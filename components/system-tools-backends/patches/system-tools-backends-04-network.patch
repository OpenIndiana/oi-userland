--- system-tools-backends-1.4.2.orig/network-conf.in	Thu Aug 21 05:46:02 2008
+++ system-tools-backends-1.4.2/network-conf.in	Thu Aug 21 05:47:16 2008
@@ -77,7 +77,8 @@
               "vine-3.0", "vine-3.1",
               "ark", 
               "slackware-9.1.0", "slackware-10.0.0", "slackware-10.1.0", "slackware-10.2.0",
-              "gentoo", "vlos-1.2", "freebsd-5", "freebsd-6");
+              "gentoo", "vlos-1.2", "freebsd-5", "freebsd-6",
+              "nexenta-1.0", "solaris-2.11");
 
 $description =<<"end_of_description;";
        Configures all network parameters and interfaces.
@@ -527,6 +528,10 @@
   if ($enabled == 0)
   {
     gst_file_run ("ifconfig $iface down");
+    if ($$tool{"system"} eq "SunOS")
+    {
+      &gst_network_sunos_nis_client_set(0);
+    }
     &drop_dhcp_connection ($iface);
     &drop_pppd_connection ($iface);
   }
@@ -550,6 +555,10 @@
   }
 
   $ret = &gst_network_enable_iface_with_config ($hash);
+  if ($$tool{"system"} eq "SunOS")
+  {
+    &gst_network_sunos_nis_client_set(1);
+  }
   &gst_report_end ();
 
   &gst_xml_print_begin  ("enable-iface");
diff -up system-tools-backends-1.4.2/network.pl.in-clean system-tools-backends-1.4.2/network.pl.in
--- system-tools-backends-1.4.2/network.pl.in-clean	2006-01-02 15:50:54.000000000 +0000
+++ system-tools-backends-1.4.2/network.pl.in	2009-03-13 11:39:51.202396844 +0000
@@ -28,8 +28,10 @@
 use Socket;
 
 $SCRIPTSDIR = "@scriptsdir@";
+$SYSCONFDIR = "@sysconfdir@";
 if ($SCRIPTSDIR =~ /^@scriptsdir[@]/)
 {
+  $SYSCONFDIR="/etc";
   $SCRIPTSDIR = ".";
   $DOTIN = ".in";
 }
@@ -117,6 +119,457 @@ sub gst_network_get_freebsd_wireless_ifa
   return \@ifaces;
 }
 
+sub gst_network_sunos_get_network_lengths
+{
+  my %netmasks;
+  open(NETMASKS, '/etc/netmasks') or return {};
+  while(my $l = <NETMASKS>) {
+    chomp $l;
+    $l =~ s/#.*//;
+    $l =~ s/^\s+//; $l =~ s/\s+$//;
+    next if $l eq '';
+    $l =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)\s+(\d+)\.(\d+)\.(\d+)\.(\d+)$/ or
+      next;
+    my @prefix = ($1, $2, $3, $4);
+    my @mask   = ($5, $6, $7, $8);
+    # calculate prefix length of the network
+    my $prefix_bin = sprintf("%08b%08b%08b%08b", @prefix[0..3]);
+    $prefix_bin =~ s/0+$//; # this would be the right thing (see ifconfig(1m))
+    # emulate Solaris apparent functionality:
+    $prefix_bin =~ s/0{1,8}$//; # only do bit-wise on the last byte
+    $prefix_bin =~ s/0{8}$//;
+    $prefix_bin =~ s/0{8}$//;
+    $prefix_bin =~ s/0{8}$//;
+    $netmasks{$prefix_bin}=\@mask;
+  }
+  return \%netmasks;
+}
+
+# Get network-part of a host using /etc/netmasks. Returns two values: network as
+# quadded-IP and prefix length of the network. Example: ('129.132.0.0', 26)
+sub gst_network_sunos_ip2network
+{
+  my ($ip) = @_;
+  $ip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;
+  my @ip = (int($1), int($2), int($3), int($4)); # don't ask me why the int are needed
+  my $netmasks = &gst_network_sunos_get_network_lengths();
+  my ($max_length, $max_ip, $max_mask);
+  for my $prefix_bin (sort keys %$netmasks) {
+    my @net = map { $ip[$_] & $netmasks->{$prefix_bin}[$_] } (0..3);
+    my $net_bin = sprintf("%08b%08b%08b%08b", @net[0..3]);
+    if($net_bin =~ /^$prefix_bin/) {
+      if(not defined $max_length or length($prefix_bin)>$max_length) {
+        my $mask_bin = sprintf("%08b%08b%08b%08b", @{$netmasks->{$prefix_bin}}[0..3]);
+        $mask_bin =~ s/0+$//;
+        ($max_ip, $max_mask, $max_length) =
+          (join('.', @net), length($mask_bin), length($prefix_bin));
+      }
+    }
+  }
+  if(defined $max_ip) {
+    return ($max_ip, $max_mask);
+  }
+  else {
+    return undef;
+  }
+}
+
+# Calculate broadcast address (quadded notation) from the network (quadded
+# notation) + prefix length (number)
+sub gst_network_sunos_network2broadcast
+{
+  my ($net, $prefix) = @_;
+  my @net = split(/\./, $net);
+  for (my $i=0; $i<4; $i++) {
+    my $prefix_byte = $prefix >= 8 ? 8 : $prefix;
+    $prefix -= $prefix_byte;
+    my $mask = ~((1 << (8-$prefix_byte)) - 1) & 255;
+    my $compl = (~ $mask) & 255;
+    $net[$i] |= $compl;
+  }
+  return join('.',@net);
+}
+
+sub gst_network_sunos_length2netmask
+{
+  my ($prefix) = @_;
+  my @mask;
+  for (my $i=0; $i<4; $i++) {
+    my $prefix_byte = $prefix >= 8 ? 8 : $prefix;
+    $prefix -= $prefix_byte;
+    $mask[$i] = ~((1 << (8-$prefix_byte)) - 1) & 255;
+  }
+  return join('.',@mask);
+}
+
+sub gst_network_sunos_gateway_get
+{
+  my ($dev) = @_;
+  my $buf = &gst_file_read_joined_lines ("/etc/defaultrouter");
+  if ($buf =~ /^\s*([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)\s*/) {
+    return $1;
+  } elsif ($buf =~ /^\s*([0-9a-zA-Z-_]+)\s*/) {
+    return &gst_network_sunos_hosts_lookup ($1);
+  } elsif ( &gst_network_sunos_bootproto_get( $dev ) eq "dhcp" ) {
+    # Try get it from DHCP information
+    my $output = &gst_file_run_backtick ("dhcpinfo -i $dev Router");
+    chomp( $output );
+    if ( $output ne "" ) {
+        return $output;
+    }
+  } elsif (($buf = &gst_network_get_default_gateway ()) ne NULL) {
+	return $buf;
+  }
+  return "";
+}
+
+sub gst_network_sunos_broadcast_get
+{
+  my ($dev) = @_;
+  my $address = &gst_network_sunos_address_get ($dev);
+  my @net = &gst_network_sunos_ip2network($address);
+  return &gst_network_sunos_network2broadcast (@net) if (defined $net[0]);
+  return ""
+}
+
+sub gst_network_sunos_network_get
+{
+  my ($dev) = @_;
+  my $address = &gst_network_sunos_address_get ($dev);
+  my @net = &gst_network_sunos_ip2network($address);
+  return $net[0] if (defined $net[0]);
+}
+
+sub gst_network_sunos_netmask_get
+{
+  my ($dev) = @_;
+  my $buf = &gst_file_read_joined_lines (&gst_network_sunos_interface($dev));
+  if ($buf =~ /\s+netmask\s+\+\s*/ ||
+      $buf =~ /^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\s*$/ ||
+      $buf =~ /^\s*[0-9a-zA-Z-_]+\s*$/) {
+    my $address = &gst_network_sunos_address_get ($dev);
+    my @net = &gst_network_sunos_ip2network($address);
+    return &gst_network_sunos_length2netmask ($net[1]) if (defined $net[1]);
+  } elsif ($buf =~ /\s+netmask\s+([0-9.]+)\s*/) {
+    return $1;
+  } elsif ( &gst_network_sunos_bootproto_get( $dev ) eq "dhcp" ) {
+    # Try get it from DHCP information
+    my $output = &gst_file_run_backtick ("dhcpinfo -i $dev Subnet");
+    chomp( $output );
+    if ( $output ne "" ) {
+        return $output;
+    }
+  }
+
+  return "255.0.0.0";
+}
+
+sub gst_network_sunos_address_get
+{
+  my ($dev) = @_;
+  my $buf = &gst_file_read_joined_lines (&gst_network_sunos_interface($dev));
+
+  if ($buf =~ /^\s*([0-9.]+)\s*/) {
+    return $1;
+  } elsif ($buf =~ /^\s*([0-9a-zA-Z-_]+)\s*/) {
+    return &gst_network_sunos_hosts_lookup ($1);
+  } elsif ( &gst_network_sunos_bootproto_get( $dev ) eq "dhcp" ) {
+    # Try get it from DHCP information
+    my $output = &gst_file_run_backtick ("dhcpinfo -i $dev Yiaddr");
+    chomp( $output );
+    if ( $output ne "" ) {
+        return $output;
+    }
+  }
+
+  return "";
+}
+
+sub gst_network_sunos_name_get
+{
+  my ($dev) = @_;
+  return $dev;
+}
+
+sub gst_network_sunos_ipmask2network
+{
+  my ($ip, $mask) = @_;
+  my ($b1, $b2);
+  my @maskbyte = split /\./, $mask;
+  my @ipbyte = split /\./, $ip;
+  for (my $i=0; $i < 4; $i++) {
+    $b1 = $maskbyte[$i]+0;
+    $b2 = $ipbyte[$i]+0;
+    $netbyte = $b1 & $b2;
+    if ($i != 0) {
+      $netaddr = $netaddr . "." . $netbyte;
+    } else {
+      $netaddr = $netbyte;
+    }
+  }
+  return $netaddr;
+}
+
+sub gst_network_sunos_address_set
+{
+  my ($dev, $addr) = @_;
+  my ($file) = &gst_network_sunos_interface($dev);
+
+  if (-e $file) {
+    my $buf = &gst_file_read_joined_lines ($file);
+    if ($buf =~ /^\s*([0-9.]+)(\s*.*)/) {
+      &gst_file_remove ($file);
+      &gst_file_buffer_save ("$addr$2\n", $file);
+    } elsif ($buf =~ /^\s*([0-9a-zA-Z-_]+)\s*/) {
+      my $host = $1;
+      my $updated = 0;
+      local (*INFILE, *OUTFILE);
+
+      # /etc/hosts and /etc/inet/ipnodes have been merged and are the same
+      # file now in the latest Solaris builds, but it may be that they remain
+      # separate on this system for historic reasons.
+      my @stat_hosts = stat( $hosts );
+      my @stat_ipnodes = stat( $ipnodes );
+      my $single_hosts_file = "@stat_hosts" eq "@stat_ipnodes";
+      
+      unless ( $single_hosts_file ) {
+        my ($ifh, $ofh) = &gst_file_open_filter_write_from_names("/etc/inet/ipnodes");
+        if (not $ofh) { return; }  # No point if we can't write.
+        *INFILE = $ifh; *OUTFILE = $ofh;
+        while (<INFILE>) {
+          if (/^\s*([0-9a-fA-F.:]+)\s+(.*$host.*)/) {
+            $updated = 1;
+            print OUTFILE "$addr\t$2\n";
+            next;
+          }
+          print OUTFILE $_;
+        }
+        close INFILE;
+        close OUTFILE;
+      }
+
+      my ($ifh, $ofh) = &gst_file_open_filter_write_from_names("/etc/hosts");
+      if (not $ofh) { return; }  # No point if we can't write.
+      *INFILE = $ifh; *OUTFILE = $ofh;
+      while (<INFILE>) {
+        # Check IPv6 Addr, if we are looking at merged files.
+        if ($single_hosts_file && /^\s*([0-9a-fA-F.:]+)\s+(.*$host.*)/) { 
+          $updated = 1;
+          print OUTFILE "$addr\t$2\n";
+          next;
+        }
+        if (/^\s*[0-9.]+(\s+.*$host.*)/) {          # Check IPv4 Addr
+          $updated = 1;
+          print OUTFILE "$addr$1\n";
+          next;
+        }
+        print OUTFILE $_;
+      }
+      close INFILE;
+
+      print OUTFILE "$addr\t\t$host\n" if (!$updated);
+      close OUTFILE;
+
+    } else {
+      &gst_file_remove ($file);
+      &gst_file_buffer_save ("$addr\n", $file);
+    }
+  } else {
+    &gst_file_buffer_save ("$addr\n", $file);
+  }
+}
+
+sub gst_network_sunos_netmask_set
+{
+  my ($dev, $addr, $mask) = @_;
+  my ($file) = &gst_network_sunos_interface($dev);
+  my $buf = &gst_file_read_joined_lines ($file);
+  if ($buf =~ /^(\s*.*\s+netmask\s+)[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\s*.*)/) {
+      &gst_file_remove ($file);
+      &gst_file_buffer_save ("$1$mask$2", $file);
+  } elsif (-e "/etc/netmasks" &&
+      ($buf =~ /^\s*([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)\s*$/ ||
+       $buf =~ /^\s*(.*\s+netmask\s+)\+(\s*.*)/ ||
+       $buf =~ /^\s*([0-9a-zA-Z-_]+)\s*$/)) {
+    my $updated = 0;
+    my $net = &gst_network_sunos_ipmask2network($addr, $mask);
+    local (*INFILE, *OUTFILE);
+    my ($ifh, $ofh) = &gst_file_open_filter_write_from_names("/etc/netmasks");
+    if (not $ofh) { return; }  # No point if we can't write.
+    *INFILE = $ifh; *OUTFILE = $ofh;
+    while (<INFILE>) {
+      if (/^\s*$net(\s+)[0-9.]+(.*)/) {
+        $updated = 1;
+        print OUTFILE "$net$1$mask$2\n";
+        next;
+      }
+      print OUTFILE $_;
+    }
+    close INFILE;
+    print OUTFILE "$net\t\t$mask\n" if (!$updated);
+    close OUTFILE;
+  } elsif (! -e "/etc/netmasks") {
+    my $net = &gst_network_sunos_ipmask2network($addr, $mask);
+    &gst_file_buffer_save ("$net\t\t$mask\n", "/etc/netmasks");
+  }
+}
+
+sub gst_network_sunos_remote_address_set
+{
+  my ($dev, $addr) = @_;
+}
+
+sub gst_network_sunos_gateway_set
+{
+  my ($dev, $gateway) = @_;
+
+  return if ( -e "/etc/dhcp.$dev" || -e "$SYSCONFDIR/inet/gnome-system-tools/dhcp.$dev" );
+
+  # Save the default route - but only if the i/f is configured and not DHCP
+  if ( -e "/etc/hostname.$dev" || -e "/etc/hostname6.$dev" ) {
+      &gst_file_buffer_save ("$gateway\n", "/etc/defaultrouter");
+  }
+  elsif ( -e "$SYSCONFDIR/inet/gnome-system-tools/hostname.$dev" || 
+          -e "$SYSCONFDIR/inet/gnome-system-tools/hostname6.$dev" ) {
+      &gst_file_buffer_save ("$gateway\n", "$SYSCONFDIR/inet/gnome-system-tools/defaultrouter.$dev");
+  }
+}
+
+# We can't get the real WEP key, so use a token we will recognise later so
+# as to know when a value wasn't specified.
+my $sunos_secure_wep_key_placeholder = "gst-secure-wep-key-placeholder";
+
+sub gst_network_sunos_wireless_set
+{
+  my ($dev, $opt, $value) = @_;
+  my $key = "";
+  # set profile name based on the ESSID
+  my $essid = "";
+  if ( $opt eq "essid" ) {
+    $essid = $value;
+  }
+  else {
+    # Need to get the essid!
+    $essid = &gst_network_sunos_wireless_get ($dev, "essid");
+  }
+
+  my $profile = &gst_network_sunos_profile_from_essid( $essid );
+
+  if ($opt eq "essid") {
+    &gst_file_run ("wificonfig setprofileparam $profile essid='$value'");
+  } elsif ($opt eq "key_type") {
+    $key = &gst_network_sunos_wireless_get($dev, "key");
+    if (defined($key) && $key ne $sunos_secure_wep_key_placeholder) {
+       # We'll do this in the set of "key" below, instead
+       return;
+    }
+    # no key, or key is reserved value still
+    &gst_file_run ("wificonfig setprofileparam $profile encryption=none");
+  } elsif ($opt eq "key" && $value ne $sunos_secure_wep_key_placeholder ) {
+    # key is really set; set encryption=wep, and key value/index
+    &gst_file_run ("wificonfig setprofileparam $profile encryption=wep");
+    &gst_file_run ("wificonfig setprofileparam $profile wepkey1=$value");
+    &gst_file_run ("wificonfig setprofileparam $profile wepkeyindex=1");
+  }
+}
+
+sub gst_network_sunos_wireless_get
+{
+  my ($dev, $opt) = @_;
+  my ($fd, $essid, $key_type);
+  
+  return undef unless gst_network_sunos_check_if_wireless( $dev );
+
+  $fd = &gst_file_run_pipe_read ("wificonfig -i $dev getparam");
+  return {} if $fd eq undef;
+  while (<$fd>) {
+    if (/essid:\s+(.*)/) {
+      $essid =  $1;
+      return $essid if ($opt eq "essid");
+    }
+    if (/encryption:\s+(.*)/) {
+      $key_type = $1;
+      return $key_type if ($opt eq "key_type");
+    }
+    if (/wepkeyindex:\s+(.*)/) {
+      # We can't get the real key, so set a token we will recognise later so
+      # as to know when a value wasn't specified.
+      return $sunos_secure_wep_key_placeholder; 
+    }
+  }
+  &gst_file_close ($fd);
+  return "";
+}
+
+sub gst_network_sunos_check_if_wireless
+{
+  my ($dev) = @_;
+  my ($ret);
+
+  $ret = 0;
+
+  $fd = &gst_file_run_pipe_read ("wificonfig -i $dev showstatus");
+  return $ret if $fd eq undef;
+  while (<$fd>) {
+    if (/linkstatus:/) {
+      $ret = 1;
+	  last;
+      }
+  }
+  &gst_file_close ($fd);
+
+  &gst_report_leave ();
+
+  return $ret;
+}
+
+sub gst_network_get_sunos_wireless_ifaces
+{
+  my ($fd, $dev);
+  my (@ifaces);
+
+  my $allifaces = &gst_network_sunos_interfaces_get_info();
+  foreach $dev (keys %$allifaces) {
+    $fd = &gst_file_run_pipe_read ("wificonfig -i $dev showstatus");
+    return {} if $fd eq undef;
+    while (<$fd>) {
+      if (/linkstatus:/) {
+        push @ifaces, $dev;
+	last;
+      }
+    }
+    &gst_file_close ($fd);
+  }
+
+  &gst_report_leave ();
+  return \@ifaces;
+}
+
+sub gst_network_get_sunos_ethernet_and_wireless_ifaces
+{
+  my ($fd, $dev);
+  my (@ifaces);
+
+  # First let's get all ethernet and wireless interfaces
+  $fd = &gst_file_run_pipe_read ("dladm show-link -p -o LINK");
+
+  unless ($fd eq undef)  {
+    while (<$fd>)
+    {
+      chomp;
+      if (/^\s*(\S*)\s*/)
+      {
+        push @ifaces, $1;
+      }
+    }
+    &gst_file_close ($fd);
+  }
+
+  &gst_report_leave ();
+  return \@ifaces;
+}
+
+
 # Returns an array with the wireless devices found
 sub gst_network_get_wireless_ifaces
 {
@@ -124,6 +577,7 @@ sub gst_network_get_wireless_ifaces
     
   return &gst_network_get_linux_wireless_ifaces   if ($plat eq "Linux");
   return &gst_network_get_freebsd_wireless_ifaces if ($plat eq "FreeBSD");
+  return &gst_network_get_sunos_wireless_ifaces if ($plat eq "SunOS");
 }
 
 # set of functions for enabling an interface
@@ -138,39 +592,171 @@ sub gst_network_config_wireless
 
   if ($essid)
   {
+    $command  = "wificonfig" if ($$tool{"system"} eq "SunOS");
     $command  = $command_iwconfig if ($$tool{"system"} eq "Linux");
     $command  = $command_ifconfig if ($$tool{"system"} eq "FreeBSD");
 
-    $command .= " $dev";
-    $command .= " essid '$essid'" if ($essid);
+    if ($$tool{"system"} eq "SunOS") {
+      my ($profile) = &gst_network_sunos_profile_from_essid( $essid );
 
-    if ($key)
-    {
-      $key = &gst_network_get_full_key ($key, $key_type);
-      $command .= " key '$key'";
+      my $command_withdev = $command . " -i $dev";
+      my $profile_info = &gst_file_run_backtick("$command showprofile $profile");
+      if ( $profile_info =~ /^\s*$/ ) {
+        &gst_file_run ("$command deleteprofile $profile");
+        &gst_file_run ("$command createprofile $profile essid='$essid'");
+      }
+      &gst_file_run ("$command setprefer $profile 1");
+    
+      &gst_network_sunos_wireless_set($dev, "essid", $essid ) if ( $essid );
+      &gst_network_sunos_wireless_set($dev, "key_type", $key_type ) if ( $essid );
+      &gst_network_sunos_wireless_set($dev, "key", $key ) if ( $key );
+    } else {
+      $command .= " $dev";
+      $command .= " essid '$essid'" if ($essid);
+
+      if ($key)
+      {
+        $key = &gst_network_get_full_key ($key, $key_type);
+        $command .= " key '$key'";
+      }
+      else
+      {
+        $command .= " key off";
+      }
+      &gst_file_run ($command);
     }
-    else
-    {
-      $command .= " key off";
+  }
+}
+
+sub gst_network_sunos_nis_state_get
+{
+  my ($fd, $nis_state);
+
+  $fd = &gst_file_run_pipe_read ("svcs -l nis/client");
+  return {} if $fd eq undef;
+  $nis_state = "";
+  while (<$fd>) {
+    if (/^\s*enabled\s*(\w*)\s+(.*)/) {
+      $nis_state = $1;
+      $nis_state = "$1_temporary" if ( $2 eq "(temporary)");
+      last;
+    }
+  }
+  &gst_file_close ($fd);
+  return $nis_state;
+}
+
+sub gst_network_sunos_nis_is_available
+{
+  my ($fd, $is_available);
+
+  $fd = &gst_file_run_pipe_read ("ypwhich");
+  return 0 if $fd eq undef;
+  $is_available = 0;
+  while (<$fd>) {
+    if (/^([_0-9a-zA-Z\.]+)/) {
+      $is_available = 1;
+      last;
     }
+  }
+  &gst_file_close ($fd);
+  return $is_available;
+}
+
+sub gst_network_sunos_set_nsswitch
+{
+  my ($namesvc) = @_;
+  my ($new_nsswitch, $old_nsswitch);
 
-    &gst_file_run ($command);
+  $old_nsswitch = "/etc/nsswitch.conf";
+  $new_nsswitch = undef;
+
+  if ( $namesvc eq "dns" ) {
+      $new_nsswitch = "/etc/nsswitch.dns";
+  }
+  elsif ( $namesvc eq "nis" ) {
+      $new_nsswitch = "/etc/nsswitch.nis";
+  }
+
+  if ( $new_nsswitch ) {
+    &gst_file_backup( $old_nsswitch ) if (&gst_file_exists ($old_nsswitch));
+
+    &gst_file_copy( $new_nsswitch, $old_nsswitch );
+  }
+}
+
+
+sub gst_network_sunos_nis_client_set
+{
+  my ($enable) = @_;
+  my $nis_state, $nis_is_available;
+
+  $nis_state = &gst_network_sunos_nis_state_get();
+  if ($enable == 1)
+  {
+    if ($nis_state eq "false_temporary")
+    {
+      &gst_file_run ("svcadm enable svc:/network/nis/client");
+      $nis_is_available = &gst_network_sunos_nis_is_available();
+      if (not $nis_is_available)
+      {
+      	&gst_file_run ("svcadm disable -t svc:/network/nis/client");
+        &gst_network_sunos_set_nsswitch( "dns" );
+      }
+      else 
+      {
+        &gst_network_sunos_set_nsswitch( "nis" );
+      }
+    }
+  } else {
+    $nis_is_available = &gst_network_sunos_nis_is_available();
+    if ( (($nis_state eq "true") || ($nis_state eq "true_temporary")) && not $nis_is_available )
+      {
+        gst_file_run ("svcadm disable -t svc:/network/nis/client");
+      }
+    &gst_network_sunos_set_nsswitch( "dns" );
   }
 }
 
 sub gst_network_enable_iface
 {
   my ($hash, $dev, $command_ifconfig) = @_;
-  my ($address, $netmask, $bootproto, $remote_address);
+  my ($essid, $address, $netmask, $bootproto, $remote_address);
 
+  $essid          = $$hash{"configuration"}{"essid"};
   $address        = $$hash{"configuration"}{"address"};
   $netmask        = $$hash{"configuration"}{"netmask"};
   $bootproto      = $$hash{"configuration"}{"bootproto"};
   $remote_address = $$hash{"configuration"}{"remote_address"};
 
+  my %dist_attrib = &gst_network_get_parse_table ();
+  my $resolv_conf = $dist_attrib{"fn"}{"RESOLV_CONF"};
+
   if ($bootproto eq "dhcp")
   {
-    if (&gst_file_locate_tool ("dhclient3"))
+    if ($$tool{"system"} eq "SunOS")
+    {
+
+      &gst_file_run ("ifconfig $dev plumb"); # XXX - inet6???
+      if (&gst_network_get_interface_type($dev) eq "wireless" ) {
+        my $profile = &gst_network_sunos_profile_from_essid( $essid );
+        &gst_file_run ("wificonfig -i $dev disconnect");
+        if ( $profile eq "gst_default" ) {
+            return -1 if (&gst_file_run ("wificonfig -i $dev startconf wait=20"));
+        }
+        else {
+            return -1 if (&gst_file_run ("wificonfig -i $dev connect $profile wait=20"));
+        }
+      }
+      $command  = "ifconfig";
+      $command .= " $dev";
+      $command .= " auto-dhcp wait 45";
+      # Apparently the default action for dhcpagent is to erase
+      # /etc/resolv.conf - so we needto back it up!
+      &gst_file_remove ("$SYSCONFDIR/inet/gnome-system-tools/resolv.conf.$dev.bak");
+      &gst_file_run ("cp -p $resolv_conf $SYSCONFDIR/inet/gnome-system-tools/resolv.conf.$dev.bak");
+    }
+    elsif (&gst_file_locate_tool ("dhclient3"))
     {
       $command = "dhclient3 -pf /var/run/dhclient.$dev.pid $dev";
     }
@@ -189,11 +775,36 @@ sub gst_network_enable_iface
     $command .= " $dev";
     $command .= " $address" if ($address);
     $command .= " netmask $netmask" if ($netmask);
-    $command .= " dstaddr $remote_address" if ($remote_address);
+    if ($$tool{"system"} eq "SunOS") {
+      $command .= " destination $remote_address" if ($remote_address);
+    } else {
+      $command .= " dstaddr $remote_address" if ($remote_address);
+    }
     $command .= " up";
   }
 
-  return &gst_file_run ($command);
+  $ret = &gst_file_run ($command);
+  if ($ret == 0 && $bootproto eq "dhcp" && $$tool{"system"} eq "SunOS") {
+    # ifconfig $dev auto-dhcp may overwrite /etc/resolv.conf
+    # so, we save it on per-device basis and restore original one...
+    &gst_file_run ("cp -p $SYSCONFDIR/inet/gnome-system-tools/resolv.conf.$dev.bak $resolv_conf");
+    # Now we need to merge this resolv.conf file now with the new DHCP
+    # settings
+    my $domainname = &gst_file_run_backtick ("dhcpinfo -i $dev DNSdmain");
+    chomp( $domainname );
+    my $nameservers_str = &gst_file_run_backtick ("dhcpinfo -i $dev DNSserv");
+    my @nameservers = split(/\s+/, $nameservers_str);
+    chomp( @nameservers );
+    my $newipaddr = &gst_file_run_backtick ("dhcpinfo -i $dev Yiaddr");
+    chomp( $newipaddr );
+
+    &gst_replace_join_first_str( $resolv_conf, "domain", "[ \t]+", $domainname ) if ( $domainname );
+    &gst_replace_join_all( $resolv_conf, "nameserver", "[ \t]+", \@nameservers ) if ( $#nameservers >= 0 );
+
+    &gst_file_run ("svcadm restart svc:/network/service"); # Restart name services
+    &gst_file_run ("svcadm restart svc:/system/name-service-cache"); # Restart name services cache
+  }
+  return $ret;
 }
 
 sub gst_network_get_chat_file
@@ -352,6 +963,10 @@ sub gst_network_autodetect_modem
   {
     @arr = ("/dev/modem", "/dev/cuaa0", "/dev/cuaa1", "/dev/cuaa2", "/dev/cuaa3");
   }
+  elsif ($$tool{"system"} eq "SunOS")
+  {
+    @arr = ("/dev/modem", "/dev/cua/a", "/dev/cua/b", "/dev/cua/c", "/dev/cua/d");
+  }
   
   foreach $tty (@arr) {
     $temp = `pppd lcp-max-configure 1 nodetach noauth nocrtscts $tty connect \"chat -t1 \'\' AT OK\" 2>/dev/null`;
@@ -480,7 +1095,9 @@ sub gst_network_get_broadcast_ping_cmd
   my %cmd_map =
       (
        "debian-2.2" => "ping -c 2 -i 1 -n $bcast",
-       "redhat-6.2" => "ping -c 2 -i 1 -n -b $bcast"
+       "redhat-6.2" => "ping -c 2 -i 1 -n -b $bcast",
+       "nexenta" => "ping -I 1 -s $bcast 56 2",
+       "solaris" => "ping -I 1 -s $bcast 56 2"
        );
   my %dist_map =
       (
@@ -499,6 +1116,8 @@ sub gst_network_get_broadcast_ping_cmd
        "ubuntu-5.04"  => "debian-2.2",
        "ubuntu-5.10"  => "debian-2.2",
        "ubuntu-6.04"  => "debian-2.2",
+       "nexenta-1.0" => "nexenta",       
+       "solaris-2.11" => "solaris",       
        "mandrake-7.1" => "debian-2.2",
        "mandrake-7.2" => "debian-2.2",
        "mandrake-9.0" => "debian-2.2",
@@ -778,6 +1397,8 @@ sub gst_network_get_interface_type
 {
   my ($dev) = @_;
   my (@wireless_ifaces, $wi, $type);
+  my (@ethernet_ifaces, $eth, $type);
+  my ($plat) = $$tool{"system"};
 
   return $types_cache{$dev} if (exists $types_cache{$dev});
 
@@ -804,7 +1425,7 @@ sub gst_network_get_interface_type
       $types_cache{$dev} = "modem";
     }
   }
-  elsif ($dev =~ /^(eth|dc|ed|bfe|em|fxp|bge|de|xl|ixgb|txp|vx|lge|nge|pcn|re|rl|sf|sis|sk|ste|ti|tl|tx|vge|vr|wb|cs|ex|ep|fe|ie|lnc|sn|xe|le|an|awi|wi|ndis|wlaue|axe|cue|kue|rue|fwe|nve)[0-9]/)
+  elsif ($dev =~ /^(ath|eth|dc|ed|bfe|em|fxp|bge|bcme|de|xl|ixgb|iwi|ipw|pcwl|pciwl|txp|vx|lge|nge|pcn|re|rl|sf|sis|sk|ste|ti|tl|tx|vge|vr|wb|cs|ex|ep|fe|ie|lnc|sn|xe|le|an|awi|wi|.*ndis|wlaue|axe|cue|kue|rue|fwe|nve)[0-9]/)
   {
     $types_cache{$dev} = "ethernet";
   }
@@ -820,6 +1441,19 @@ sub gst_network_get_interface_type
   {
     $types_cache{$dev} = "loopback";
   }
+  elsif ($plat eq "SunOS")
+  {
+    #check whether interface is ethernet 
+    $ethernet_ifaces = &gst_network_get_sunos_ethernet_and_wireless_ifaces ();
+    foreach $eth (@$ethernet_ifaces)
+    {
+      if ($dev eq $eth)
+      {
+        $types_cache{$dev} = "ethernet";
+        return $types_cache{$dev};
+      }
+    }
+  }
 
   return $types_cache{$dev};
 }
@@ -895,12 +1529,73 @@ sub gst_network_linux_interfaces_get_inf
   return \%ifaces;
 }
 
+sub gst_network_sunos_interfaces_get_info
+{
+  my ($dev, %ifaces, $fd);
+
+  &gst_report_enter ();
+  &gst_report ("network_iface_active_get");
+
+  # First let's get all real network nterfaces known to the kernel
+  $fd = &gst_file_run_pipe_read ("dladm show-link -p -o LINK");
+
+  unless ($fd eq undef)  {
+    while (<$fd>)
+    {
+      chomp;
+      if (/^\s*(\S*)\s*/)
+      {
+        $dev = $1;
+        $ifaces{$dev}{"dev"}    = $dev;
+        $ifaces{$dev}{"enabled"} = 0;
+      }
+    }
+    
+    &gst_file_close ($fd);
+  }
+
+  # Now let's get more info on the plumbed interfaces
+  $fd = &gst_file_run_pipe_read ("ifconfig -a");
+  return {} if $fd eq undef;
+  
+  while (<$fd>)
+  {
+    chomp;
+    if (/^\s*(.*):\s+.*(<.*>)/)
+    {
+      $dev = $1;
+      $ifaces{$dev}{"dev"}    = $dev;
+      $ifaces{$dev}{"enabled"} = 0;
+      $ifaces{$dev}{"enabled"} = 1 if ($2 =~ /[<,]UP[,>]/);
+    }
+    
+    s/^[ \t]+//;
+    if ($dev)
+    {
+      $ifaces{$dev}{"hwaddr"}  = $1 if /ether[ \t]+([^ \t]+)/i;
+      $ifaces{$dev}{"addr"}    = $1 if /inet[ \t]+([^ \t]+)/i;
+      $ifaces{$dev}{"mask"}    = $1 if /netmask[ \t]+([^ \t]+)/i;
+      $ifaces{$dev}{"bcast"}   = $1 if /broadcast[ \t]+([^ \t]+)/i;
+      if ( $ifaces{$dev}{"mask"} =~ /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ )
+       {
+        $ifaces{$dev}{"mask"} = sprintf ("%d.%d.%d.%d", hex($1), hex($2), hex($3), hex($4));
+       }
+    }
+  }
+  
+  &gst_file_close ($fd);
+
+  &gst_report_leave ();
+  return \%ifaces;
+}
+
 sub gst_network_interfaces_get_info
 {
   my (%ifaces);
 
   $ifaces = &gst_network_linux_interfaces_get_info   if ($$tool{"system"} eq "Linux");
   $ifaces = &gst_network_freebsd_interfaces_get_info if ($$tool{"system"} eq "FreeBSD");
+  $ifaces = &gst_network_sunos_interfaces_get_info if ($$tool{"system"} eq "SunOS");
 
   foreach $dev (keys %$ifaces)
   {
@@ -925,12 +1620,18 @@ sub gst_network_active_interfaces_get
   &gst_report_enter ();
   &gst_report ("network_iface_active_get");
 
-  $fd = &gst_file_run_pipe_read ("ifconfig");
+  if ($$tool{"system"} eq "SunOS") {
+      $fd = &gst_file_run_pipe_read ("ifconfig -a");
+  }
+  else {
+      $fd = &gst_file_run_pipe_read ("ifconfig");
+  }
   return undef if $fd eq undef;
   
   while (<$fd>)
   {
     chomp;
+    next if ( $$tool{"system"} eq "SunOS" && !/^[^:]+:.*[<,]UP[,>].*$/ );
     s/:? .*//;
     next if /^$/;
     push @ret, $_;
@@ -1182,6 +1883,208 @@ sub gst_network_freebsd_ifaces_get_exist
   return @ret;
 }
 
+sub gst_network_sunos_auto_get
+{
+  my ($iface) = @_;
+
+  return 1 if (-e "/etc/hostname.$iface");
+  return 1 if (-e "/etc/hostname6.$iface"); #IPv6
+  return 0;
+}
+
+# Set an interface to come up on boot... "auto"
+sub gst_network_sunos_auto_set
+{
+  my ($iface, $active) = @_;
+
+  return if ( $iface =~ /\(lo|xx\)[0-9]/ ); # Don't do this for xx[0-9] or lo0
+
+  &gst_report_enter();
+
+  my %dist_attrib = &gst_network_get_parse_table ();
+  my $resolv_conf = $dist_attrib{"fn"}{"RESOLV_CONF"};
+
+  &gst_report("gst_network_sunos_auto_set", $iface, $active );
+
+  # If we want the i/f to come up on boot, the files should be in /etc, if
+  # not, we need to move the configuration to /etc/inet/gnome-system-tools
+  # where we store the configuration in the absence of such a mechanism
+  # already on Solaris.
+  if ($active == 1) {
+    if (-e "$SYSCONFDIR/inet/gnome-system-tools/hostname.$iface") {
+      &gst_file_run ("mv $SYSCONFDIR/inet/gnome-system-tools/hostname.$iface /etc/hostname.$iface");
+    } else {
+      &gst_file_run ("touch /etc/hostname.$iface");
+    }
+    if (-e "$SYSCONFDIR/inet/gnome-system-tools/hostname6.$iface") {
+      &gst_file_run ("mv $SYSCONFDIR/inet/gnome-system-tools/hostname6.$iface /etc/hostname6.$iface");
+    } else { 
+      # XXX - IPv6 not enabled.
+    }
+    if (-e "$SYSCONFDIR/inet/gnome-system-tools/dhcp.$iface") {
+      &gst_file_run ("mv $SYSCONFDIR/inet/gnome-system-tools/dhcp.$iface /etc/dhcp.$iface");
+    }
+    if (-e "$SYSCONFDIR/inet/gnome-system-tools/resolv.conf.$iface") {
+      &gst_file_run ("mv $SYSCONFDIR/inet/gnome-system-tools/resolv.conf.$iface $resolv_conf");
+    }
+    if (-e "$SYSCONFDIR/inet/gnome-system-tools/defaultrouter.$iface") {
+      &gst_file_run ("mv $SYSCONFDIR/inet/gnome-system-tools/defaultrouter.$iface /etc/defaultrouter");
+    }
+  } else {
+    # XXX - Save configuration, i.e. hostname and dhcp file.
+    if (-e "/etc/hostname.$iface") {
+      &gst_file_run ("mv /etc/hostname.$iface $SYSCONFDIR/inet/gnome-system-tools/hostname.$iface");
+    }
+    else {
+      &gst_file_run ("touch $SYSCONFDIR/inet/gnome-system-tools/hostname.$iface");
+    }
+    if (-e "/etc/hostname6.$iface") {
+      &gst_file_run ("mv /etc/hostname6.$iface $SYSCONFDIR/inet/gnome-system-tools/hostname6.$iface");
+    }
+    if (-e "/etc/dhcp.$iface") {
+      &gst_file_run ("mv /etc/dhcp.$iface $SYSCONFDIR/inet/gnome-system-tools/dhcp.$iface");
+    }
+    if (-e "$resolv_conf") {
+      &gst_file_run ("cp -p $SYSCONFDIR/inet/gnome-system-tools/resolv.conf.$iface $resolv_conf");
+    }
+    if (-e "/etc/defaultrouter") {
+      &gst_file_run ("mv /etc/defaultrouter $SYSCONFDIR/inet/gnome-system-tools/defaultrouter.$iface");
+    }
+  }
+
+  &gst_report_leave();
+}
+
+# Check to see if the device is configured as DHCP - look in /etc and saved
+# configuration.
+# XXX - Need to check if we are doing the right thing here.
+sub gst_network_sunos_bootproto_get
+{
+  my ($dev) = @_;
+
+  my $fd = &gst_file_run_pipe_read("ls /etc/dhcp.* $SYSCONFDIR/inet/gnome-system-tools/dhcp.*");
+  return undef if (!$fd);
+
+  while (<$fd>) {
+    if (/\.?dhcp\.(.*)/) {
+      next if ($1 eq "xx0");
+      return "dhcp" if ($1 eq $dev);
+    }
+  }
+
+  &gst_file_close ($fd);
+  return "none";
+}
+
+sub gst_network_sunos_bootproto_set
+{
+  my ($iface, $value) = @_;
+
+  # Remove or create "DHCP" related configuration files.
+  if ($value eq "none") {
+    &gst_file_remove ("/etc/dhcp.$iface");
+    &gst_file_remove ("$SYSCONFDIR/inet/gnome-system-tools/dhcp.$iface");
+  } elsif ($value eq "dhcp") {
+    if (-e "/etc/hostname.$iface" || -e "/etc/hostname6.$dev" ) {
+      &gst_file_run ("touch /etc/dhcp.$iface");
+    } elsif (-e "$SYSCONFDIR/inet/gnome-system-tools/hostname.$iface" || 
+             -e "$SYSCONFDIR/inet/gnome-system-tools/hostname6.$iface") {
+      &gst_file_run ("touch $SYSCONFDIR/inet/gnome-system-tools/dhcp.$iface");
+    }
+  }
+}
+
+sub gst_network_sunos_interface_activate
+{
+  my ($hash, $old_hash, $enabled, $force) =@_;
+
+  my %dist_attrib = &gst_network_get_parse_table ();
+  my $resolv_conf = $dist_attrib{"fn"}{"RESOLV_CONF"};
+
+
+  # This is called on pressing "OK" - should only really restart the network
+  # based on the configuration currently set.
+
+  &gst_report_enter ();
+
+  if ($force || &gst_network_interface_changed ($hash, $old_hash))
+  {
+    my ($dev) = $$hash{"configuration"}{"file"};
+    my ($auto) = $$hash{"configuration"}{"auto"};
+    if ($enabled)
+    {
+      &gst_report ("gst_network_sunos_interface_activate", $dev);
+      if ( $auto ) {
+        &gst_file_run ("svcadm restart svc:/network/physical"); # Restart physical network interfaces 
+        &gst_file_run ("svcadm restart svc:/network/service"); # Restart name services
+        &gst_file_run ("svcadm restart svc:/system/name-service-cache"); # Restart name services cache
+      }
+      else { # Can't do above since no /etc/hostname.<if> file, so try simply
+             # use enable_with_config
+        &gst_network_enable_iface_with_config( $hash );
+      }
+    }
+    else 
+    {
+      # XXX - Should I unplumb the network now? Will be marked as down
+      # later... 
+      &gst_report ("gst_network_sunos_interface_deactivate", $dev);
+      # Unplumb an i/f that's up, and is no longer configured
+      &gst_file_run ("ifconfig $dev unplumb") unless ( -e "/etc/hostname.$dev" || -e "/etc/hostname6.$dev" );  
+      &gst_file_run ("svcadm restart svc:/network/physical"); # Restart physical network interfaces 
+      &gst_file_run ("svcadm restart svc:/network/service"); # Restart name services
+      &gst_file_run ("svcadm restart svc:/system/name-service-cache"); # Restart name services cache
+    }
+  }
+  &gst_report_leave ();
+}
+
+sub gst_network_sunos_profile_from_essid
+{
+    my ($essid) = @_;
+    my $profilename;
+
+    $profilename = $essid;
+    $profilename =~ s/\W/_/g;
+
+    $profilename = "gst_default" unless ( $profilename );
+
+    return $profilename
+}
+
+sub gst_network_sunos_interface_delete
+{
+    # XXX - Shouldn't we be removing all references to the interface here??
+}
+
+# Generate the name of the file that exists for the interface...
+sub gst_network_sunos_interface
+{
+  my ($dev) = @_;
+  my ($file) = "hostname." . $dev;
+  return "/etc/$file" if (-e "/etc/$file");
+  return "$SYSCONFDIR/inet/gnome-system-tools/$file";
+}
+
+# What existing configurations exist...
+sub gst_network_sunos_ifaces_get_existing
+{
+  my @ret;
+
+  my $fd = &gst_file_run_pipe_read("ls /etc/hostname.* /etc/hostname6.* $SYSCONFDIR/inet/gnome-system-tools/hostname.* $SYSCONFDIR/inet/gnome-system-tools/hostname6.*");
+  return undef if (!$fd);
+
+  while (<$fd>) {
+    if (/hostname6?\.(.*)/) {
+      next if ($1 eq "xx0");
+      push @ret, $1;
+    }
+  }
+
+  &gst_file_close ($fd);
+  return @ret;
+}
+
 sub gst_network_suse70_parse_iface_num
 {
   my ($file, $dev) = @_;
@@ -1637,9 +2540,7 @@ sub gst_network_interfaces_get
   # clear unneeded hash elements
   foreach $i (keys %$hash)
   {
-    delete $$hash{$i}{"addr"};
     delete $$hash{$i}{"bcast"};
-    delete $$hash{$i}{"mask"};
   }
 
   foreach $i (@ifaces)
@@ -1672,7 +2573,7 @@ sub gst_network_interfaces_get
   $dev = "ppp0" if ($$tool{"system"} eq "Linux");
   $dev = "tun0" if ($$tool{"system"} eq "FreeBSD");
 
-  if (!exists $$hash{$dev} && &gst_file_locate_tool ("pppd"))
+  if ($dev && !exists $$hash{$dev} && &gst_file_locate_tool ("pppd"))
   {
     $$hash{$dev}{"dev"} = $dev;
     $$hash{$dev}{"enabled"} = 0;
@@ -1683,6 +2584,63 @@ sub gst_network_interfaces_get
   return \%$hash;
 }
 
+sub gst_network_sunos_search_in_hosts
+{
+  my ($list, $host) = @_;
+  my @arr = (values %$list);
+  my @keys = (keys %$list);
+  for (my $i = 0; $i < length(@arr); $i++) {
+  	for (my $j = 0; $j < length(@arr[$i]); $j++) {
+		return $keys[$i] if ($host eq $arr[$i][$j]);
+	}
+  }
+  return "";
+}
+ 
+sub gst_network_sunos_hosts_lookup
+{
+  my ($host) = @_;
+  my $fd;
+  
+  $fd = &gst_file_open_read_from_names ("/etc/hosts");
+  return undef if !$fd;
+  while (<$fd>) {
+    return $1 if (/^\s*([0-9.]+).*\s+$host.*/);
+  }
+  &gst_file_close ($fd);
+  
+  $fd = &gst_file_open_read_from_names ("/etc/inet/ipnodes");
+  return undef if !$fd;
+  while (<$fd>) {
+    return $1 if (/^\s*([0-9.]+).*\s+$host.*/)
+  }
+  &gst_file_close ($fd);
+
+  return "";
+}
+
+
+sub gst_network_sunos_statichost_get
+{
+  my ($hosts, $ipnodes) = @_;
+  my %list;
+ 
+  if (!&gst_network_sunos_hosts_lookup ("localhost")) {
+    my $lofound = 0;
+    local *SVCS = &gst_file_run_pipe_read("ifconfig -a");
+    while (<SVCS>) {
+      if (/lo0:\s*/) { $lofound = 1; next; }
+      if ($lofound && /inet\s*([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/) {
+        %list = ($1, "localhost");
+        last;
+      }
+    }
+    close (SVCS);
+  }
+
+  return \%list;
+}
+
 sub gst_network_conf_get
 {
   my %dist_attrib;
@@ -1743,6 +2701,12 @@ sub gst_network_rh72_get_file
   return "$dev.$i";
 }
 
+sub gst_network_sunos_get_file
+{
+  my ($iface) = @_;
+  return &gst_network_sunos_interface ($$iface{"dev"});
+}
+
 sub gst_network_deb22_get_file
 {
   my ($iface) = @_;
@@ -1816,6 +2780,8 @@ sub gst_network_get_file
           "ubuntu-5.04" => \&gst_network_deb22_get_file,    
           "ubuntu-5.10" => \&gst_network_deb22_get_file,    
           "ubuntu-6.04" => \&gst_network_deb22_get_file,    
+          "nexenta-1.0" => \&gst_network_sunos_get_file,    
+          "solaris-2.11" => \&gst_network_sunos_get_file,    
           "suse-7.0"     => \&gst_network_suse70_get_file,
           "suse-9.0"     => \&gst_network_deb22_get_file,
           "suse-9.1"     => \&gst_network_deb22_get_file,
@@ -1851,6 +2817,15 @@ sub gst_network_get_file
 
 sub gst_network_get_gateway_data
 {
+  if ($$tool{"system"} eq "SunOS") {
+  	return &gst_network_sunos_get_gateway_data ();
+  } else {
+  	return &gst_network_linux_get_gateway_data ();
+  }
+}
+
+sub gst_network_linux_get_gateway_data
+{
   my ($fd, $gateway, $dev);
 
   $fd = &gst_file_run_pipe_read ("route -n");
@@ -1868,6 +2843,25 @@ sub gst_network_get_gateway_data
   return ($gateway, $dev);
 }
 
+sub gst_network_sunos_get_gateway_data
+{
+  my ($fd, $gateway, $dev);
+
+  $fd = &gst_file_run_pipe_read ("netstat -rn");
+  while (<$fd>)
+  {
+    if (/^default[ \t]+([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)[ \t]+.*[ \t]([a-zA-Z0-9]*[0-9])/)
+    {
+      $gateway = $1;
+      $dev = $2;
+      last;
+    }
+  }
+
+  &gst_file_close ($fd);
+  return ($gateway, $dev);
+}
+
 sub gst_network_get_default_gatewaydev
 {
   my ($gateway, $dev) = &gst_network_get_gateway_data ();
@@ -1890,10 +2884,15 @@ sub gst_network_route_set_default_gw
   # Just in case. This means that no static gateway is needed.
   return if $gateway eq "";
 
-  $fd = &gst_file_run_pipe_read ("route -n");
+  # XXX - Check to see if the route is already set... 
+  if ($$tool{"system"} eq "SunOS") {
+    $fd = &gst_file_run_pipe_read ("netstat -rn");
+  } else {
+    $fd = &gst_file_run_pipe_read ("route -n");
+  }
   while (<$fd>)
   {
-    if (/^0\.0\.0\.0[ \t]+([0-9.]+) /)
+    if (/^0\.0\.0\.0[ \t]+([0-9.]+) / || /^default\s+([0-9.]+)\s+/)
     {
       $curr_gateway = $1;
       if ($gatewaydev ne "")
@@ -1910,8 +2909,14 @@ sub gst_network_route_set_default_gw
   if (($curr_gateway    ne $gateway) ||
       ($curr_gatewaydev ne $gatewaydev))
   {
-    &gst_file_run ("route del default gw $curr_gateway");
-    &gst_file_run ("route add default gw $gateway $gatewaydev");
+    if ($$tool{"system"} eq "SunOS") {
+      # Set the default gateway
+      &gst_file_run ("route delete default $curr_gateway");
+      &gst_file_run ("route add default $gateway");
+    } else {
+      &gst_file_run ("route del default gw $curr_gateway");
+      &gst_file_run ("route add default gw $gateway $gatewaydev");
+    }
   }
 }
 
@@ -3822,28 +4827,57 @@ sub gst_network_suse9_get_dev_name
   return $dev;
 }
 
+# Search for visible networks
 sub gst_network_detect_essids
 {
   my ($iface) = @_;
   my ($fd, @arr, $encrypted);
 
-  # some wireless cards need to be up before scanning
-  &gst_file_run ("ifconfig $iface up");
-  $fd = &gst_file_run_pipe_read ("iwlist $iface scanning");
-  return undef if (!$fd);
-
-  while (<$fd>)
-  {
-    if (/^[ \t]*Encryption key:([^ \t\n]+)/)
+  &gst_report_enter ();
+  &gst_report ("gst_network_detect_essids", $iface);
+  if ($$tool{"system"} eq "SunOS") {
+    &gst_file_run ("ifconfig $iface plumb"); # XXX - a hack, do we really need it?
+    #&gst_file_run ("wificonfig -i $iface disconnect"); # XXX - Don't do this!
+    $fd = &gst_file_run_pipe_read ("wificonfig -i $iface scan");
+    return undef if (!$fd);
+    while (<$fd>)
     {
-      $encrypted = ($1 eq "off") ? 0 : 1;
+      if (/(.*)\s+([0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+)\s+(.+)\s+(wep|none)\s+([0-9]+)/) {
+
+        my $essid = $1;
+	    my $bssid = $2;
+        my $type = $3;
+        my $encryption = $4;
+        my $signallevel = $5;
+
+	    $essid =~ s/^\s+//; $essid =~ s/\s+$//;
+	    $type =~ s/^\s+//; $type =~ s/\s+$//;
+
+        $encrypted = ($encryption eq "none") ? 0 : 1;
+        push @arr, {"essid" => $essid,
+                    "encrypted" => $encrypted };
+      }
     }
-    elsif (/^[ \t]*ESSID\:"(.+)"/)
+  } else {
+    # some wireless cards need to be up before scanning
+    &gst_file_run ("ifconfig $iface up");
+    $fd = &gst_file_run_pipe_read ("iwlist $iface scanning");
+    return undef if (!$fd);
+  
+    while (<$fd>)
     {
-      push @arr, {"essid" => $1,
-                  "encrypted" => $encrypted };
+      if (/^[ \t]*Encryption key:([^ \t\n]+)/)
+      {
+        $encrypted = ($1 eq "off") ? 0 : 1;
+      }
+      elsif (/^[ \t]*ESSID\:"(.+)"/)
+      {
+        push @arr, {"essid" => $1,
+                    "encrypted" => $encrypted };
+      }
     }
   }
+  &gst_report_leave ();
 
   return \@arr;
 }
@@ -3936,6 +4970,8 @@ sub gst_network_ensure_loopback_interfac
           "ubuntu-5.04" => "lo",    
           "ubuntu-5.10" => "lo",    
           "ubuntu-6.04" => "lo",    
+          "nexenta-1.0" => "",    
+          "solaris-2.11" => "",    
           "suse-7.0"     => "",
           "suse-9.0"     => "",
           "suse-9.1"     => "",
@@ -3970,7 +5006,7 @@ sub gst_network_ensure_loopback_interfac
     my %iface = (
                  "auto" => 1,
                  "user" => 0,
-                 "dev" => "lo",
+                 "dev" => "$dev",
                  "address" => "127.0.0.1",
                  "netmask" => "255.0.0.0",
                  "broadcast" => "127.255.255.255",
@@ -4021,16 +5057,27 @@ sub gst_network_ensure_loopback_staticho
 {
   my ($statichost, $hostname, $old_hostname, $lo_ip) = @_;
   my $i;
+  my ($plat) = $$tool{"system"};
 
   if (exists $$statichost{$lo_ip})
   {
     my $localhost = $$statichost{$lo_ip};
     &gst_network_statichost_remove_alias ($localhost, $old_hostname) if ($old_hostname);
-    &gst_network_statichost_add_alias ($localhost, $hostname);
+    if ($plat ne "SunOS")
+    {
+      &gst_network_statichost_add_alias ($localhost, $hostname);
+    }
   }
   else
   {
-    $$statichost{$lo_ip} = [ ("localhost", "localhost.localdomain", $hostname) ];
+    if ($plat eq "SunOS")
+    {
+      $$statichost{$lo_ip} = [ ("localhost", "localhost.localdomain") ];
+    }
+    else
+    {
+      $$statichost{$lo_ip} = [ ("localhost", "localhost.localdomain", $hostname) ];
+    }
   }
 }
 
@@ -4101,6 +5148,8 @@ sub gst_network_get_parse_table
           "ubuntu-5.04" => "debian-2.2",
           "ubuntu-5.10" => "debian-2.2",
           "ubuntu-6.04" => "debian-2.2",
+          "nexenta-1.0" => "nexenta",
+          "solaris-2.11" => "solaris",
           "suse-7.0"     => "suse-7.0",
           "suse-9.0"     => "suse-9.0",
           "suse-9.1"     => "suse-9.0",
@@ -4479,6 +5528,79 @@ sub gst_network_get_parse_table
        [ "gatewaydev",    \&gst_network_get_gateway_dev_from_address, "%interface%", "%gateway%" ],
        ]
      },
+
+     "nexenta" =>
+     {
+       fn =>
+       {
+          RESOLV_CONF => "/etc/resolv.conf",
+          HOST_CONF   => "/etc/host.conf",
+          HOSTS       => "/etc/hosts",
+          IPNODES     => "/etc/inet/ipnodes", # IPv6
+          HOSTNAME    => "/etc/nodename",
+          SMB_CONF    => "/etc/samba/smb.conf",
+       },
+       table =>
+          [
+           [ "hostname",      \&gst_parse_line_first,        HOSTNAME ],
+           [ "gateway",       \&gst_network_get_default_gateway ],
+           [ "gatewaydev",    \&gst_network_get_default_gatewaydev ],
+#           [ "gwdevunsup",    \&gst_parse_trivial,           1 ],
+#           [ "userifacectl",  \&gst_parse_trivial,           0 ],
+           [ "domain",	      \&gst_parse_split_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
+           [ "nameserver",    \&gst_parse_split_all_hash_comment, RESOLV_CONF,  "nameserver", "[ \t]+" ],
+           [ "searchdomain",  \&gst_parse_split_first_array, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
+           [ "order",         \&gst_parse_split_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
+           [ "hostmatch",     \&gst_parse_split_first_bool,  HOST_CONF,    "multi", "[ \t]+" ],
+           [ "statichost",    \&gst_network_sunos_statichost_get, HOSTS, IPNODES ],
+           [ "workgroup",     \&gst_parse_ini,               SMB_CONF,     "global", "workgroup" ],
+           [ "smbdesc",       \&gst_parse_ini,               SMB_CONF,     "global", "server string" ],
+           [ "winsserver",    \&gst_parse_ini,               SMB_CONF,     "global", "wins server" ],
+           [ "winsuse",       \&gst_parse_ini_bool,          SMB_CONF,     "global", "wins support" ],
+           [ "smbuse",        \&gst_service_sysv_get_status_any, "smbd", "nmbd" ],
+           [ "smbinstalled",  \&gst_service_sysv_installed,  "samba" ],
+           [ "smartdhcpcd",   \&gst_file_tool_installed,     "pump" ],
+           [ "dialinstalled", \&gst_file_tool_installed,     "wvdial" ],
+           [ "interface",     \&gst_network_interfaces_get ]
+           ]
+     },
+
+     "solaris" =>
+     {
+       fn =>
+       {
+          RESOLV_CONF => "/etc/resolv.conf",
+          HOST_CONF   => "/etc/host.conf",
+          HOSTS       => "/etc/hosts",
+          IPNODES     => "/etc/inet/ipnodes", # IPv6
+          HOSTNAME    => "/etc/nodename",
+          SMB_CONF    => "/etc/sfw/smb.conf",
+       },
+       table =>
+          [
+           [ "hostname",      \&gst_parse_line_first,        HOSTNAME ],
+           [ "gateway",       \&gst_network_get_default_gateway ],
+           [ "gatewaydev",    \&gst_network_get_default_gatewaydev ],
+#           [ "gwdevunsup",    \&gst_parse_trivial,           1 ],
+#           [ "userifacectl",  \&gst_parse_trivial,           0 ],
+           [ "domain",	      \&gst_parse_split_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
+           [ "nameserver",    \&gst_parse_split_all_hash_comment, RESOLV_CONF,  "nameserver", "[ \t]+" ],
+           [ "searchdomain",  \&gst_parse_split_first_array, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
+           [ "order",         \&gst_parse_split_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
+           [ "hostmatch",     \&gst_parse_split_first_bool,  HOST_CONF,    "multi", "[ \t]+" ],
+#DPK           [ "statichost",    \&gst_network_sunos_statichost_get, HOSTS, IPNODES ],
+		   [ "statichost",    \&gst_parse_split_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
+           [ "workgroup",     \&gst_parse_ini,               SMB_CONF,     "global", "workgroup" ],
+           [ "smbdesc",       \&gst_parse_ini,               SMB_CONF,     "global", "server string" ],
+           [ "winsserver",    \&gst_parse_ini,               SMB_CONF,     "global", "wins server" ],
+           [ "winsuse",       \&gst_parse_ini_bool,          SMB_CONF,     "global", "wins support" ],
+           [ "smbuse",        \&gst_service_sysv_get_status_any, "smbd", "nmbd" ],
+           [ "smbinstalled",  \&gst_service_sysv_installed,  "samba" ],
+           [ "smartdhcpcd",   \&gst_file_tool_installed,     "pump" ],
+           [ "dialinstalled", \&gst_file_tool_installed,     "wvdial" ],
+           [ "interface",     \&gst_network_interfaces_get ]
+           ]
+     },
    );
   
   my $dist = $dist_map{$gst_dist};
@@ -4522,6 +5644,8 @@ sub gst_network_get_interface_parse_tabl
           "ubuntu-5.04" => "debian-3.0",
           "ubuntu-5.10" => "debian-3.0",
           "ubuntu-6.04" => "debian-3.0",
+          "nexenta-1.0" => "nexenta",
+          "solaris-2.11" => "solaris",
           "suse-7.0"     => "suse-7.0",
           "suse-9.0"     => "suse-9.0",
           "suse-9.1"     => "suse-9.0",
@@ -5318,7 +6442,115 @@ sub gst_network_get_interface_parse_tabl
        [ "persist",            \&gst_network_get_freebsd5_ppp_persist, [ STARTIF, IFACE ]],
       ]
     },
-	  );
+
+  "nexenta" =>
+  {
+    ifaces_get => \&gst_network_sunos_ifaces_get_existing,
+    fn =>
+    {
+        INTERFACES  => "/etc",
+        IFACE       => "#iface#",
+        CHAT        => "/etc/chatscripts/%section%",
+        PPP_OPTIONS => "/etc/ppp/peers/%section%",
+        PAP         => "/etc/ppp/pap-secrets",
+        CHAP        => "/etc/ppp/chap-secrets",
+    },
+    table =>
+          [
+#           [ "user",               \&gst_parse_trivial,                  0 ], # not supported.
+           [ "dev",                \&gst_parse_trivial,                  IFACE ],
+           [ "bootproto",          \&gst_network_sunos_bootproto_get,    IFACE ],
+           [ "auto",               \&gst_network_sunos_auto_get,         IFACE ],
+           [ "name",               \&gst_network_sunos_name_get,         [IFACE]],
+           [ "address",            \&gst_network_sunos_address_get,      [IFACE]],
+           [ "netmask",            \&gst_network_sunos_netmask_get,      [IFACE]],
+           [ "broadcast",          \&gst_network_sunos_broadcast_get,    [IFACE]],
+           [ "network",            \&gst_network_sunos_network_get,      [IFACE]],
+           [ "gateway",            \&gst_network_sunos_gateway_get,      [IFACE]],
+           [ "essid",              \&gst_network_sunos_wireless_get,     [IFACE, "essid" ]],
+           [ "key_type",           \&gst_network_sunos_wireless_get,     [IFACE, "key_type" ]],
+           [ "key",                \&gst_network_sunos_wireless_get,     [IFACE, "key" ]],
+           [ "remote_address",     \&gst_network_debian_parse_remote_address, [INTERFACES, IFACE]],
+           [ "section",            \&gst_parse_interfaces_option_str,    [INTERFACES, IFACE], "provider" ],
+           [ "update_dns",         \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "usepeerdns" ]],
+           [ "noauth",             \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "noauth" ]],
+           [ "mtu",                \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_split_first_str, PPP_OPTIONS, "mtu", "[ \t]+" ]],
+           [ "mru",                \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_split_first_str, PPP_OPTIONS, "mru", "[ \t]+" ]],
+           [ "serial_port",        \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^(/dev/[^ \t]+)" ]],
+           [ "serial_speed",       \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^([0-9]+)" ]],
+           [ "login",              \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^user \"?([^\"]*)\"?" ]],
+           [ "password",           \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_network_get_pap_passwd, PAP, "%login%" ]],
+           [ "password",           \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_network_get_pap_passwd, CHAP, "%login%" ]],
+           [ "ppp_options",        \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_ppp_options_unsup, PPP_OPTIONS ]],
+           [ "set_default_gw",     \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "defaultroute" ]],
+           [ "debug",              \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "debug" ]],
+           [ "persist",            \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "persist" ]],
+           [ "serial_escapechars", \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_split_first_str, PPP_OPTIONS, "escape", "[ \t]+" ]],
+           [ "serial_hwctl",       \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_kw, PPP_OPTIONS, "crtscts" ]],
+           [ "external_line",      \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_chat, CHAT, "atd[^0-9]([0-9*#]*)[wW]" ]],
+           [ "external_line",      \&gst_network_check_type,            [IFACE, "isdn", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^number[ \t]+(.+)[wW]" ]],
+           [ "phone_number",       \&gst_network_check_type,            [IFACE, "isdn", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^number.*[wW \t](.*)" ]],
+           [ "phone_number",       \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_chat, CHAT, "atd.*[ptwW]([0-9, -]+)" ]],
+           [ "dial_command",       \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_chat, CHAT, "(atd[tp])[0-9, -w]+" ]],
+           [ "volume",             \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_modem_volume, CHAT ]],
+           [ "enabled",            \&gst_network_interface_active,       IFACE, \&gst_network_active_interfaces_get ],
+         ]
+     },
+
+  "solaris" =>
+  {
+    ifaces_get => \&gst_network_sunos_ifaces_get_existing,
+    fn =>
+    {
+        INTERFACES  => "/etc",
+        IFACE       => "#iface#",
+        CHAT        => "/etc/chatscripts/%section%",
+        PPP_OPTIONS => "/etc/ppp/peers/%section%",
+        PAP         => "/etc/ppp/pap-secrets",
+        CHAP        => "/etc/ppp/chap-secrets",
+    },
+    table =>
+          [
+#           [ "user",               \&gst_parse_trivial,                  0 ], # not supported.
+           [ "dev",                \&gst_parse_trivial,                  IFACE ],
+           [ "bootproto",          \&gst_network_sunos_bootproto_get,    IFACE ],
+           [ "auto",               \&gst_network_sunos_auto_get,         IFACE ],
+           [ "name",               \&gst_network_sunos_name_get,         [IFACE]],
+           [ "address",            \&gst_network_sunos_address_get,      [IFACE]],
+           [ "netmask",            \&gst_network_sunos_netmask_get,      [IFACE]],
+           [ "broadcast",          \&gst_network_sunos_broadcast_get,    [IFACE]],
+           [ "network",            \&gst_network_sunos_network_get,      [IFACE]],
+           [ "gateway",            \&gst_network_sunos_gateway_get,      [IFACE]],
+           [ "essid",              \&gst_network_sunos_wireless_get,     [IFACE, "essid" ]],
+           [ "key_type",           \&gst_network_sunos_wireless_get,     [IFACE, "key_type" ]],
+           [ "key",                \&gst_network_sunos_wireless_get,     [IFACE, "key" ]],
+           [ "remote_address",     \&gst_network_debian_parse_remote_address, [INTERFACES, IFACE]],
+           [ "section",            \&gst_parse_interfaces_option_str,    [INTERFACES, IFACE], "provider" ],
+           [ "update_dns",         \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "usepeerdns" ]],
+           [ "noauth",             \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "noauth" ]],
+           [ "mtu",                \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_split_first_str, PPP_OPTIONS, "mtu", "[ \t]+" ]],
+           [ "mru",                \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_split_first_str, PPP_OPTIONS, "mru", "[ \t]+" ]],
+           [ "serial_port",        \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^(/dev/[^ \t]+)" ]],
+           [ "serial_speed",       \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^([0-9]+)" ]],
+           [ "login",              \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^user \"?([^\"]*)\"?" ]],
+           [ "password",           \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_network_get_pap_passwd, PAP, "%login%" ]],
+           [ "password",           \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_network_get_pap_passwd, CHAP, "%login%" ]],
+           [ "ppp_options",        \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_ppp_options_unsup, PPP_OPTIONS ]],
+           [ "set_default_gw",     \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "defaultroute" ]],
+           [ "debug",              \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "debug" ]],
+           [ "persist",            \&gst_network_check_type,            [IFACE, "(modem|isdn)", \&gst_parse_kw, PPP_OPTIONS, "persist" ]],
+           [ "serial_escapechars", \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_split_first_str, PPP_OPTIONS, "escape", "[ \t]+" ]],
+           [ "serial_hwctl",       \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_kw, PPP_OPTIONS, "crtscts" ]],
+           [ "external_line",      \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_chat, CHAT, "atd[^0-9]([0-9*#]*)[wW]" ]],
+           [ "external_line",      \&gst_network_check_type,            [IFACE, "isdn", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^number[ \t]+(.+)[wW]" ]],
+           [ "phone_number",       \&gst_network_check_type,            [IFACE, "isdn", \&gst_network_get_ppp_options_re, PPP_OPTIONS, "^number.*[wW \t](.*)" ]],
+           [ "phone_number",       \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_chat, CHAT, "atd.*[ptwW]([0-9, -]+)" ]],
+           [ "dial_command",       \&gst_network_check_type,            [IFACE, "modem", \&gst_parse_chat, CHAT, "(atd[tp])[0-9, -w]+" ]],
+           [ "volume",             \&gst_network_check_type,            [IFACE, "modem", \&gst_network_get_modem_volume, CHAT ]],
+           [ "enabled",            \&gst_network_interface_active,       IFACE, \&gst_network_active_interfaces_get ],
+         ]
+     },
+  );
   
   my $dist = $dist_map{$gst_dist};
   return %{$dist_tables{$dist}} if $dist;
@@ -5360,6 +6592,8 @@ sub gst_network_get_replace_table
           "ubuntu-5.04" => "debian-2.2",
           "ubuntu-5.10" => "debian-2.2",
           "ubuntu-6.04" => "debian-2.2",
+          "nexenta-1.0" => "nexenta",
+          "solaris-2.11" => "solaris",
           "suse-7.0"     => "suse-7.0",
           "suse-9.0"     => "suse-9.0",
           "suse-9.1"     => "suse-9.0",
@@ -5723,7 +6957,69 @@ sub gst_network_get_replace_table
        [ "gateway",       \&gst_replace_sh,               RC_CONF, "defaultrouter" ],
        [ "interface",     \&gst_network_interfaces_set,   OLD_HASH ]
        ]
-    }
+    },
+
+	  "nexenta" =>
+	  {
+	    fn =>
+	    {
+        RESOLV_CONF => "/etc/resolv.conf",
+        HOST_CONF   => "/etc/host.conf",
+        HOSTS       => "/etc/hosts",
+        HOSTNAME    => "/etc/nodename",
+        SMB_CONF    => "/etc/samba/smb.conf",
+        WVDIAL      => "/etc/wvdial.conf"
+      },
+	    table =>
+          [
+           [ "hostname",      \&gst_replace_line_first,       HOSTNAME ],
+           [ "hostname",      \&gst_network_run_hostname ],
+           [ "domain",        \&gst_replace_join_first_str,   RESOLV_CONF, "domain", "[ \t]+" ],
+           [ "nameserver",    \&gst_replace_join_all,         RESOLV_CONF, "nameserver", "[ \t]+" ],
+           [ "searchdomain",  \&gst_replace_join_first_array, RESOLV_CONF, "search", "[ \t]+", "[ \t]+" ],
+           [ "order",         \&gst_replace_join_first_array, HOST_CONF,   "order", "[ \t]+", ",[ \t]*" ],
+           [ "hostmatch",     \&gst_replace_join_first_bool,  HOST_CONF,   "multi", "[ \t]+", "on", "off" ],
+           [ "statichost",    \&gst_replace_join_hash,        HOSTS,       "[ \t]+", "[ \t]+" ],
+           [ "workgroup",     \&gst_replace_ini,              SMB_CONF,    "global", "workgroup" ],
+           [ "smbdesc",       \&gst_replace_ini,              SMB_CONF,    "global", "server string" ],
+           [ "winsserver",    \&gst_replace_ini,              SMB_CONF,    "global", "wins server" ],
+           [ "winsuse",       \&gst_replace_ini_bool,         SMB_CONF,    "global", "wins support" ],
+           [ "smbuse",        \&gst_service_sysv_set_status,  91, "samba" ],
+           [ "interface",     \&gst_network_interfaces_set,   OLD_HASH ],
+           [ "gateway",       \&gst_network_route_set_default_gw, "%gatewaydev%" ]
+           ]
+             },
+
+	  "solaris" =>
+	  {
+	    fn =>
+	    {
+        RESOLV_CONF => "/etc/resolv.conf",
+        #HOST_CONF   => "/etc/host.conf",
+        HOSTS       => "/etc/hosts",
+        HOSTNAME    => "/etc/nodename",
+        SMB_CONF    => "/etc/samba/smb.conf",
+        WVDIAL      => "/etc/wvdial.conf"
+      },
+	    table =>
+          [
+           [ "hostname",      \&gst_replace_line_first,       HOSTNAME ],
+           [ "hostname",      \&gst_network_run_hostname ],
+           [ "domain",        \&gst_replace_join_first_str,   RESOLV_CONF, "domain", "[ \t]+" ],
+           [ "nameserver",    \&gst_replace_join_all,         RESOLV_CONF, "nameserver", "[ \t]+" ],
+           [ "searchdomain",  \&gst_replace_join_first_array, RESOLV_CONF, "search", "[ \t]+", "[ \t]+" ],
+           #[ "order",         \&gst_replace_join_first_array, HOST_CONF,   "order", "[ \t]+", ",[ \t]*" ],
+           #[ "hostmatch",     \&gst_replace_join_first_bool,  HOST_CONF,   "multi", "[ \t]+", "on", "off" ],
+           [ "statichost",    \&gst_replace_join_hash,        HOSTS,       "[ \t]+", "[ \t]+" ],
+           [ "workgroup",     \&gst_replace_ini,              SMB_CONF,    "global", "workgroup" ],
+           [ "smbdesc",       \&gst_replace_ini,              SMB_CONF,    "global", "server string" ],
+           [ "winsserver",    \&gst_replace_ini,              SMB_CONF,    "global", "wins server" ],
+           [ "winsuse",       \&gst_replace_ini_bool,         SMB_CONF,    "global", "wins support" ],
+           [ "smbuse",        \&gst_service_sysv_set_status,  91, "samba" ],
+           [ "interface",     \&gst_network_interfaces_set,   OLD_HASH ],
+           [ "gateway",       \&gst_network_route_set_default_gw, "%gatewaydev%" ]
+           ]
+             },
 	  );
   
   my $dist = $dist_map{$gst_dist};
@@ -5766,6 +7062,8 @@ sub gst_network_get_interface_replace_ta
           "ubuntu-5.04" => "debian-3.0",
           "ubuntu-5.10" => "debian-3.0",
           "ubuntu-6.04" => "debian-3.0",
+          "nexenta-1.0" => "nexenta",
+          "solaris-2.11" => "solaris",
           "suse-7.0"     => "suse-7.0",
           "suse-9.0"     => "suse-9.0",
           "suse-9.1"     => "suse-9.0",
@@ -6522,7 +7820,109 @@ sub gst_network_get_interface_replace_ta
        [ "dial_command",   \&gst_network_replace_pppconf_dial_command, [ PPPCONF, STARTIF, IFACE ]],
        [ "volume",         \&gst_network_replace_pppconf_volume,       [ PPPCONF, STARTIF, IFACE ]],
       ]
-    }
+    },
+
+    "nexenta" =>
+    {
+      iface_set    => \&gst_network_sunos_interface_activate,
+      iface_delete => \&gst_network_sunos_interface_delete,
+      ifaces_get   => \&gst_network_sunos_ifaces_get_existing,
+    fn =>
+    {
+        IFACE       => "#iface#",
+        CHAT        => "/etc/chatscripts/%section%",
+        PPP_OPTIONS => "/etc/ppp/peers/%section%",
+        PAP         => "/etc/ppp/pap-secrets",
+        CHAP        => "/etc/ppp/chap-secrets",
+    },
+    table =>
+          [
+           [ "auto",               \&gst_network_sunos_auto_set,          [IFACE]],
+           [ "bootproto",          \&gst_network_sunos_bootproto_set,     [IFACE]],
+           [ "address",            \&gst_network_sunos_address_set,       [IFACE]],
+           [ "netmask",            \&gst_network_sunos_netmask_set,       [IFACE], "%address%" ],
+           [ "gateway",            \&gst_network_sunos_gateway_set,       [IFACE]],
+           [ "essid",              \&gst_network_sunos_wireless_set,      [IFACE], "essid" ],
+           [ "key",                \&gst_network_sunos_wireless_set,      [IFACE], "key" ],
+           [ "key_type",           \&gst_network_sunos_wireless_set,      [IFACE], "key_type" ],
+           [ "remote_address",     \&gst_network_sunos_remote_address_set,[IFACE]],
+           # Modem stuff
+           [ "section",            \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_ppp_options_connect,  PPP_OPTIONS ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "modem", \&gst_network_create_pppscript, CHAT ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "isdn", \&gst_network_create_isdn_options, PPP_OPTIONS ]],
+           [ "update_dns",         \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "usepeerdns" ]],
+           [ "noauth",             \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "noauth" ]],
+           [ "set_default_gw",     \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "defaultroute" ]],
+           [ "debug",              \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "debug" ]],
+           [ "persist",            \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "persist" ]],
+           [ "serial_hwctl",       \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_kw, PPP_OPTIONS, "crtscts" ]],
+           [ "mtu",                \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_join_first_str, PPP_OPTIONS, "mtu", "[ \t]+" ]],
+           [ "mru",                \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_join_first_str, PPP_OPTIONS, "mru", "[ \t]+" ]],
+           [ "serial_port",        \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^(/dev/[^ \t]+)" ]],
+           [ "serial_speed",       \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^([0-9]+)" ]],
+           [ "login",              \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^user (.*)", "user \"%login%\"" ]],
+           [ "password",           \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_network_set_pap_passwd, PAP, "%login%" ]],
+           [ "password",           \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_network_set_pap_passwd, CHAP, "%login%" ]],
+           [ "serial_escapechars", \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_join_first_str, PPP_OPTIONS, "escape", "[ \t]+" ]],
+           [ "dial_command",       \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_chat, CHAT, "(atd[tp])[0-9w, -]+" ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_chat, CHAT, "atd[tp]([0-9w]+)" ]],
+           [ "external_line",      \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_chat, CHAT, "atd[tp]([0-9w, -]+)", "%external_line%W%phone_number%" ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "isdn", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^number (.*)", "number %phone_number%" ]],
+           [ "external_line",      \&gst_network_check_type,             [IFACE, "isdn", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^number (.*)", "number %external_line%W%phone_number%" ]],
+           [ "volume",             \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_modem_volume, CHAT ]],
+           ]
+    },
+
+    "solaris" =>
+    {
+      iface_set    => \&gst_network_sunos_interface_activate,
+      iface_delete => \&gst_network_sunos_interface_delete,
+      ifaces_get   => \&gst_network_sunos_ifaces_get_existing,
+    fn =>
+    {
+        IFACE       => "#iface#",
+        CHAT        => "/etc/chatscripts/%section%",
+        PPP_OPTIONS => "/etc/ppp/peers/%section%",
+        PAP         => "/etc/ppp/pap-secrets",
+        CHAP        => "/etc/ppp/chap-secrets",
+    },
+    table =>
+          [
+           [ "auto",               \&gst_network_sunos_auto_set,          [IFACE]],
+           [ "bootproto",          \&gst_network_sunos_bootproto_set,     [IFACE]],
+           [ "address",            \&gst_network_sunos_address_set,       [IFACE]],
+           [ "netmask",            \&gst_network_sunos_netmask_set,       [IFACE], "%address%" ],
+           [ "gateway",            \&gst_network_sunos_gateway_set,       [IFACE]],
+           [ "essid",              \&gst_network_sunos_wireless_set,      [IFACE], "essid" ],
+           [ "key",                \&gst_network_sunos_wireless_set,      [IFACE], "key" ],
+           [ "key_type",           \&gst_network_sunos_wireless_set,      [IFACE], "key_type" ],
+           [ "remote_address",     \&gst_network_sunos_remote_address_set,[IFACE]],
+           # Modem stuff
+           [ "section",            \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_ppp_options_connect,  PPP_OPTIONS ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "modem", \&gst_network_create_pppscript, CHAT ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "isdn", \&gst_network_create_isdn_options, PPP_OPTIONS ]],
+           [ "update_dns",         \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "usepeerdns" ]],
+           [ "noauth",             \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "noauth" ]],
+           [ "set_default_gw",     \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "defaultroute" ]],
+           [ "debug",              \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "debug" ]],
+           [ "persist",            \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_kw, PPP_OPTIONS, "persist" ]],
+           [ "serial_hwctl",       \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_kw, PPP_OPTIONS, "crtscts" ]],
+           [ "mtu",                \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_join_first_str, PPP_OPTIONS, "mtu", "[ \t]+" ]],
+           [ "mru",                \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_replace_join_first_str, PPP_OPTIONS, "mru", "[ \t]+" ]],
+           [ "serial_port",        \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^(/dev/[^ \t]+)" ]],
+           [ "serial_speed",       \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^([0-9]+)" ]],
+           [ "login",              \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^user (.*)", "user \"%login%\"" ]],
+           [ "password",           \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_network_set_pap_passwd, PAP, "%login%" ]],
+           [ "password",           \&gst_network_check_type,             [IFACE, "(modem|isdn)", \&gst_network_set_pap_passwd, CHAP, "%login%" ]],
+           [ "serial_escapechars", \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_join_first_str, PPP_OPTIONS, "escape", "[ \t]+" ]],
+           [ "dial_command",       \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_chat, CHAT, "(atd[tp])[0-9w, -]+" ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_chat, CHAT, "atd[tp]([0-9w]+)" ]],
+           [ "external_line",      \&gst_network_check_type,             [IFACE, "modem", \&gst_replace_chat, CHAT, "atd[tp]([0-9w, -]+)", "%external_line%W%phone_number%" ]],
+           [ "phone_number",       \&gst_network_check_type,             [IFACE, "isdn", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^number (.*)", "number %phone_number%" ]],
+           [ "external_line",      \&gst_network_check_type,             [IFACE, "isdn", \&gst_network_set_ppp_options_re, PPP_OPTIONS, "^number (.*)", "number %external_line%W%phone_number%" ]],
+           [ "volume",             \&gst_network_check_type,             [IFACE, "modem", \&gst_network_set_modem_volume, CHAT ]],
+           ]
+    },
   );
   
   my $dist = $dist_map{$gst_dist};

