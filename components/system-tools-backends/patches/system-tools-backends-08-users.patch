diff -up system-tools-backends-1.4.2/users-conf.in.orig system-tools-backends-1.4.2/users-conf.in
--- system-tools-backends-1.4.2/users-conf.in.orig	2009-05-01 14:59:26.685073313 +0100
+++ system-tools-backends-1.4.2/users-conf.in	2009-05-01 14:59:16.334547388 +0100
@@ -47,6 +47,8 @@
 # pw: modifying users/groups and user/group data on FreeBSD.
 
 
+use Authen::PAM;
+
 BEGIN {
   $SCRIPTSDIR = "@scriptsdir@";
   if ($SCRIPTSDIR =~ /^@scriptsdir[@]/)
@@ -54,7 +56,8 @@ BEGIN {
       $SCRIPTSDIR = ".";
       $DOTIN = ".in";
   }
-  
+  push(@INC, $SCRIPTSDIR);
+
   require "$SCRIPTSDIR/general.pl$DOTIN";
   require "$SCRIPTSDIR/platform.pl$DOTIN";
   require "$SCRIPTSDIR/util.pl$DOTIN";
@@ -63,6 +66,7 @@ BEGIN {
   require "$SCRIPTSDIR/replace.pl$DOTIN";
 }
 
+use secdb;
 
 # --- Tool information --- #
 
@@ -74,6 +78,7 @@ $version = "@VERSION@";
               "mandrake-7.1", "mandrake-7.2", "mandrake-9.0", "mandrake-9.1", "mandrake-9.2",
               "mandrake-10.0", "mandrake-10.1",
               "debian-2.2", "debian-3.0", "debian-sarge",
+               "nexenta-1.0", "solaris-2.11",
               "suse-7.0", "suse-9.0", "suse-9.1", "turbolinux-7.0",
               "slackware-8.0.0", "slackware-8.1", "slackware-9.0.0", "slackware-9.1.0", "slackware-10.0.0", "slackware-10.1.0", "slackware-10.2.0",
               "freebsd-4", "freebsd-5", "freebsd-6",
@@ -93,6 +98,7 @@ end_of_description;
 @passwd_names =     ( "/etc/passwd" );
 @shadow_names =     ( "/etc/shadow", "/etc/master.passwd" );
 @group_names =      ( "/etc/group" );
+@rbac_names =       ( "/etc/user_attr" ); # Files that will be changed by RBAC commands
 @login_defs_names = ( "/etc/login.defs", "/etc/adduser.conf" );
 @shell_names =      ( "/etc/shells" );
 @skel_dir =         ( "/usr/share/skel", "/etc/skel" );
@@ -115,9 +121,33 @@ $cmd_pw       = &gst_file_locate_tool ("
 # --- Mapping constants --- #
 
 %users_prop_map = ();
+
+sub get_users_prop_array
+{
 @users_prop_array = ();
 
-if ($$tool{"platform"} eq "Linux")
+if ($$tool{"system"} eq "Linux")
+{
+  @users_prop_array = (
+    "key", 0,
+    "login", 1,
+    "password", 2,
+    "uid", 3,
+    "gid", 4,
+    "comment", 5,
+    "home", 6,
+    "shell", 7,
+    "last_mod", 8, # Read shadow (5) for these.
+    "passwd_min_life", 9,
+    "passwd_max_life", 10,
+    "passwd_exp_warn", 11,
+    "passwd_exp_disable", 12,
+    "passwd_disable", 13,
+    "reserved", 14,
+    "is_shadow", 15,
+    "", "");
+}
+if ($$tool{"system"} eq "SunOS")
 {
   @users_prop_array = (
     "key", 0,
@@ -136,6 +166,8 @@ if ($$tool{"platform"} eq "Linux")
     "passwd_disable", 13,
     "reserved", 14,
     "is_shadow", 15,
+    "rbac", 16,
+    "role", 17,
     "", "");
 }
 else
@@ -157,6 +189,7 @@ for ($i = 0; $users_prop_array[$i] ne ""
   $users_prop_map {$users_prop_array[$i]} = $users_prop_array[$i + 1];
   $users_prop_map {$users_prop_array[$i + 1]} = $users_prop_array[$i];
 }
+}
 
 %groups_prop_map = ();
 @groups_prop_array = (
@@ -193,6 +226,71 @@ for ($i = 0; $groups_prop_array[$i] ne "
 %login_defs_prop_map = ();
 %profiles_prop_map = ();
 
+sub read_rbac() {
+  return unless ( $gst_dist =~ /^solaris/ );
+
+  my ($hash) = @_;
+  my ($buffer, $line, $profile, $description, $dummy);
+  my ($user, $attr);
+  my (%rbac, %rbac_profiles, %role, %rbac_roles);
+
+  %rbac=();
+  %rbac_profiles=();
+  %rbac_roles=();
+
+  # Get Profiles
+  secdb::setprofattr();
+  while ( $pattr = secdb::getprofattr() ) {
+    $profile = $pattr->{name};
+    $description = $pattr->{desc};
+    # Skip the "All" special profile.
+    next if ( $profile =~ /^All$/ );
+
+    $rbac_profiles{$profile} = &gst_xml_quote($description);
+  }
+  secdb::endprofattr();
+
+  $rbac{"rbac_profiles"} = \%rbac_profiles;
+
+  $$hash{"rbacdb"} = \%rbac;
+
+  # Get Roles
+  secdb::setuserattr();
+  while ( $uattr = secdb::getuserattr() ) {
+    $user = $uattr->{name};
+    $type = secdb::kva_match($uattr->{attr}, $secdb::USERATTR_TYPE_KW );
+    if ( $type =~ $secdb::USERATTR_TYPE_ROLE ) {
+      $rbac_roles{$user} = &gst_xml_quote($user) 
+    }
+  }
+  secdb::enduserattr();
+
+  $role{"rbac_roles"} = \%rbac_roles;
+
+  $$hash{"roledb"} = \%role;
+}
+
+sub read_rbac_default_profiles
+{
+  return unless ( $gst_dist =~ /^solaris/ );
+
+  my ($buffer, $line, $dummy, @def_prof, $def_prof_ref);
+  $buffer = &gst_file_buffer_load("/etc/security/policy.conf");
+  foreach $line ( @$buffer ) {
+    chomp $line;
+    if ( $line =~ /^PROFS_GRANTED=/ )
+      {
+        ($dummy, $def_line) = split(/=/, $line, 2);
+        @def_prof = split (/,/, $def_line);
+        foreach ( @def_prof ) {
+          $def_prof_ref->{$_} = 1;
+        }
+        return $def_prof_ref;
+      }
+    next;
+  }
+}
+
 sub get_login_defs_prop_array
 {
   my @prop_array;
@@ -315,6 +413,30 @@ sub get_profiles_prop_array
   }
 }
 
+my $nexenta_logindefs_defaults = {
+  'login_defs'  => 0, # Open Solaris doesn't have a login.defs file.
+  'shell'       => '/bin/bash',
+  'group'       => 'users',
+  'skel_dir'    => '/etc/skel/',
+  'home_prefix' => '/export/home/$user',
+  'gmin'        => 1000,
+  'gmax'        => 2147483647, # Based on MAXUID from sys/param.h
+  'umin'        => 100,
+  'umax'        => 2147483647, # Based on MAXUID from sys/param.h
+};
+
+my $solaris_logindefs_defaults = {
+  'login_defs'  => 0, # Open Solaris doesn't have a login.defs file.
+  'shell'       => '/bin/bash',
+  'group'       => 'users',
+  'skel_dir'    => '/etc/skel/',
+  'home_prefix' => '/export/home/$user',
+  'gmin'        => 1000,
+  'gmax'        => 2147483647, # Based on MAXUID from sys/param.h
+  'umin'        => 100,
+  'umax'        => 2147483647, # Based on MAXUID from sys/param.h
+};
+
 my $rh_logindefs_defaults = {
   'shell'       => '/bin/bash',
   'group'       => '$user',
@@ -362,6 +484,8 @@ my $logindefs_dist_map = {
   'debian-2.2'      => $rh_logindefs_defaults,
   'debian-3.0'      => $rh_logindefs_defaults,
   'debian-sarge'    => $rh_logindefs_defaults,
+  'nexenta-1.0'    => $nexenta_logindefs_defaults,
+  'solaris-2.11'    => $solaris_logindefs_defaults,
   'vine-3.0'        => $rh_logindefs_defaults,
   'vine-3.1'        => $rh_logindefs_defaults,
   'gentoo'	        => $gentoo_logindefs_defaults,
@@ -419,7 +543,8 @@ sub arr_cmp_recurse
 	my ($a1, $a2) = @_;
 	my $i;
 	
-	return -1 if ($#$a1 != $#$a2);
+  return 0 if ( ( $#$a1 < 0 || $#$a2 < 0 ) && $#$a1 == $#$a2 );
+	return -1 if ($#$a1 != $#$a2 || $#$a1 < 0 || $#$a2 < 0 );
 	
 	for ($i = 0; $i <= $#$a1; $i++) {
 	  if (ref ($$a1[$i]) eq "ARRAY") { # see if this is a reference.
@@ -453,6 +578,7 @@ sub read
   &read_passwd_shadow (\%hash);
   &read_profiledb     (\%hash);
   &read_shells        (\%hash);
+  &read_rbac          (\%hash) if ( $gst_dist =~ /^solaris/);
 
   return \%hash;
 }
@@ -553,11 +679,11 @@ sub read_logindefs
   }
   else
   {
-    # Put safe defaults for distros/OS that don't have any defaults file
-    $logindefs->{"umin"} = '1000';
-    $logindefs->{"umax"} = '60000';
-    $logindefs->{"gmin"} = '1000';
-    $logindefs->{"gmax"} = '60000';
+    # Put safe defaults for distros/OS that don't have any defaults set
+    $logindefs->{"umin"} = '1000' unless ($logindefs->{"umin"});
+    $logindefs->{"umax"} = '60000' unless ($logindefs->{"umax"});
+    $logindefs->{"gmin"} = '1000' unless ($logindefs->{"gmin"});
+    $logindefs->{"gmax"} = '60000' unless ($logindefs->{"gmax"});
   }
 }
 
@@ -602,6 +728,7 @@ sub read_passwd_shadow
   my ($ifh, @users, %users_hash, $passwd_last_modified);
   my (@line, $copy, %tmphash);
   my $login_pos = $users_prop_map{"login"};
+  #my (%users_rbac_profiles);
   my $i = 0;
 
   # Find the passwd file.
@@ -660,6 +787,35 @@ sub read_passwd_shadow
 
     &gst_file_close ($ifh);
   }
+  if ($gst_dist =~ /^solaris/ ) {
+    my $rbac_pos = $users_prop_map{"rbac"};
+    my $role_pos = $users_prop_map{"role"};
+    my ($fd);
+    foreach $user (@users) {
+      my @profiles;
+      my @roles, $tmproles;
+      my $logname = $$user[1];
+
+      # Get User's Profiles
+       @profiles = ();
+       if ( $uattr = secdb::getusernam( $logname ) ) {
+        $prof_str = secdb::kva_match($uattr->{attr}, $secdb::USERATTR_PROFILES_KW);
+        @profiles = split(/,/, $prof_str );
+        chomp( @profiles );
+      }
+      @{$tmphash{$logname}}[$rbac_pos] = \@profiles;
+      # Get User's Roles
+       @roles = ();
+       if ( $uattr = secdb::getusernam( $logname ) ) {
+        $roles_str = secdb::kva_match($uattr->{attr}, $secdb::USERATTR_ROLES_KW);
+        @roles = split(/,/, $roles_str );
+        chomp( @roles );
+      }
+      @{$tmphash{$logname}}[$role_pos] = \@roles;
+      
+    }
+    #$$hash{"users_rbac_profiles"} = \%users_rbac_profiles;
+  }
 
   $$hash{"users"}      = \@users;
   $$hash{"users_hash"} = \%users_hash;
@@ -740,7 +896,40 @@ sub read_shells
   push (@shells, "/bin/false") if (stat ("/bin/false"));
   
   $ifh = &gst_file_open_read_from_names(@shell_names);
-  return unless $ifh;
+  unless ($ifh)
+  {
+     if ($gst_dist =~ /solaris/)
+     {
+       push (@shells, "/bin/bash") if (stat ("/bin/bash"));
+       push (@shells, "/bin/csh") if (stat ("/bin/csh"));
+       push (@shells, "/bin/jsh") if (stat ("/bin/jsh"));
+       push (@shells,  "/bin/ksh") if (stat ("/bin/ksh"));
+       push (@shells,  "/bin/pfcsh") if (stat ("/bin/pfcsh"));
+       push (@shells, "/bin/pfksh") if (stat ("/bin/pfksh"));
+       push (@shells, "/bin/pfsh") if (stat ("/bin/pfsh"));
+       push (@shells, "/bin/sh") if (stat ("/bin/sh"));
+       push (@shells, "/bin/tcsh") if (stat ("/bin/tcsh"));
+       push (@shells, "/bin/zsh") if (stat ("/bin/zsh"));
+       push (@shells, "/bin/jsh") if (stat ("/bin/jsh"));
+       push (@shells, "/sbin/jsh") if (stat ("/sbin/jsh"));
+       push (@shells, "/sbin/pfsh") if (stat ("/sbin/pfsh"));
+       push (@shells, "/sbin/sh") if (stat ("/sbin/sh"));
+       push (@shells, "/usr/bin/bash") if (stat ("/usr/bin/bash"));
+       push (@shells, "/usr/bin/csh") if (stat ("/usr/bin/csh"));
+       push (@shells, "/usr/bin/jsh") if (stat ("/usr/bin/jsh"));
+       push (@shells, "/usr/bin/ksh") if (stat ("/usr/bin/ksh"));
+       push (@shells, "/usr/bin/pfcsh") if (stat ("/usr/bin/pfcsh"));
+       push (@shells, "/usr/bin/pfksh") if (stat ("/usr/bin/pfksh"));
+       push (@shells, "/usr/bin/pfsh") if (stat ("/usr/bin/pfsh"));
+       push (@shells, "/usr/bin/sh") if (stat ("/usr/bin/sh"));
+       push (@shells, "/usr/bin/tcsh") if (stat ("/usr/bin/tcsh"));
+       push (@shells, "/usr/bin/zsh") if (stat ("/usr/bin/zsh"));
+       push (@shells, "/usr/xpg4/bin/sh") if (stat ("/usr/xpg4/bin/sh"));
+       $$hash{"shelldb"} = \@shells;
+     }
+     return;
+  }
+  
 
   while (<$ifh>)
   {
@@ -879,6 +1068,11 @@ sub change_user_chfn
   {
     $command = "$cmd_pw usermod -n " . $username . " -c \'" . $comment . "\'";
   }
+  elsif ($gst_dist =~ /^solaris/)
+  {
+    ($fname, $office, $office_phone, $home_phone) = @line;
+    $command = "$cmd_usermod" . " -c \'" . $fname . "\' " . $username; 
+  }
   else
   {
     ($fname, $office, $office_phone, $home_phone) = @line;
@@ -886,7 +1080,7 @@ sub change_user_chfn
     $fname = "-f \'" . $fname . "\'";
     $home_phone = "-h \'" . $home_phone . "\'";
 
-    if ($gst_dist =~ /^debian/  || $gst_dist =~ /^archlinux/)
+    if ($gst_dist =~ /^debian/  || $gst_dist =~ /^archlinux/ || $gst_dist =~ /^nexenta/)
     {
       $office = "-r \'" . $office . "\'";
       $office_phone = "-w \'" . $office_phone . "\'";
@@ -903,6 +1097,30 @@ sub change_user_chfn
   &gst_file_run ($command);
 }
 
+$service = "passwd";
+$username = "";
+$newpassword = "";
+
+sub my_conv_func {
+  my @res;
+  while ( @_ ) {
+      my $code = shift;
+      my $msg = shift;
+      my $ans = "";
+
+      $ans = $username if ($code == PAM_PROMPT_ECHO_ON() );
+      if ($code == PAM_PROMPT_ECHO_OFF() ) {
+        $ans = $newpassword;
+        $ans = $newpassword;
+
+      }
+
+      push @res, (PAM_SUCCESS(),$ans);
+  }
+  push @res, PAM_SUCCESS();
+  return @res;
+}
+
 sub add_user
 {
 	my ($data) = @_;
@@ -932,6 +1150,69 @@ sub add_user
     print $pwdpipe $$data[$users_prop_map{"password"}];
     &gst_file_close ($pwdpipe);
   }
+  elsif ($gst_dist =~ /^nexenta/)
+  {
+    my $pwdpipe;
+    $home_parents = $$data[$users_prop_map{"home"}];
+    $home_parents =~ s/\/+[^\/]+\/*$//;
+    &gst_file_run ("$tool_mkdir -p $home_parents");
+
+    $command = "$cmd_useradd" . " -d \'" . $$data[$users_prop_map{"home"}] .
+     "\' -g \'"    . $$data[$users_prop_map{"gid"}] .
+     "\' -s \'"    . $$data[$users_prop_map{"shell"}] .
+     "\' -u \'"    . $$data[$users_prop_map{"uid"}] .
+     "\' \'"       . $$data[$users_prop_map{"login"}] . "\'";
+    &gst_file_run ($command);
+    &gst_file_run("echo " . $$data[$users_prop_map{"login"}] . ":" . $$data[$users_prop_map{"password"}] . " | chpasswd -e");
+  }
+  elsif ($gst_dist =~ /^solaris/)
+  {
+    $home_parents = $$data[$users_prop_map{"home"}];
+    $home_parents =~ s/\/+[^\/]+\/*$//;
+    &gst_file_run ("$tool_mkdir -p $home_parents");
+
+    $command = "$cmd_useradd";
+    if ($$data[$users_prop_map{"rbac"}] ne undef ) {
+      my (@profiles, $old_user_profiles, $new_user_profiles );
+      $new_user_profiles = $$data[$users_prop_map{"rbac"}];
+      @profiles = ();
+      push( @profiles, @$new_user_profiles );
+      if ( $#profiles >= 0 ) {
+        my $profiles_str = "";
+        foreach ( @profiles ) {
+          $profiles_str .= ',' unless ( $profiles_str eq "" );
+          $profiles_str .= $_;
+        }
+        $command .= " -P \'" . $profiles_str . "\'";
+      }
+    }
+
+    if ($$data[$users_prop_map{"role"}] ne undef ) {
+      my (@roles, $old_user_roles, $new_user_roles );
+      $new_user_roles = $$data[$users_prop_map{"role"}];
+      @roles = ();
+      push( @roles, @$new_user_roles );
+      if ( $#roles >= 0 ) {
+        my $roles_str = "";
+        foreach ( @roles ) {
+          $roles_str .= ',' unless ( $roles_str eq "" );
+          $roles_str .= $_;
+        }
+        $command .= " -R \'" . $roles_str . "\'";
+      }
+    }
+
+    $command .= " -d \'" . $$data[$users_prop_map{"home"}] .
+     "\' -g \'"    . $$data[$users_prop_map{"gid"}] .
+     "\' -m -s \'"    . $$data[$users_prop_map{"shell"}] .
+     "\' -u \'"    . $$data[$users_prop_map{"uid"}] .
+     "\' \'"       . $$data[$users_prop_map{"login"}] . "\'";
+    &gst_file_run ($command);
+    $username = $$data[$users_prop_map{"login"}];
+    $newpassword = $$data[$users_prop_map{"password"}];
+    ref($pamh = new Authen::PAM($service, $username, \&my_conv_func));
+    $pamh->pam_chauthtok(PAM_NO_AUTHTOK_CHECK());
+  }
   else
   {
     $home_parents = $$data[$users_prop_map{"home"}];
@@ -967,9 +1248,138 @@ sub change_user
      " -H 0"; # pw(8) reads password from STDIN
 
     $pwdpipe = &gst_file_run_pipe($command, $GST_FILE_WRITE);
-    print $pwdpipe $$data[$users_prop_map{"password"}];
+    print $pwdpipe $$new_data[$users_prop_map{"password"}];
     &gst_file_close ($pwdpipe);
   }
+  elsif ($gst_dist =~ /^nexenta/)
+  {
+    $command = "$cmd_usermod" . " -d \'" . $$new_data[$users_prop_map{"home"}] .
+     "\' -g \'" . $$new_data[$users_prop_map{"gid"}] .
+     "\' -l \'" . $$new_data[$users_prop_map{"login"}] .
+     "\' -s \'" . $$new_data[$users_prop_map{"shell"}] .
+     "\' -u \'" . $$new_data[$users_prop_map{"uid"}] .
+     "\' \'" . $$old_data[$users_prop_map{"login"}] . "\'";
+    &gst_file_run ($command);
+    &gst_file_run("echo " . $$new_data[$users_prop_map{"login"}] . ":" . $$new_data[$users_prop_map{"password"}] . " | chpasswd -e");
+  }
+  elsif ($gst_dist =~ /^solaris/)
+  {
+    $command = "$cmd_usermod" ;
+
+    $command .= " -u \'" . $$new_data[$users_prop_map{"uid"}] . "\'"
+        if ( $$new_data[$users_prop_map{"uid"}] ne $$old_data[$users_prop_map{"uid"}]  );
+    $command .= " -g \'" . $$new_data[$users_prop_map{"gid"}] . "\'"
+        if ( $$new_data[$users_prop_map{"gid"}] ne $$old_data[$users_prop_map{"gid"}]  );
+    $command .= " -d \'" . $$new_data[$users_prop_map{"home"}] . "\'"
+        if ( $$new_data[$users_prop_map{"home"}] ne $$old_data[$users_prop_map{"home"}]  );
+    $command .= " -s \'" . $$new_data[$users_prop_map{"shell"}] . "\'"
+        if ( $$new_data[$users_prop_map{"shell"}] ne $$old_data[$users_prop_map{"shell"}]  );
+
+    if ($$new_data[$users_prop_map{"rbac"}] ne undef ) {
+      my (@old_profiles, @new_profiles, $old_user_profiles, $new_user_profiles );
+      my $change = 0;
+      $old_user_profiles = $$old_data[$users_prop_map{"rbac"}];
+      $new_user_profiles = $$new_data[$users_prop_map{"rbac"}];
+      @old_profiles = ();
+      @new_profiles = ();
+      if ( $old_user_profiles eq undef ) {
+        # All new profiles, so just use directly
+        &gst_report("RBAC profiles created for ". $$old_data[$users_prop_map{"login"}] );
+        push( @new_profiles, @$new_user_profiles );
+	push( @old_profiles, @$old_user_profiles );
+      }
+      else {
+        my @sorted_old_user_profiles = sort(@$old_user_profiles);
+        my @sorted_new_user_profiles = sort(@$new_user_profiles);
+        if ( &arr_cmp_recurse( \@sorted_new_user_profiles, \@sorted_old_user_profiles) ) {
+          &gst_report("RBAC profiles changed for ". $$old_data[$users_prop_map{"login"}] );
+          push( @new_profiles, @$new_user_profiles ); # Copy unsorted list
+	  push( @old_profiles, @$old_user_profiles );
+	  $change = 1;
+ 	}
+      }
+      if ( $#new_profiles >= 0 ) {
+        my $profiles_str = "";
+        foreach ( @old_profiles ) {
+          $tmp = $_;
+          foreach ( @new_profiles ) {
+            if ( $tmp eq $_ ) {
+              $profiles_str .= ',' unless ( $profiles_str eq "" );
+              $profiles_str .= $tmp;
+              last;
+            }
+          }
+        }
+
+        foreach ( @new_profiles ) {
+          $tmp = $_;
+          $found = 0;
+          foreach ( @old_profiles ) {
+            if ( $tmp eq $_ ) {
+              $found = 1;
+              last;
+            }
+          }
+          if ( !$found ) {
+            $profiles_str .= ',' unless ( $profiles_str eq "" );
+            $profiles_str .= $tmp;
+          }
+        }
+       
+        $command .= " -P \'" . $profiles_str . "\'";
+       } else {
+	$command .= " -P \'\'" if ( $change );
+       }
+    }
+
+    if ($$new_data[$users_prop_map{"role"}] ne undef ) {
+      my (@roles, $old_user_roles, $new_user_roles );
+      my $change = 0;
+      $old_user_roles = $$old_data[$users_prop_map{"role"}];
+      $new_user_roles = $$new_data[$users_prop_map{"role"}];
+      @roles = ();
+      if ( $old_user_roles eq undef ) {
+        # All new roles, so just use directly
+        &gst_report("RBAC roles created for ". $$old_data[$users_prop_map{"login"}] );
+        push( @roles, @$new_user_roles );
+      }
+      else {
+        my @sorted_old_user_roles = sort(@$old_user_roles);
+        my @sorted_new_user_roles = sort(@$new_user_roles);
+        if ( &arr_cmp_recurse( \@sorted_new_user_roles, \@sorted_old_user_roles) ) {
+          &gst_report("RBAC roles changed for ". $$old_data[$users_prop_map{"login"}] );
+          push( @roles, @$new_user_roles ); # Copy unsorted list
+	  $change = 1;
+        }
+      }
+      if ( $#roles >= 0 ) {
+        my $roles_str = "";
+        foreach ( @roles ) {
+          $roles_str .= ',' unless ( $roles_str eq "" );
+          $roles_str .= $_;
+        }
+        $command .= " -R \'" . $roles_str . "\'";
+      } else {
+        $command .= " -R \'\'" if ( $change);
+      }
+    }
+
+    # If there's nothing to change, then don't... 
+    if ( $command ne $cmd_usermod ) {
+        $command .= " \'" . $$old_data[$users_prop_map{"login"}] . "\'";
+        &gst_file_run ($command);
+    }
+    $username = $$old_data[$users_prop_map{"login"}];
+    $oldpassword = $$old_data[$users_prop_map{"password"}];
+    $newpassword = $$new_data[$users_prop_map{"password"}];
+    # Should only change password if old and new differ - this is especially
+    # important since the old password is usually the "crypted" one!! Only if
+    # it's different has a user entered a clear string here.
+    if ( $newpassword ne undef && $newpassword ne $oldpassword ) {
+        ref($pamh = new Authen::PAM($service, $username, \&my_conv_func));
+        $pamh->pam_chauthtok(PAM_NO_AUTHTOK_CHECK());
+    }
+  }
   else
   {
     $command = "$cmd_usermod" . " -d \'" . $$new_data[$users_prop_map{"home"}] .
@@ -1026,8 +1436,24 @@ sub add_group
 
     foreach $user (@$u)
     {
-      $command = "$cmd_gpasswd -a \'" . $user .
-        "\' " . $$data[$groups_prop_map{"name"}];
+      if ($gst_dist =~ /^solaris/)
+      {
+        my ($groups, @a);
+        $command = "groups \'" . $user . "\'";
+        $groups = &gst_file_run_backtick ($command);
+        chomp ($groups);
+        @a = split (/ /, $groups);
+        $groups = join (',', @a);
+
+        $command = "$cmd_usermod -G " . $groups . "," .
+                $$data[$groups_prop_map{"name"}] .  " " .
+                $user . " ";
+      }
+      else
+      {
+        $command = "$cmd_gpasswd -a \'" . $user .
+          "\' " . $$data[$groups_prop_map{"name"}];
+      }
       &gst_file_run ($command);
     }
   }
@@ -1052,10 +1478,18 @@ sub change_group
   }
   else
   {
-    $command = "$cmd_groupmod -g \'" . $$new_data[$groups_prop_map{"gid"}] .
-      "\' -n \'" . $$new_data[$groups_prop_map{"name"}] . "\' " .
-      "\'" . $$old_data[$groups_prop_map{"name"}] . "\'";
-  
+    if ( $$new_data[$groups_propmap{"name"}] eq $$old_data[$group_prop_map{"name"}] )
+    {
+      $command = "$cmd_groupmod -g \'" . $$new_data[$groups_prop_map{"gid"}] .
+        "\' \'" . $$old_data[$groups_prop_map{"name"}] . "\'";
+    }
+    else
+    {
+      $command = "$cmd_groupmod -g \'" . $$new_data[$groups_prop_map{"gid"}] .
+        "\' -n \'" . $$new_data[$groups_prop_map{"name"}] . "\' " .
+        "\'" . $$old_data[$groups_prop_map{"name"}] . "\'";
+    }
+
     &gst_file_run ($command);
 	
     # Let's see if the users that compose the group have changed.
@@ -1069,25 +1503,62 @@ sub change_group
       $max_o = $#$o;
       for ($i = 0, $j = 0; $i <= &max ($max_n, $max_o); ) {
         $r = $$n[$i] cmp $$o[$j];
-        $r *= -1 if (($$o[$j] eq "") || ($$n[$i] eq ""));
 
-        if ($r < 0) { # add this user to the group.
-          $command = "$cmd_gpasswd -a \'" . $$n[$i] . "\' \'" . 
-            $$new_data[$groups_prop_map{"name"}] . "\'";
+        if ($r > 0) { # add this user to the group.
+          if ($gst_dist =~ /^solaris/)
+          {
+            my ($groups, @a);
+            $command = "groups \'" . $$n[$i] . "\'";
+            $groups = &gst_file_run_backtick ($command);
+            chomp ($groups);
+            @a = split (/ /, $groups);
+            $groups = join (',', @a);
+
+            $command = "$cmd_usermod -G " . $groups . "," .
+                $$new_data[$groups_prop_map{"name"}] .  " " .
+                $$n[$i] . " ";
+          }
+          else
+          {
+            $command = "$cmd_gpasswd -a " . $$n[$i] . " " .  $$new_data[$groups_prop_map{"name"}] . " ";
+          }
           $i ++;
-				
+
           &gst_file_run ($command);
-			  } elsif ($r > 0) { # delete the user from the group.
-          $command = "$cmd_gpasswd -d \'" . $$o[$j] . "\' \'" . 
-            $$new_data[$groups_prop_map{"name"}] . "\'";
+        } elsif ($r < 0) { # delete the user from the group.
+          if ($gst_dist =~ /^solaris/)
+          {
+            my ($groups, @a, $k);
+            $command = "groups \'" . $$o[$j] . "\'";
+            $groups = &gst_file_run_backtick ($command);
+            chomp ($groups);
+            @a = split (/ /, $groups);
+            for ($k = 0; $k < $#a + 1; $k++)
+            {
+              if ($a[$k] eq $$new_data[$groups_prop_map{"name"}])
+              {
+                splice (@a, $k, 1);
+                last;
+              }
+            }
+            $groups = join (',', @a);
+
+            $command = "$cmd_usermod -G " . $groups . " " .
+                $$o[$j] . " ";
+          }
+          else
+          {
+            $command = "$cmd_gpasswd -d \'" . $$o[$j] . "\' \'" .
+              $$new_data[$groups_prop_map{"name"}] . "\'";
+          }
           $j ++;
-				
+
           &gst_file_run ($command);
-			  } else { # The information is the same. Go to next tuple.
+        } else { # The information is the same. Go to next tuple.
           $i ++; $j ++;
-			  }	
-		  }	
-	  }
+        }
+      }
+    }
   }
 }
 
@@ -1204,8 +1675,11 @@ sub xml_parse_users
 		elsif ($$tree[0] eq "group_last_modified") { &xml_parse_group_last_modified ($$tree[1], $hash); }
 		elsif ($$tree[0] eq "userdb") { &xml_parse_userdb ($$tree[1], $hash); }
 		elsif ($$tree[0] eq "groupdb") { &xml_parse_groupdb ($$tree[1], $hash); }
+		elsif ($$tree[0] eq "use_md5")  { }
 		elsif ($$tree[0] eq "shelldb")  { }
 		elsif ($$tree[0] eq "profiledb")  { &xml_parse_profiledb ($$tree[1], $hash); }
+		elsif ($$tree[0] eq "rbacdb")  { } # if rbacdb is there ignore, can't be changed.
+                elsif ($$tree[0] eq "roledb")  { } # if roledb is there ignore, can't be changed.
 		else
 		{
 		  &gst_report ("xml_unexp_tag", $$tree[0]);
@@ -1268,18 +1742,60 @@ sub xml_parse_user
 
 	while (@$tree)
 	{
-		if ($users_prop_map{$$tree[0]} ne undef)
+		if ($users_prop_map{$$tree[0]} ne undef && $$tree[0] ne "rbac" && $$tree[0] ne "role" )
 		{
 		  $line[$users_prop_map{$$tree[0]}] = &gst_xml_unquote($$tree[1][2]);
 		}
-		else
-		{
-		  &gst_report ("xml_unexp_tag", $$tree[0]);
-		}
-		
-		shift @$tree;
-		shift @$tree;
-	}
+    elsif ($$tree[0] eq "rbac")
+    {
+      my $rbac = $$tree[1]; # rbac children
+      shift @$rbac; # Skip attributes
+      my $rbac_profiles = $$rbac[1]; # rbac children
+      shift @$rbac_profiles; # Skip attributes
+
+      my @user_profiles;
+      # my $users_rbac_profiles = $$hash{"users_rbac_profiles"};
+
+      # if ( $users_rbac_profiles eq undef ) { # Allocate a new one if none exists
+      #  my %dummy = ();
+      #  $users_rbac_profiles = \%dummy;
+      #  $$hash{"users_rbac_profiles"} = $users_rbac_profiles;
+      #}
+
+      while (@$rbac_profiles) {
+        my $profile = $$rbac_profiles[1][2];
+        push(@user_profiles, $profile );
+        shift( @$rbac_profiles );
+        shift( @$rbac_profiles );
+      }
+      #$$users_rbac_profiles{ $line[$users_prop_map{"login"}] } = \@user_profiles;
+      #XXX Here
+		  $line[$users_prop_map{$$tree[0]}] = \@user_profiles;
+    }
+    elsif ($$tree[0] eq "role")
+    {
+      my $role = $$tree[1]; # role children
+      shift @$role; # Skip attributes
+      my $role_lists = $$role[1]; # role children
+      shift @$role_lists; # Skip attributes
+
+      my @user_roles;
+
+      while (@$role_lists) {
+	my $role = $$role_lists[1][2];
+	push(@user_roles, $role );
+	shift( @$role_lists );
+	shift( @$role_lists );
+      }
+      $line[$users_prop_map{$$tree[0]}] = \@user_roles;
+    }
+    else
+    {
+      &gst_report ("xml_unexp_tag", $$tree[0]);
+    }
+      shift @$tree;
+      shift @$tree;
+    }
 
   $$users_hash{sprintf ("%06d", $line[0])} = [@line];
   push (@$users, [@line]);
@@ -1323,6 +1839,7 @@ sub xml_parse_group
 		  if ($$tree[0] eq "users") { $line[$groups_prop_map{$$tree[0]}] = $$tree[1]; }
 			else { $line[$groups_prop_map{$$tree[0]}] = $$tree[1][2]; }
 		}
+		elsif ($$tree[0] eq "allows_to") { }
 		else
 		{
 		  &gst_report ("xml_unexp_tag", $$tree[0]);
@@ -1487,11 +2004,20 @@ sub xml_print
   my ($hash) = @_;
   my ($key, $value, $i, $j, $k);
   my ($passwd_last_modified, $users, $desc);
+  # my ($users_rbac_profiles);
+  my ($rbac, $rbac_profiles, $role, $rbac_roles);
 
   $passwd_last_modified = $$hash{"passwd_last_modified"};
   $users = $$hash{"users"};
   $group_last_modified = $$hash{"group_last_modified"};
   $groups = $$hash{"groups"};
+  if ( $gst_dist =~ /^solaris/ ) {
+    $rbac = $$hash{"rbacdb"};
+    $rbac_profiles = $$rbac{"rbac_profiles"};
+    $role = $$hash{"roledb"};
+    $rbac_roles = $$role{"rbac_roles"};
+    # $users_rbac_profiles = $$hash{"users_rbac_profiles"};
+  }
 
   &gst_xml_print_begin ();
 
@@ -1519,8 +2045,35 @@ sub xml_print
 	  &gst_xml_container_enter ('user');
 		for ($j = 0; $j < ($#users_prop_array - 1) / 2; $j++)
     {
-      &gst_xml_print_pcdata ($users_prop_map{$j}, $$i[$j]);
+      if ( $users_prop_map{$j} eq "rbac" && $gst_dist =~ /^solaris/ ) {
+        my ($user_profiles);
+        &gst_xml_container_enter ('rbac');
+        &gst_xml_container_enter ('rbac_profiles');
+        # $user_profiles = $$users_rbac_profiles{$$i[1]};
+        $user_profiles = $$i[$j];
+        foreach $prof ( @$user_profiles ) {
+          &gst_xml_print_pcdata ("rbac_profile", $prof);
+        }
+        &gst_xml_container_leave ();
+        &gst_xml_container_leave ();
+      }
+      elsif ( $users_prop_map{$j} eq "role" && $gst_dist =~ /^solaris/ ) {
+        my ($user_roles);
+        &gst_xml_container_enter ('role');
+        &gst_xml_container_enter ('rbac_roles');
+        # $user_profiles = $$users_rbac_profiles{$$i[1]};
+        $user_roles = $$i[$j];
+        foreach $role ( @$user_roles ) {
+          &gst_xml_print_pcdata ("rbac_role", $role);
+        }
+        &gst_xml_container_leave ();
+        &gst_xml_container_leave ();
+      }
+      else {
+        &gst_xml_print_pcdata ($users_prop_map{$j}, $$i[$j]);
+      }
 		}
+
 		&gst_xml_container_leave ();
 	}
 	&gst_xml_container_leave ();
@@ -1559,9 +2112,47 @@ sub xml_print
 		&gst_xml_container_leave ();
 	}
 	&gst_xml_container_leave ();
-  &gst_xml_print_vspace ();
 
-  &gst_xml_print_end ();
+    if ( $gst_dist =~ /^solaris/ ) {
+      &gst_xml_print_vspace ();
+
+      &gst_xml_print_comment ('Now the RBAC Profiles');
+      &gst_xml_print_vspace ();
+        
+      &gst_xml_container_enter ('rbacdb');
+      &gst_xml_container_enter ('rbac_profiles');
+
+      foreach $prof ( sort keys %$rbac_profiles )
+      {
+        &gst_xml_print_vspace ();
+        &gst_xml_container_enter ('rbac_profile');
+        &gst_xml_print_pcdata ('name', $prof );
+        &gst_xml_print_pcdata ('description', $$rbac_profiles{$prof} );
+        &gst_xml_container_leave ();
+      }
+      &gst_xml_container_leave ();
+      &gst_xml_container_leave ();
+      &gst_xml_print_vspace ();
+
+      &gst_xml_print_comment ('Now the ROLE');
+      &gst_xml_print_vspace ();
+
+      &gst_xml_container_enter ('roledb');
+      &gst_xml_container_enter ('rbac_roles');
+
+      foreach $role ( sort keys %$rbac_roles )
+      {
+    	&gst_xml_print_vspace ();
+    	&gst_xml_container_enter ('rbac_role');
+    	&gst_xml_print_pcdata ('role', $role );
+    	&gst_xml_container_leave ();
+      }
+      &gst_xml_container_leave ();
+      &gst_xml_container_leave ();
+      &gst_xml_print_vspace ();
+    }
+
+    &gst_xml_print_end ();
 }
 
 
@@ -1590,6 +2181,7 @@ sub set
     &gst_file_backup ($_) foreach (@passwd_names);
     &gst_file_backup ($_) foreach (@shadow_names);
     &gst_file_backup ($_) foreach (@group_names);
+    &gst_file_backup ($_) foreach (@rbac_names);
 
     &write_profiledb ($hash);
     &write_group_passwd ($hash);
@@ -1627,6 +2219,7 @@ $directives = {
 $tool = &gst_init ($name, $version, $description, $directives, @ARGV);
 &gst_platform_ensure_supported ($tool, @platforms);
 
+&get_users_prop_array ();
 &get_login_defs_prop_array ();
 &get_profiles_prop_array   ();
 

diff -up system-tools-backends-1.4.2/Makefile.am.orig system-tools-backends-1.4.2/Makefile.am
--- system-tools-backends-1.4.2/Makefile.am.orig	2005-02-23 14:31:25.000000000 +0000
+++ system-tools-backends-1.4.2/Makefile.am	2009-05-01 10:52:18.828515674 +0100
@@ -18,6 +18,8 @@ backends = \
 	font-conf
 
 perl_libs = \
+    user_attr.pm \
+	user_attr.so \
 	boot.pl      \
 	boot-grub.pl \
 	boot-lilo.pl \

diff -up system-tools-backends-1.4.2/Makefile.in.orig system-tools-backends-1.4.2/Makefile.in
--- system-tools-backends-1.4.2/Makefile.in.orig	2009-05-01 10:52:40.000000000 +0100
+++ system-tools-backends-1.4.2/Makefile.in	2009-05-01 11:21:42.782223461 +0100
@@ -194,6 +194,13 @@ backends = \
 	font-conf
 
 
+secdb_libs = \
+	secdb.so
+
+secdb_files = \
+    secdb.pm \
+	$(secdb_libs)
+
 perl_libs = \
 	boot.pl      \
 	boot-grub.pl \
@@ -224,7 +231,7 @@ perl_libs = \
 	xml.pl
 
 
-scripts_SCRIPTS = $(backends) $(perl_libs) guess_system.sh type1inst
+scripts_SCRIPTS = $(backends) $(perl_libs) guess_system.sh type1inst $(secdb_files)
 
 EXTRA_DIST = \
 	intltool-extract.in \
@@ -238,7 +245,7 @@ EXTRA_DIST = \
 	NEWS
 
 
-CLEANFILES = $(backends) $(perl_libs)
+CLEANFILES = $(backends) $(perl_libs) $(secdb_libs)
 
 DISTCLEANFILES = \
 	intltool-extract 	\
@@ -295,6 +302,13 @@ all: config.h
 
 .SUFFIXES:
 
+secdb_wrap.o: secdb_wrap.c
+	$(CC) -c secdb_wrap.c `perl -MExtUtils::Embed -e ccopts`
+
+secdb.so: secdb_wrap.o
+	$(LD) -G secdb_wrap.o -o secdb.so -lsecdb
+
+	
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno
 $(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)

diff -up system-tools-backends-1.4.2/secdb.i.orig system-tools-backends-1.4.2/secdb.i
--- system-tools-backends-1.4.2/secdb.i.orig	2009-05-01 14:10:51.392529355 +0100
+++ system-tools-backends-1.4.2/secdb.i	2009-05-01 11:29:10.761689758 +0100
@@ -0,0 +1,11 @@
+%module secdb
+%{ 
+#include "prof_attr.h"
+#include "secdb.h"
+#include "user_attr.h"
+%}
+
+%include "prof_attr.h"
+%include "user_attr.h"
+%include "secdb.h"
+

--- system-tools-backends-1.4.2/secdb.pm	1970-01-01 10:00:00.000000000 +1000
+++ system-tools-backends-1.4.2.new/secdb.pm	2010-08-05 16:34:58.891880880 +1000
@@ -0,0 +1,447 @@
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 1.3.35
+#
+# Don't modify this file, modify the SWIG interface instead.
+
+package secdb;
+require Exporter;
+require DynaLoader;
+@ISA = qw(Exporter DynaLoader);
+package secdbc;
+bootstrap secdb;
+package secdb;
+@EXPORT = qw( );
+
+# ---------- BASE METHODS -------------
+
+package secdb;
+
+sub TIEHASH {
+    my ($classname,$obj) = @_;
+    return bless $obj, $classname;
+}
+
+sub CLEAR { }
+
+sub FIRSTKEY { }
+
+sub NEXTKEY { }
+
+sub FETCH {
+    my ($self,$field) = @_;
+    my $member_func = "swig_${field}_get";
+    $self->$member_func();
+}
+
+sub STORE {
+    my ($self,$field,$newval) = @_;
+    my $member_func = "swig_${field}_set";
+    $self->$member_func($newval);
+}
+
+sub this {
+    my $ptr = shift;
+    return tied(%$ptr);
+}
+
+
+# ------- FUNCTION WRAPPERS --------
+
+package secdb;
+
+*getprofnam = *secdbc::getprofnam;
+*getprofattr = *secdbc::getprofattr;
+*getproflist = *secdbc::getproflist;
+*setprofattr = *secdbc::setprofattr;
+*endprofattr = *secdbc::endprofattr;
+*free_profattr = *secdbc::free_profattr;
+*free_proflist = *secdbc::free_proflist;
+*getusernam = *secdbc::getusernam;
+*getuseruid = *secdbc::getuseruid;
+*getuserattr = *secdbc::getuserattr;
+*fgetuserattr = *secdbc::fgetuserattr;
+*setuserattr = *secdbc::setuserattr;
+*enduserattr = *secdbc::enduserattr;
+*free_userattr = *secdbc::free_userattr;
+*kva_match = *secdbc::kva_match;
+*_auth_match = *secdbc::_auth_match;
+*_argv_to_csl = *secdbc::_argv_to_csl;
+*_csl_to_argv = *secdbc::_csl_to_argv;
+*_do_unescape = *secdbc::_do_unescape;
+*_free_argv = *secdbc::_free_argv;
+*_insert2kva = *secdbc::_insert2kva;
+*_kva2str = *secdbc::_kva2str;
+*_kva_dup = *secdbc::_kva_dup;
+*_kva_free = *secdbc::_kva_free;
+*_new_kva = *secdbc::_new_kva;
+*_str2kva = *secdbc::_str2kva;
+
+############# Class : secdb::profstr_t ##############
+
+package secdb::profstr_t;
+use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
+@ISA = qw( secdb );
+%OWNER = ();
+%ITERATORS = ();
+*swig_name_get = *secdbc::profstr_t_name_get;
+*swig_name_set = *secdbc::profstr_t_name_set;
+*swig_res1_get = *secdbc::profstr_t_res1_get;
+*swig_res1_set = *secdbc::profstr_t_res1_set;
+*swig_res2_get = *secdbc::profstr_t_res2_get;
+*swig_res2_set = *secdbc::profstr_t_res2_set;
+*swig_desc_get = *secdbc::profstr_t_desc_get;
+*swig_desc_set = *secdbc::profstr_t_desc_set;
+*swig_attr_get = *secdbc::profstr_t_attr_get;
+*swig_attr_set = *secdbc::profstr_t_attr_set;
+sub new {
+    my $pkg = shift;
+    my $self = secdbc::new_profstr_t(@_);
+    bless $self, $pkg if defined($self);
+}
+
+sub DESTROY {
+    return unless $_[0]->isa('HASH');
+    my $self = tied(%{$_[0]});
+    return unless defined $self;
+    delete $ITERATORS{$self};
+    if (exists $OWNER{$self}) {
+        secdbc::delete_profstr_t($self);
+        delete $OWNER{$self};
+    }
+}
+
+sub DISOWN {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    delete $OWNER{$ptr};
+}
+
+sub ACQUIRE {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    $OWNER{$ptr} = 1;
+}
+
+
+############# Class : secdb::profattr_t ##############
+
+package secdb::profattr_t;
+use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
+@ISA = qw( secdb );
+%OWNER = ();
+%ITERATORS = ();
+*swig_name_get = *secdbc::profattr_t_name_get;
+*swig_name_set = *secdbc::profattr_t_name_set;
+*swig_res1_get = *secdbc::profattr_t_res1_get;
+*swig_res1_set = *secdbc::profattr_t_res1_set;
+*swig_res2_get = *secdbc::profattr_t_res2_get;
+*swig_res2_set = *secdbc::profattr_t_res2_set;
+*swig_desc_get = *secdbc::profattr_t_desc_get;
+*swig_desc_set = *secdbc::profattr_t_desc_set;
+*swig_attr_get = *secdbc::profattr_t_attr_get;
+*swig_attr_set = *secdbc::profattr_t_attr_set;
+sub new {
+    my $pkg = shift;
+    my $self = secdbc::new_profattr_t(@_);
+    bless $self, $pkg if defined($self);
+}
+
+sub DESTROY {
+    return unless $_[0]->isa('HASH');
+    my $self = tied(%{$_[0]});
+    return unless defined $self;
+    delete $ITERATORS{$self};
+    if (exists $OWNER{$self}) {
+        secdbc::delete_profattr_t($self);
+        delete $OWNER{$self};
+    }
+}
+
+sub DISOWN {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    delete $OWNER{$ptr};
+}
+
+sub ACQUIRE {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    $OWNER{$ptr} = 1;
+}
+
+
+############# Class : secdb::userstr_t ##############
+
+package secdb::userstr_t;
+use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
+@ISA = qw( secdb );
+%OWNER = ();
+%ITERATORS = ();
+*swig_name_get = *secdbc::userstr_t_name_get;
+*swig_name_set = *secdbc::userstr_t_name_set;
+*swig_qualifier_get = *secdbc::userstr_t_qualifier_get;
+*swig_qualifier_set = *secdbc::userstr_t_qualifier_set;
+*swig_res1_get = *secdbc::userstr_t_res1_get;
+*swig_res1_set = *secdbc::userstr_t_res1_set;
+*swig_res2_get = *secdbc::userstr_t_res2_get;
+*swig_res2_set = *secdbc::userstr_t_res2_set;
+*swig_attr_get = *secdbc::userstr_t_attr_get;
+*swig_attr_set = *secdbc::userstr_t_attr_set;
+sub new {
+    my $pkg = shift;
+    my $self = secdbc::new_userstr_t(@_);
+    bless $self, $pkg if defined($self);
+}
+
+sub DESTROY {
+    return unless $_[0]->isa('HASH');
+    my $self = tied(%{$_[0]});
+    return unless defined $self;
+    delete $ITERATORS{$self};
+    if (exists $OWNER{$self}) {
+        secdbc::delete_userstr_t($self);
+        delete $OWNER{$self};
+    }
+}
+
+sub DISOWN {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    delete $OWNER{$ptr};
+}
+
+sub ACQUIRE {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    $OWNER{$ptr} = 1;
+}
+
+
+############# Class : secdb::userattr_t ##############
+
+package secdb::userattr_t;
+use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
+@ISA = qw( secdb );
+%OWNER = ();
+%ITERATORS = ();
+*swig_name_get = *secdbc::userattr_t_name_get;
+*swig_name_set = *secdbc::userattr_t_name_set;
+*swig_qualifier_get = *secdbc::userattr_t_qualifier_get;
+*swig_qualifier_set = *secdbc::userattr_t_qualifier_set;
+*swig_res1_get = *secdbc::userattr_t_res1_get;
+*swig_res1_set = *secdbc::userattr_t_res1_set;
+*swig_res2_get = *secdbc::userattr_t_res2_get;
+*swig_res2_set = *secdbc::userattr_t_res2_set;
+*swig_attr_get = *secdbc::userattr_t_attr_get;
+*swig_attr_set = *secdbc::userattr_t_attr_set;
+sub new {
+    my $pkg = shift;
+    my $self = secdbc::new_userattr_t(@_);
+    bless $self, $pkg if defined($self);
+}
+
+sub DESTROY {
+    return unless $_[0]->isa('HASH');
+    my $self = tied(%{$_[0]});
+    return unless defined $self;
+    delete $ITERATORS{$self};
+    if (exists $OWNER{$self}) {
+        secdbc::delete_userattr_t($self);
+        delete $OWNER{$self};
+    }
+}
+
+sub DISOWN {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    delete $OWNER{$ptr};
+}
+
+sub ACQUIRE {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    $OWNER{$ptr} = 1;
+}
+
+
+############# Class : secdb::kv_t ##############
+
+package secdb::kv_t;
+use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
+@ISA = qw( secdb );
+%OWNER = ();
+%ITERATORS = ();
+*swig_key_get = *secdbc::kv_t_key_get;
+*swig_key_set = *secdbc::kv_t_key_set;
+*swig_value_get = *secdbc::kv_t_value_get;
+*swig_value_set = *secdbc::kv_t_value_set;
+sub new {
+    my $pkg = shift;
+    my $self = secdbc::new_kv_t(@_);
+    bless $self, $pkg if defined($self);
+}
+
+sub DESTROY {
+    return unless $_[0]->isa('HASH');
+    my $self = tied(%{$_[0]});
+    return unless defined $self;
+    delete $ITERATORS{$self};
+    if (exists $OWNER{$self}) {
+        secdbc::delete_kv_t($self);
+        delete $OWNER{$self};
+    }
+}
+
+sub DISOWN {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    delete $OWNER{$ptr};
+}
+
+sub ACQUIRE {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    $OWNER{$ptr} = 1;
+}
+
+
+############# Class : secdb::kva_t ##############
+
+package secdb::kva_t;
+use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
+@ISA = qw( secdb );
+%OWNER = ();
+%ITERATORS = ();
+*swig_length_get = *secdbc::kva_t_length_get;
+*swig_length_set = *secdbc::kva_t_length_set;
+*swig_data_get = *secdbc::kva_t_data_get;
+*swig_data_set = *secdbc::kva_t_data_set;
+sub new {
+    my $pkg = shift;
+    my $self = secdbc::new_kva_t(@_);
+    bless $self, $pkg if defined($self);
+}
+
+sub DESTROY {
+    return unless $_[0]->isa('HASH');
+    my $self = tied(%{$_[0]});
+    return unless defined $self;
+    delete $ITERATORS{$self};
+    if (exists $OWNER{$self}) {
+        secdbc::delete_kva_t($self);
+        delete $OWNER{$self};
+    }
+}
+
+sub DISOWN {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    delete $OWNER{$ptr};
+}
+
+sub ACQUIRE {
+    my $self = shift;
+    my $ptr = tied(%$self);
+    $OWNER{$ptr} = 1;
+}
+
+
+# ------- VARIABLE STUBS --------
+
+package secdb;
+
+*PROFATTR_FILENAME = *secdbc::PROFATTR_FILENAME;
+*PROFATTR_DB_NAME = *secdbc::PROFATTR_DB_NAME;
+*PROFATTR_DB_NCOL = *secdbc::PROFATTR_DB_NCOL;
+*PROFATTR_DB_NKEYCOL = *secdbc::PROFATTR_DB_NKEYCOL;
+*PROFATTR_DB_TBLT = *secdbc::PROFATTR_DB_TBLT;
+*PROFATTR_NAME_DEFAULT_KW = *secdbc::PROFATTR_NAME_DEFAULT_KW;
+*PROFATTR_COL0_KW = *secdbc::PROFATTR_COL0_KW;
+*PROFATTR_COL1_KW = *secdbc::PROFATTR_COL1_KW;
+*PROFATTR_COL2_KW = *secdbc::PROFATTR_COL2_KW;
+*PROFATTR_COL3_KW = *secdbc::PROFATTR_COL3_KW;
+*PROFATTR_COL4_KW = *secdbc::PROFATTR_COL4_KW;
+*DEF_PROF = *secdbc::DEF_PROF;
+*DEF_CONSUSER = *secdbc::DEF_CONSUSER;
+*MAXPROFS = *secdbc::MAXPROFS;
+*PROFATTR_KEYCOL0 = *secdbc::PROFATTR_KEYCOL0;
+*PROFATTR_AUTHS_KW = *secdbc::PROFATTR_AUTHS_KW;
+*PROFATTR_PROFS_KW = *secdbc::PROFATTR_PROFS_KW;
+*PROFATTR_PRIVS_KW = *secdbc::PROFATTR_PRIVS_KW;
+*USERATTR_FILENAME = *secdbc::USERATTR_FILENAME;
+*USERATTR_DB_NAME = *secdbc::USERATTR_DB_NAME;
+*USERATTR_DB_NCOL = *secdbc::USERATTR_DB_NCOL;
+*USERATTR_DB_NKEYCOL = *secdbc::USERATTR_DB_NKEYCOL;
+*USERATTR_DB_TBL = *secdbc::USERATTR_DB_TBL;
+*USERATTR_NAME_DEFAULT_KW = *secdbc::USERATTR_NAME_DEFAULT_KW;
+*USERATTR_COL0_KW = *secdbc::USERATTR_COL0_KW;
+*USERATTR_COL1_KW = *secdbc::USERATTR_COL1_KW;
+*USERATTR_COL2_KW = *secdbc::USERATTR_COL2_KW;
+*USERATTR_COL3_KW = *secdbc::USERATTR_COL3_KW;
+*USERATTR_COL4_KW = *secdbc::USERATTR_COL4_KW;
+*DEF_LIMITPRIV = *secdbc::DEF_LIMITPRIV;
+*DEF_DFLTPRIV = *secdbc::DEF_DFLTPRIV;
+*USERATTR_KEYCOL0 = *secdbc::USERATTR_KEYCOL0;
+*USERATTR_KEYCOL1 = *secdbc::USERATTR_KEYCOL1;
+*USERATTR_LOCK_KW = *secdbc::USERATTR_LOCK_KW;
+*USERATTR_LOCK_LOCKED_KW = *secdbc::USERATTR_LOCK_LOCKED_KW;
+*USERATTR_LOCK_OPEN_KW = *secdbc::USERATTR_LOCK_OPEN_KW;
+*USERATTR_LOCK_FIXED_KW = *secdbc::USERATTR_LOCK_FIXED_KW;
+*USERATTR_GEN_KW = *secdbc::USERATTR_GEN_KW;
+*USERATTR_GEN_AUTOMATIC_KW = *secdbc::USERATTR_GEN_AUTOMATIC_KW;
+*USERATTR_GEN_MANUAL_KW = *secdbc::USERATTR_GEN_MANUAL_KW;
+*USERATTR_GEN_SYSDEF_KW = *secdbc::USERATTR_GEN_SYSDEF_KW;
+*USERATTR_PROFILES_KW = *secdbc::USERATTR_PROFILES_KW;
+*USERATTR_PROFILES_NONE_KW = *secdbc::USERATTR_PROFILES_NONE_KW;
+*USERATTR_ROLES_KW = *secdbc::USERATTR_ROLES_KW;
+*USERATTR_ROLES_NONE_KW = *secdbc::USERATTR_ROLES_NONE_KW;
+*USERATTR_DEFAULTPROJ_KW = *secdbc::USERATTR_DEFAULTPROJ_KW;
+*USERATTR_IDLETIME_KW = *secdbc::USERATTR_IDLETIME_KW;
+*USERATTR_IDLECMD_KW = *secdbc::USERATTR_IDLECMD_KW;
+*USERATTR_IDLECMD_LOCK_KW = *secdbc::USERATTR_IDLECMD_LOCK_KW;
+*USERATTR_IDLECMD_LOGOUT_KW = *secdbc::USERATTR_IDLECMD_LOGOUT_KW;
+*USERATTR_TYPE_KW = *secdbc::USERATTR_TYPE_KW;
+*USERATTR_TYPE_NORMAL_KW = *secdbc::USERATTR_TYPE_NORMAL_KW;
+*USERATTR_TYPE_ADMIN_KW = *secdbc::USERATTR_TYPE_ADMIN_KW;
+*USERATTR_TYPE_NONADMIN_KW = *secdbc::USERATTR_TYPE_NONADMIN_KW;
+*USERATTR_AUTHS_KW = *secdbc::USERATTR_AUTHS_KW;
+*USERATTR_LIMPRIV_KW = *secdbc::USERATTR_LIMPRIV_KW;
+*USERATTR_DFLTPRIV_KW = *secdbc::USERATTR_DFLTPRIV_KW;
+*USERATTR_LOCK_AFTER_RETRIES_KW = *secdbc::USERATTR_LOCK_AFTER_RETRIES_KW;
+*USERATTR_CLEARANCE = *secdbc::USERATTR_CLEARANCE;
+*USERATTR_LABELVIEW = *secdbc::USERATTR_LABELVIEW;
+*USERATTR_LABELVIEW_EXTERNAL = *secdbc::USERATTR_LABELVIEW_EXTERNAL;
+*USERATTR_LABELVIEW_HIDESL = *secdbc::USERATTR_LABELVIEW_HIDESL;
+*USERATTR_HIDESL = *secdbc::USERATTR_HIDESL;
+*USERATTR_LABELVIEW_INTERNAL = *secdbc::USERATTR_LABELVIEW_INTERNAL;
+*USERATTR_LABELVIEW_SHOWSL = *secdbc::USERATTR_LABELVIEW_SHOWSL;
+*USERATTR_LABELTRANS = *secdbc::USERATTR_LABELTRANS;
+*USERATTR_LOCK_NO = *secdbc::USERATTR_LOCK_NO;
+*USERATTR_LOCK_YES = *secdbc::USERATTR_LOCK_YES;
+*USERATTR_MINLABEL = *secdbc::USERATTR_MINLABEL;
+*USERATTR_PASSWD = *secdbc::USERATTR_PASSWD;
+*USERATTR_PASSWD_AUTOMATIC = *secdbc::USERATTR_PASSWD_AUTOMATIC;
+*USERATTR_PASSWD_MANUAL = *secdbc::USERATTR_PASSWD_MANUAL;
+*USERATTR_TYPE_ROLE = *secdbc::USERATTR_TYPE_ROLE;
+*DEFAULT_POLICY = *secdbc::DEFAULT_POLICY;
+*SUSER_POLICY = *secdbc::SUSER_POLICY;
+*KV_ACTION = *secdbc::KV_ACTION;
+*KV_COMMAND = *secdbc::KV_COMMAND;
+*KV_JAVA_CLASS = *secdbc::KV_JAVA_CLASS;
+*KV_JAVA_METHOD = *secdbc::KV_JAVA_METHOD;
+*KV_ASSIGN = *secdbc::KV_ASSIGN;
+*KV_DELIMITER = *secdbc::KV_DELIMITER;
+*KV_EMPTY = *secdbc::KV_EMPTY;
+*KV_ESCAPE = *secdbc::KV_ESCAPE;
+*KV_ADD_KEYS = *secdbc::KV_ADD_KEYS;
+*KV_SPECIAL = *secdbc::KV_SPECIAL;
+*KV_TOKEN_DELIMIT = *secdbc::KV_TOKEN_DELIMIT;
+*KV_WILDCARD = *secdbc::KV_WILDCARD;
+*KV_WILDCHAR = *secdbc::KV_WILDCHAR;
+*KV_ACTION_WILDCARD = *secdbc::KV_ACTION_WILDCARD;
+*KV_FLAG_NONE = *secdbc::KV_FLAG_NONE;
+*KV_FLAG_REQUIRED = *secdbc::KV_FLAG_REQUIRED;
+*ATTR_FOUND = *secdbc::ATTR_FOUND;
+*ATTR_NOT_FOUND = *secdbc::ATTR_NOT_FOUND;
+*ATTR_NO_RECOVERY = *secdbc::ATTR_NO_RECOVERY;
+1;
--- system-tools-backends-1.4.2/secdb_wrap.c	1970-01-01 10:00:00.000000000 +1000
+++ system-tools-backends-1.4.2.new/secdb_wrap.c	2010-08-05 16:30:19.199811777 +1000
@@ -0,0 +1,5442 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 1.3.35
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPERL
+#define SWIG_CASTRANK_MODE
+/* -----------------------------------------------------------------------------
+ *  This section contains generic SWIG labels for method/variable
+ *  declarations/attributes, and other compiler dependent labels.
+ * ----------------------------------------------------------------------------- */
+
+/* template workaround for compilers that cannot correctly implement the C++ standard */
+#ifndef SWIGTEMPLATEDISAMBIGUATOR
+# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# else
+#  define SWIGTEMPLATEDISAMBIGUATOR
+# endif
+#endif
+
+/* inline attribute */
+#ifndef SWIGINLINE
+# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+#   define SWIGINLINE inline
+# else
+#   define SWIGINLINE
+# endif
+#endif
+
+/* attribute recognised by some compilers to avoid 'unused' warnings */
+#ifndef SWIGUNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define SWIGUNUSED __attribute__ ((__unused__)) 
+#   else
+#     define SWIGUNUSED
+#   endif
+# elif defined(__ICC)
+#   define SWIGUNUSED __attribute__ ((__unused__)) 
+# else
+#   define SWIGUNUSED 
+# endif
+#endif
+
+#ifndef SWIGUNUSEDPARM
+# ifdef __cplusplus
+#   define SWIGUNUSEDPARM(p)
+# else
+#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+# endif
+#endif
+
+/* internal SWIG method */
+#ifndef SWIGINTERN
+# define SWIGINTERN static SWIGUNUSED
+#endif
+
+/* internal inline SWIG method */
+#ifndef SWIGINTERNINLINE
+# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+#endif
+
+/* exporting methods */
+#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#  ifndef GCC_HASCLASSVISIBILITY
+#    define GCC_HASCLASSVISIBILITY
+#  endif
+#endif
+
+#ifndef SWIGEXPORT
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   if defined(STATIC_LINKED)
+#     define SWIGEXPORT
+#   else
+#     define SWIGEXPORT __declspec(dllexport)
+#   endif
+# else
+#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+#     define SWIGEXPORT __attribute__ ((visibility("default")))
+#   else
+#     define SWIGEXPORT
+#   endif
+# endif
+#endif
+
+/* calling conventions for Windows */
+#ifndef SWIGSTDCALL
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   define SWIGSTDCALL __stdcall
+# else
+#   define SWIGSTDCALL
+# endif 
+#endif
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * swigrun.swg
+ *
+ * This file contains generic CAPI SWIG runtime support for pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+/* This should only be incremented when either the layout of swig_type_info changes,
+   or for whatever reason, the runtime changes incompatibly */
+#define SWIG_RUNTIME_VERSION "4"
+
+/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+#ifdef SWIG_TYPE_TABLE
+# define SWIG_QUOTE_STRING(x) #x
+# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+#else
+# define SWIG_TYPE_TABLE_NAME
+#endif
+
+/*
+  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+  creating a static or dynamic library from the swig runtime code.
+  In 99.9% of the cases, swig just needs to declare them as 'static'.
+  
+  But only do this if is strictly necessary, ie, if you have problems
+  with your compiler or so.
+*/
+
+#ifndef SWIGRUNTIME
+# define SWIGRUNTIME SWIGINTERN
+#endif
+
+#ifndef SWIGRUNTIMEINLINE
+# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+#endif
+
+/*  Generic buffer size */
+#ifndef SWIG_BUFFER_SIZE
+# define SWIG_BUFFER_SIZE 1024
+#endif
+
+/* Flags for pointer conversions */
+#define SWIG_POINTER_DISOWN        0x1
+#define SWIG_CAST_NEW_MEMORY       0x2
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_OWN           0x1
+
+
+/* 
+   Flags/methods for returning states.
+   
+   The swig conversion methods, as ConvertPtr, return and integer 
+   that tells if the conversion was successful or not. And if not,
+   an error code can be returned (see swigerrors.swg for the codes).
+   
+   Use the following macros/flags to set or process the returning
+   states.
+   
+   In old swig versions, you usually write code as:
+
+     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+       // success code
+     } else {
+       //fail code
+     }
+
+   Now you can be more explicit as:
+
+    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+    } else {
+      // fail code
+    }
+
+   that seems to be the same, but now you can also do
+
+    Type *ptr;
+    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+      if (SWIG_IsNewObj(res) {
+        ...
+	delete *ptr;
+      } else {
+        ...
+      }
+    } else {
+      // fail code
+    }
+    
+   I.e., now SWIG_ConvertPtr can return new objects and you can
+   identify the case and take care of the deallocation. Of course that
+   requires also to SWIG_ConvertPtr to return new result values, as
+
+      int SWIG_ConvertPtr(obj, ptr,...) {         
+        if (<obj is ok>) {			       
+          if (<need new object>) {		       
+            *ptr = <ptr to new allocated object>; 
+            return SWIG_NEWOBJ;		       
+          } else {				       
+            *ptr = <ptr to old object>;	       
+            return SWIG_OLDOBJ;		       
+          } 				       
+        } else {				       
+          return SWIG_BADOBJ;		       
+        }					       
+      }
+
+   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+   swig errors code.
+
+   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+   allows to return the 'cast rank', for example, if you have this
+
+       int food(double)
+       int fooi(int);
+
+   and you call
+ 
+      food(1)   // cast rank '1'  (1 -> 1.0)
+      fooi(1)   // cast rank '0'
+
+   just use the SWIG_AddCast()/SWIG_CheckState()
+
+
+ */
+#define SWIG_OK                    (0) 
+#define SWIG_ERROR                 (-1)
+#define SWIG_IsOK(r)               (r >= 0)
+#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+
+/* The CastRankLimit says how many bits are used for the cast rank */
+#define SWIG_CASTRANKLIMIT         (1 << 8)
+/* The NewMask denotes the object was created (using new/malloc) */
+#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+/* The TmpMask is for in/out typemaps that use temporal objects */
+#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+/* Simple returning values */
+#define SWIG_BADOBJ                (SWIG_ERROR)
+#define SWIG_OLDOBJ                (SWIG_OK)
+#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+/* Check, add and del mask methods */
+#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+
+
+/* Cast-Rank Mode */
+#if defined(SWIG_CASTRANK_MODE)
+#  ifndef SWIG_TypeRank
+#    define SWIG_TypeRank             unsigned long
+#  endif
+#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+#    define SWIG_MAXCASTRANK          (2)
+#  endif
+#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+}
+SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+}
+#else /* no cast-rank mode */
+#  define SWIG_AddCast
+#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+#endif
+
+
+
+
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *(*swig_converter_func)(void *, int *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+/* Structure to store information on one type */
+typedef struct swig_type_info {
+  const char             *name;			/* mangled name of this type */
+  const char             *str;			/* human readable name of this type */
+  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+  void                   *clientdata;		/* language specific type data */
+  int                    owndata;		/* flag if the structure owns the clientdata */
+} swig_type_info;
+
+/* Structure to store a type and conversion function used for casting */
+typedef struct swig_cast_info {
+  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+  swig_converter_func     converter;		/* function to cast the void pointers */
+  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+  struct swig_cast_info  *prev;			/* pointer to the previous cast */
+} swig_cast_info;
+
+/* Structure used to store module information
+ * Each module generates one structure like this, and the runtime collects
+ * all of these structures and stores them in a circularly linked list.*/
+typedef struct swig_module_info {
+  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+  size_t                 size;		        /* Number of types in this module */
+  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+  swig_type_info         **type_initial;	/* Array of initially generated type structures */
+  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+  void                    *clientdata;		/* Language specific module data */
+} swig_module_info;
+
+/* 
+  Compare two type names skipping the space characters, therefore
+  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+
+  Return 0 when the two name types are equivalent, as in
+  strncmp, but skipping ' '.
+*/
+SWIGRUNTIME int
+SWIG_TypeNameComp(const char *f1, const char *l1,
+		  const char *f2, const char *l2) {
+  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+    while ((*f1 == ' ') && (f1 != l1)) ++f1;
+    while ((*f2 == ' ') && (f2 != l2)) ++f2;
+    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+  }
+  return (int)((l1 - f1) - (l2 - f2));
+}
+
+/*
+  Check type equivalence in a name list like <name1>|<name2>|...
+  Return 0 if not equal, 1 if equal
+*/
+SWIGRUNTIME int
+SWIG_TypeEquiv(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv && *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+/*
+  Check type equivalence in a name list like <name1>|<name2>|...
+  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+*/
+SWIGRUNTIME int
+SWIG_TypeCompare(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv && *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+
+/* think of this as a c++ template<> or a scheme macro */
+#define SWIG_TypeCheck_Template(comparison, ty)         \
+  if (ty) {                                             \
+    swig_cast_info *iter = ty->cast;                    \
+    while (iter) {                                      \
+      if (comparison) {                                 \
+        if (iter == ty->cast) return iter;              \
+        /* Move iter to the top of the linked list */   \
+        iter->prev->next = iter->next;                  \
+        if (iter->next)                                 \
+          iter->next->prev = iter->prev;                \
+        iter->next = ty->cast;                          \
+        iter->prev = 0;                                 \
+        if (ty->cast) ty->cast->prev = iter;            \
+        ty->cast = iter;                                \
+        return iter;                                    \
+      }                                                 \
+      iter = iter->next;                                \
+    }                                                   \
+  }                                                     \
+  return 0
+
+/*
+  Check the typename
+*/
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+}
+
+/* Same as previous function, except strcmp is replaced with a pointer comparison */
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+  SWIG_TypeCheck_Template(iter->type == from, into);
+}
+
+/*
+  Cast a pointer up an inheritance hierarchy
+*/
+SWIGRUNTIMEINLINE void *
+SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
+}
+
+/* 
+   Dynamic pointer casting. Down an inheritance hierarchy
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty->dcast) return ty;
+  while (ty && (ty->dcast)) {
+    ty = (*ty->dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/*
+  Return the name associated with this type
+*/
+SWIGRUNTIMEINLINE const char *
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty->name;
+}
+
+/*
+  Return the pretty name associated with this type,
+  that is an unmangled type name in a form presentable to the user.
+*/
+SWIGRUNTIME const char *
+SWIG_TypePrettyName(const swig_type_info *type) {
+  /* The "str" field contains the equivalent pretty names of the
+     type, separated by vertical-bar characters.  We choose
+     to print the last name, as it is often (?) the most
+     specific. */
+  if (!type) return NULL;
+  if (type->str != NULL) {
+    const char *last_name = type->str;
+    const char *s;
+    for (s = type->str; *s; s++)
+      if (*s == '|') last_name = s+1;
+    return last_name;
+  }
+  else
+    return type->name;
+}
+
+/* 
+   Set the clientdata field for a type
+*/
+SWIGRUNTIME void
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_cast_info *cast = ti->cast;
+  /* if (ti->clientdata == clientdata) return; */
+  ti->clientdata = clientdata;
+  
+  while (cast) {
+    if (!cast->converter) {
+      swig_type_info *tc = cast->type;
+      if (!tc->clientdata) {
+	SWIG_TypeClientData(tc, clientdata);
+      }
+    }    
+    cast = cast->next;
+  }
+}
+SWIGRUNTIME void
+SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+  SWIG_TypeClientData(ti, clientdata);
+  ti->owndata = 1;
+}
+  
+/*
+  Search for a swig_type_info structure only by mangled name
+  Search is a O(log #types)
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                            swig_module_info *end, 
+		            const char *name) {
+  swig_module_info *iter = start;
+  do {
+    if (iter->size) {
+      register size_t l = 0;
+      register size_t r = iter->size - 1;
+      do {
+	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+	register size_t i = (l + r) >> 1; 
+	const char *iname = iter->types[i]->name;
+	if (iname) {
+	  register int compare = strcmp(name, iname);
+	  if (compare == 0) {	    
+	    return iter->types[i];
+	  } else if (compare < 0) {
+	    if (i) {
+	      r = i - 1;
+	    } else {
+	      break;
+	    }
+	  } else if (compare > 0) {
+	    l = i + 1;
+	  }
+	} else {
+	  break; /* should never happen */
+	}
+      } while (l <= r);
+    }
+    iter = iter->next;
+  } while (iter != end);
+  return 0;
+}
+
+/*
+  Search for a swig_type_info structure for either a mangled name or a human readable name.
+  It first searches the mangled names of the types, which is a O(log #types)
+  If a type is not found it then searches the human readable names, which is O(#types).
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeQueryModule(swig_module_info *start, 
+                     swig_module_info *end, 
+		     const char *name) {
+  /* STEP 1: Search the name field using binary search */
+  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+  if (ret) {
+    return ret;
+  } else {
+    /* STEP 2: If the type hasn't been found, do a complete search
+       of the str field (the human readable name) */
+    swig_module_info *iter = start;
+    do {
+      register size_t i = 0;
+      for (; i < iter->size; ++i) {
+	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+	  return iter->types[i];
+      }
+      iter = iter->next;
+    } while (iter != end);
+  }
+  
+  /* neither found a match */
+  return 0;
+}
+
+/* 
+   Pack binary data into a string
+*/
+SWIGRUNTIME char *
+SWIG_PackData(char *c, void *ptr, size_t sz) {
+  static const char hex[17] = "0123456789abcdef";
+  register const unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu =  u + sz;
+  for (; u != eu; ++u) {
+    register unsigned char uu = *u;
+    *(c++) = hex[(uu & 0xf0) >> 4];
+    *(c++) = hex[uu & 0xf];
+  }
+  return c;
+}
+
+/* 
+   Unpack binary data from a string
+*/
+SWIGRUNTIME const char *
+SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+  register unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu = u + sz;
+  for (; u != eu; ++u) {
+    register char d = *(c++);
+    register unsigned char uu;
+    if ((d >= '0') && (d <= '9'))
+      uu = ((d - '0') << 4);
+    else if ((d >= 'a') && (d <= 'f'))
+      uu = ((d - ('a'-10)) << 4);
+    else 
+      return (char *) 0;
+    d = *(c++);
+    if ((d >= '0') && (d <= '9'))
+      uu |= (d - '0');
+    else if ((d >= 'a') && (d <= 'f'))
+      uu |= (d - ('a'-10));
+    else 
+      return (char *) 0;
+    *u = uu;
+  }
+  return c;
+}
+
+/* 
+   Pack 'void *' into a string buffer.
+*/
+SWIGRUNTIME char *
+SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+  char *r = buff;
+  if ((2*sizeof(void *) + 2) > bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,&ptr,sizeof(void *));
+  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+  strcpy(r,name);
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,"NULL") == 0) {
+      *ptr = (void *) 0;
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sizeof(void *));
+}
+
+SWIGRUNTIME char *
+SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+  char *r = buff;
+  size_t lname = (name ? strlen(name) : 0);
+  if ((2*sz + 2 + lname) > bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  if (lname) {
+    strncpy(r,name,lname+1);
+  } else {
+    *r = 0;
+  }
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,"NULL") == 0) {
+      memset(ptr,0,sz);
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sz);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/*  Errors in SWIG */
+#define  SWIG_UnknownError    	   -1 
+#define  SWIG_IOError        	   -2 
+#define  SWIG_RuntimeError   	   -3 
+#define  SWIG_IndexError     	   -4 
+#define  SWIG_TypeError      	   -5 
+#define  SWIG_DivisionByZero 	   -6 
+#define  SWIG_OverflowError  	   -7 
+#define  SWIG_SyntaxError    	   -8 
+#define  SWIG_ValueError     	   -9 
+#define  SWIG_SystemError    	   -10
+#define  SWIG_AttributeError 	   -11
+#define  SWIG_MemoryError    	   -12 
+#define  SWIG_NullReferenceError   -13
+
+
+
+#ifdef __cplusplus
+/* Needed on some windows machines---since MS plays funny games with the header files under C++ */
+#include <math.h>
+#include <stdlib.h>
+extern "C" {
+#endif
+#include "EXTERN.h"
+#include "perl.h"
+#include "XSUB.h"
+
+/* Add in functionality missing in older versions of Perl. Much of this is based on Devel-PPPort on cpan. */
+
+/* Add PERL_REVISION, PERL_VERSION, PERL_SUBVERSION if missing */
+#ifndef PERL_REVISION
+#  if !defined(__PATCHLEVEL_H_INCLUDED__) && !(defined(PATCHLEVEL) && defined(SUBVERSION))
+#    define PERL_PATCHLEVEL_H_IMPLICIT
+#    include <patchlevel.h>
+#  endif
+#  if !(defined(PERL_VERSION) || (defined(SUBVERSION) && defined(PATCHLEVEL)))
+#    include <could_not_find_Perl_patchlevel.h>
+#  endif
+#  ifndef PERL_REVISION
+#    define PERL_REVISION       (5)
+#    define PERL_VERSION        PATCHLEVEL
+#    define PERL_SUBVERSION     SUBVERSION
+#  endif
+#endif
+
+#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
+#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
+#endif
+
+#ifndef SvIOK_UV
+# define SvIOK_UV(sv)       (SvIOK(sv) && (SvUVX(sv) == SvIVX(sv)))
+#endif
+
+#ifndef SvUOK
+# define SvUOK(sv)           SvIOK_UV(sv)
+#endif
+
+#if ((PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 5)))
+#  define PL_sv_undef               sv_undef
+#  define PL_na	                    na
+#  define PL_errgv                  errgv
+#  define PL_sv_no                  sv_no
+#  define PL_sv_yes                 sv_yes
+#  define PL_markstack_ptr          markstack_ptr
+#endif
+
+#ifndef IVSIZE
+#  ifdef LONGSIZE
+#    define IVSIZE LONGSIZE
+#  else
+#    define IVSIZE 4 /* A bold guess, but the best we can make. */
+#  endif
+#endif
+
+#ifndef INT2PTR
+#  if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
+#    define PTRV                  UV
+#    define INT2PTR(any,d)        (any)(d)
+#  else
+#    if PTRSIZE == LONGSIZE
+#      define PTRV                unsigned long
+#    else
+#      define PTRV                unsigned
+#    endif
+#    define INT2PTR(any,d)        (any)(PTRV)(d)
+#  endif
+
+#  define NUM2PTR(any,d)  (any)(PTRV)(d)
+#  define PTR2IV(p)       INT2PTR(IV,p)
+#  define PTR2UV(p)       INT2PTR(UV,p)
+#  define PTR2NV(p)       NUM2PTR(NV,p)
+
+#  if PTRSIZE == LONGSIZE
+#    define PTR2ul(p)     (unsigned long)(p)
+#  else
+#    define PTR2ul(p)     INT2PTR(unsigned long,p)
+#  endif
+#endif /* !INT2PTR */
+
+#ifndef SvPV_nolen
+# define SvPV_nolen(x) SvPV(x,PL_na)
+#endif
+
+#ifndef get_sv
+#  define get_sv perl_get_sv
+#endif
+
+#ifndef ERRSV
+#  define ERRSV get_sv("@",FALSE)
+#endif
+
+#ifndef pTHX_
+#define pTHX_
+#endif   
+
+#include <string.h>
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------
+ * error manipulation
+ * ----------------------------------------------------------------------------- */
+
+SWIGINTERN const char*
+SWIG_Perl_ErrorType(int code) {
+  const char* type = 0;
+  switch(code) {
+  case SWIG_MemoryError:
+    type = "MemoryError";
+    break;
+  case SWIG_IOError:
+    type = "IOError";
+    break;
+  case SWIG_RuntimeError:
+    type = "RuntimeError";
+    break;
+  case SWIG_IndexError:
+    type = "IndexError";
+    break;
+  case SWIG_TypeError:
+    type = "TypeError";
+    break;
+  case SWIG_DivisionByZero:
+    type = "ZeroDivisionError";
+    break;
+  case SWIG_OverflowError:
+    type = "OverflowError";
+    break;
+  case SWIG_SyntaxError:
+    type = "SyntaxError";
+    break;
+  case SWIG_ValueError:
+    type = "ValueError";
+    break;
+  case SWIG_SystemError:
+    type = "SystemError";
+    break;
+  case SWIG_AttributeError:
+    type = "AttributeError";
+    break;
+  default:
+    type = "RuntimeError";
+  }
+  return type;
+}
+
+
+
+
+/* -----------------------------------------------------------------------------
+ * perlrun.swg
+ *
+ * This file contains the runtime support for Perl modules
+ * and includes code for managing global variables and pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef PERL_OBJECT
+#define SWIG_PERL_OBJECT_DECL CPerlObj *SWIGUNUSEDPARM(pPerl),
+#define SWIG_PERL_OBJECT_CALL pPerl,
+#else
+#define SWIG_PERL_OBJECT_DECL
+#define SWIG_PERL_OBJECT_CALL
+#endif
+
+/* Common SWIG API */
+
+/* for raw pointers */
+#define SWIG_ConvertPtr(obj, pp, type, flags)           SWIG_Perl_ConvertPtr(SWIG_PERL_OBJECT_CALL obj, pp, type, flags)
+#define SWIG_NewPointerObj(p, type, flags)              SWIG_Perl_NewPointerObj(SWIG_PERL_OBJECT_CALL p, type, flags)
+
+/* for raw packed data */
+#define SWIG_ConvertPacked(obj, p, s, type)             SWIG_Perl_ConvertPacked(SWIG_PERL_OBJECT_CALL obj, p, s, type)
+#define SWIG_NewPackedObj(p, s, type)	                SWIG_Perl_NewPackedObj(SWIG_PERL_OBJECT_CALL p, s, type)
+
+/* for class or struct pointers */
+#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
+#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
+
+/* for C or C++ function pointers */
+#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
+#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)
+
+/* for C++ member pointers, ie, member methods */
+#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_ConvertPacked(obj, ptr, sz, ty)
+#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_NewPackedObj(ptr, sz, type)
+
+
+/* Runtime API */
+
+#define SWIG_GetModule(clientdata)                      SWIG_Perl_GetModule()
+#define SWIG_SetModule(clientdata, pointer)             SWIG_Perl_SetModule(pointer)
+
+
+/* Error manipulation */
+
+#define SWIG_ErrorType(code)                            SWIG_Perl_ErrorType(code)               
+#define SWIG_Error(code, msg)            		sv_setpvf(GvSV(PL_errgv),"%s %s\n", SWIG_ErrorType(code), msg)
+#define SWIG_fail                        		goto fail						    
+
+/* Perl-specific SWIG API */
+
+#define SWIG_MakePtr(sv, ptr, type, flags)              SWIG_Perl_MakePtr(SWIG_PERL_OBJECT_CALL sv, ptr, type, flags)
+#define SWIG_MakePackedObj(sv, p, s, type)	        SWIG_Perl_MakePackedObj(SWIG_PERL_OBJECT_CALL sv, p, s, type)
+#define SWIG_SetError(str)                              SWIG_Error(SWIG_RuntimeError, str)
+
+
+#define SWIG_PERL_DECL_ARGS_1(arg1)                     (SWIG_PERL_OBJECT_DECL arg1)
+#define SWIG_PERL_CALL_ARGS_1(arg1)                     (SWIG_PERL_OBJECT_CALL arg1)
+#define SWIG_PERL_DECL_ARGS_2(arg1, arg2)               (SWIG_PERL_OBJECT_DECL arg1, arg2)
+#define SWIG_PERL_CALL_ARGS_2(arg1, arg2)               (SWIG_PERL_OBJECT_CALL arg1, arg2)
+
+/* -----------------------------------------------------------------------------
+ * pointers/data manipulation
+ * ----------------------------------------------------------------------------- */
+
+/* For backward compatibility only */
+#define SWIG_POINTER_EXCEPTION  0
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SWIG_OWNER   SWIG_POINTER_OWN
+#define SWIG_SHADOW  SWIG_OWNER << 1
+
+#define SWIG_MAYBE_PERL_OBJECT SWIG_PERL_OBJECT_DECL
+
+/* SWIG Perl macros */
+
+/* Macro to declare an XS function */
+#ifndef XSPROTO
+#   define XSPROTO(name) void name(pTHX_ CV* cv)
+#endif
+
+/* Macro to call an XS function */
+#ifdef PERL_OBJECT 
+#  define SWIG_CALLXS(_name) _name(cv,pPerl) 
+#else 
+#  ifndef MULTIPLICITY 
+#    define SWIG_CALLXS(_name) _name(cv) 
+#  else 
+#    define SWIG_CALLXS(_name) _name(PERL_GET_THX, cv) 
+#  endif 
+#endif 
+
+#ifdef PERL_OBJECT
+#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);
+#ifdef __cplusplus
+}
+#endif
+
+#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
+#define SWIGCLASS_STATIC
+
+#else /* PERL_OBJECT */
+
+#define MAGIC_PPERL
+#define SWIGCLASS_STATIC static SWIGUNUSED
+
+#ifndef MULTIPLICITY
+#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef int (*SwigMagicFunc)(SV *, MAGIC *);
+#ifdef __cplusplus
+}
+#endif
+
+#else /* MULTIPLICITY */
+
+#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MULTIPLICITY */
+#endif /* PERL_OBJECT */
+
+/* Workaround for bug in perl 5.6.x croak and earlier */
+#if (PERL_VERSION < 8)
+#  ifdef PERL_OBJECT
+#    define SWIG_croak_null() SWIG_Perl_croak_null(pPerl)
+static void SWIG_Perl_croak_null(CPerlObj *pPerl)
+#  else
+static void SWIG_croak_null()
+#  endif
+{
+  SV *err=ERRSV;
+#  if (PERL_VERSION < 6)
+  croak("%_", err);
+#  else
+  if (SvOK(err) && !SvROK(err)) croak("%_", err);
+  croak(Nullch);
+#  endif
+}
+#else
+#  define SWIG_croak_null() croak(Nullch)
+#endif
+
+
+/* 
+   Define how strict is the cast between strings and integers/doubles
+   when overloading between these types occurs.
+   
+   The default is making it as strict as possible by using SWIG_AddCast
+   when needed.
+   
+   You can use -DSWIG_PERL_NO_STRICT_STR2NUM at compilation time to
+   disable the SWIG_AddCast, making the casting between string and
+   numbers less strict.
+
+   In the end, we try to solve the overloading between strings and
+   numerical types in the more natural way, but if you can avoid it,
+   well, avoid it using %rename, for example.
+*/
+#ifndef SWIG_PERL_NO_STRICT_STR2NUM
+# ifndef SWIG_PERL_STRICT_STR2NUM
+#  define SWIG_PERL_STRICT_STR2NUM
+# endif
+#endif
+#ifdef SWIG_PERL_STRICT_STR2NUM
+/* string takes precedence */
+#define SWIG_Str2NumCast(x) SWIG_AddCast(x)  
+#else
+/* number takes precedence */
+#define SWIG_Str2NumCast(x) x
+#endif
+
+
+
+#include <stdlib.h>
+
+SWIGRUNTIME const char *
+SWIG_Perl_TypeProxyName(const swig_type_info *type) {
+  if (!type) return NULL;
+  if (type->clientdata != NULL) {
+    return (const char*) type->clientdata;
+  } 
+  else {
+    return type->name;
+  }
+}
+
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeProxyCheck(const char *c, swig_type_info *ty) {
+  SWIG_TypeCheck_Template(( (!iter->type->clientdata && (strcmp(iter->type->name, c) == 0)) 
+			    || (iter->type->clientdata && (strcmp((char*)iter->type->clientdata, c) == 0))), ty);
+}
+
+
+/* Function for getting a pointer value */
+
+SWIGRUNTIME int
+SWIG_Perl_ConvertPtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void **ptr, swig_type_info *_t, int flags) {
+  swig_cast_info *tc;
+  void *voidptr = (void *)0;
+  SV *tsv = 0;
+  /* If magical, apply more magic */
+  if (SvGMAGICAL(sv))
+    mg_get(sv);
+
+  /* Check to see if this is an object */
+  if (sv_isobject(sv)) {
+    IV tmp = 0;
+    tsv = (SV*) SvRV(sv);
+    if ((SvTYPE(tsv) == SVt_PVHV)) {
+      MAGIC *mg;
+      if (SvMAGICAL(tsv)) {
+        mg = mg_find(tsv,'P');
+        if (mg) {
+          sv = mg->mg_obj;
+          if (sv_isobject(sv)) {
+	    tsv = (SV*)SvRV(sv);
+            tmp = SvIV(tsv);
+          }
+        }
+      } else {
+        return SWIG_ERROR;
+      }
+    } else {
+      tmp = SvIV(tsv);
+    }
+    voidptr = INT2PTR(void *,tmp);
+  } else if (! SvOK(sv)) {            /* Check for undef */
+    *(ptr) = (void *) 0;
+    return SWIG_OK;
+  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
+    if (!SvROK(sv)) {
+      *(ptr) = (void *) 0;
+      return SWIG_OK;
+    } else {
+      return SWIG_ERROR;
+    }
+  } else {                            /* Don't know what it is */
+    return SWIG_ERROR;
+  }
+  if (_t) {
+    /* Now see if the types match */
+    char *_c = HvNAME(SvSTASH(SvRV(sv)));
+    tc = SWIG_TypeProxyCheck(_c,_t);
+    if (!tc) {
+      return SWIG_ERROR;
+    }
+    {
+      int newmemory = 0;
+      *ptr = SWIG_TypeCast(tc,voidptr,&newmemory);
+      assert(!newmemory); /* newmemory handling not yet implemented */
+    }
+  } else {
+    *ptr = voidptr;
+  }
+
+  /* 
+   *  DISOWN implementation: we need a perl guru to check this one.
+   */
+  if (tsv && (flags & SWIG_POINTER_DISOWN)) {
+    /* 
+     *  almost copy paste code from below SWIG_POINTER_OWN setting
+     */
+    SV *obj = sv;
+    HV *stash = SvSTASH(SvRV(obj));
+    GV *gv = *(GV**) hv_fetch(stash, "OWNER", 5, TRUE);
+    if (isGV(gv)) {
+      HV *hv = GvHVn(gv);
+      /*
+       * To set ownership (see below), a newSViv(1) entry is added. 
+       * Hence, to remove ownership, we delete the entry.
+       */
+      if (hv_exists_ent(hv, obj, 0)) {
+	hv_delete_ent(hv, obj, 0, 0);
+      }
+    }
+  }
+  return SWIG_OK;
+}
+
+SWIGRUNTIME void
+SWIG_Perl_MakePtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, swig_type_info *t, int flags) {
+  if (ptr && (flags & SWIG_SHADOW)) {
+    SV *self;
+    SV *obj=newSV(0);
+    HV *hash=newHV();
+    HV *stash;
+    sv_setref_pv(obj, (char *) SWIG_Perl_TypeProxyName(t), ptr);
+    stash=SvSTASH(SvRV(obj));
+    if (flags & SWIG_POINTER_OWN) {
+      HV *hv;
+      GV *gv=*(GV**)hv_fetch(stash, "OWNER", 5, TRUE);
+      if (!isGV(gv))
+        gv_init(gv, stash, "OWNER", 5, FALSE);
+      hv=GvHVn(gv);
+      hv_store_ent(hv, obj, newSViv(1), 0);
+    }
+    sv_magic((SV *)hash, (SV *)obj, 'P', Nullch, 0);
+    SvREFCNT_dec(obj);
+    self=newRV_noinc((SV *)hash);
+    sv_setsv(sv, self);
+    SvREFCNT_dec((SV *)self);
+    sv_bless(sv, stash);
+  }
+  else {
+    sv_setref_pv(sv, (char *) SWIG_Perl_TypeProxyName(t), ptr);
+  }
+}
+
+SWIGRUNTIMEINLINE SV *
+SWIG_Perl_NewPointerObj(SWIG_MAYBE_PERL_OBJECT void *ptr, swig_type_info *t, int flags) {
+  SV *result = sv_newmortal();
+  SWIG_MakePtr(result, ptr, t, flags);
+  return result;
+}
+
+SWIGRUNTIME void
+SWIG_Perl_MakePackedObj(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, int sz, swig_type_info *type) {
+  char result[1024];
+  char *r = result;
+  if ((2*sz + 1 + strlen(SWIG_Perl_TypeProxyName(type))) > 1000) return;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  strcpy(r,SWIG_Perl_TypeProxyName(type));
+  sv_setpv(sv, result);
+}
+
+SWIGRUNTIME SV *
+SWIG_Perl_NewPackedObj(SWIG_MAYBE_PERL_OBJECT void *ptr, int sz, swig_type_info *type) {
+  SV *result = sv_newmortal();
+  SWIG_Perl_MakePackedObj(result, ptr, sz, type);
+  return result;
+}
+
+/* Convert a packed value value */
+SWIGRUNTIME int
+SWIG_Perl_ConvertPacked(SWIG_MAYBE_PERL_OBJECT SV *obj, void *ptr, int sz, swig_type_info *ty) {
+  swig_cast_info *tc;
+  const char  *c = 0;
+
+  if ((!obj) || (!SvOK(obj))) return SWIG_ERROR;
+  c = SvPV_nolen(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') return SWIG_ERROR;
+  c++;
+  c = SWIG_UnpackData(c,ptr,sz);
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) return SWIG_ERROR;
+  }
+  return SWIG_OK;
+}
+
+
+/* Macros for low-level exception handling */
+#define SWIG_croak(x)    { SWIG_Error(SWIG_RuntimeError, x); SWIG_fail; }
+
+
+typedef XSPROTO(SwigPerlWrapper);
+typedef SwigPerlWrapper *SwigPerlWrapperPtr;
+
+/* Structure for command table */
+typedef struct {
+  const char         *name;
+  SwigPerlWrapperPtr  wrapper;
+} swig_command_info;
+
+/* Information for constant table */
+
+#define SWIG_INT     1
+#define SWIG_FLOAT   2
+#define SWIG_STRING  3
+#define SWIG_POINTER 4
+#define SWIG_BINARY  5
+
+/* Constant information structure */
+typedef struct swig_constant_info {
+    int              type;
+    const char      *name;
+    long             lvalue;
+    double           dvalue;
+    void            *pvalue;
+    swig_type_info **ptype;
+} swig_constant_info;
+
+
+/* Structure for variable table */
+typedef struct {
+  const char   *name;
+  SwigMagicFunc   set;
+  SwigMagicFunc   get;
+  swig_type_info  **type;
+} swig_variable_info;
+
+/* Magic variable code */
+#ifndef PERL_OBJECT
+#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
+  #ifndef MULTIPLICITY
+     SWIGRUNTIME void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) 
+  #else
+     SWIGRUNTIME void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*, SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) 
+  #endif
+#else
+#  define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
+SWIGRUNTIME void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) 
+#endif
+{
+  MAGIC *mg;
+  sv_magic(sv,sv,'U',(char *) name,strlen(name));
+  mg = mg_find(sv,'U');
+  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
+  mg->mg_virtual->svt_get = (SwigMagicFunc) get;
+  mg->mg_virtual->svt_set = (SwigMagicFunc) set;
+  mg->mg_virtual->svt_len = 0;
+  mg->mg_virtual->svt_clear = 0;
+  mg->mg_virtual->svt_free = 0;
+}
+
+
+SWIGRUNTIME swig_module_info *
+SWIG_Perl_GetModule(void) {
+  static void *type_pointer = (void *)0;
+  SV *pointer;
+
+  /* first check if pointer already created */
+  if (!type_pointer) {
+    pointer = get_sv("swig_runtime_data::type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, FALSE | GV_ADDMULTI);
+    if (pointer && SvOK(pointer)) {
+      type_pointer = INT2PTR(swig_type_info **, SvIV(pointer));
+    }
+  }
+
+  return (swig_module_info *) type_pointer;
+}
+
+SWIGRUNTIME void
+SWIG_Perl_SetModule(swig_module_info *module) {
+  SV *pointer;
+
+  /* create a new pointer */
+  pointer = get_sv("swig_runtime_data::type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TRUE | GV_ADDMULTI);
+  sv_setiv(pointer, PTR2IV(module));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Workaround perl5 global namespace pollution. Note that undefining library
+ * functions like fopen will not solve the problem on all platforms as fopen
+ * might be a macro on Windows but not necessarily on other operating systems. */
+#ifdef do_open
+  #undef do_open
+#endif
+#ifdef do_close
+  #undef do_close
+#endif
+#ifdef scalar
+  #undef scalar
+#endif
+#ifdef list
+  #undef list
+#endif
+#ifdef apply
+  #undef apply
+#endif
+#ifdef convert
+  #undef convert
+#endif
+#ifdef Error
+  #undef Error
+#endif
+#ifdef form
+  #undef form
+#endif
+#ifdef vform
+  #undef vform
+#endif
+#ifdef LABEL
+  #undef LABEL
+#endif
+#ifdef METHOD
+  #undef METHOD
+#endif
+#ifdef Move
+  #undef Move
+#endif
+#ifdef yylex
+  #undef yylex
+#endif
+#ifdef yyparse
+  #undef yyparse
+#endif
+#ifdef yyerror
+  #undef yyerror
+#endif
+#ifdef invert
+  #undef invert
+#endif
+#ifdef ref
+  #undef ref
+#endif
+#ifdef read
+  #undef read
+#endif
+#ifdef write
+  #undef write
+#endif
+#ifdef eof
+  #undef eof
+#endif
+#ifdef bool
+  #undef bool
+#endif
+#ifdef close
+  #undef close
+#endif
+#ifdef rewind
+  #undef rewind
+#endif
+#ifdef free
+  #undef free
+#endif
+#ifdef malloc
+  #undef malloc
+#endif
+#ifdef calloc
+  #undef calloc
+#endif
+#ifdef Stat
+  #undef Stat
+#endif
+#ifdef check
+  #undef check
+#endif
+#ifdef seekdir
+  #undef seekdir
+#endif
+#ifdef open
+  #undef open
+#endif
+
+
+
+#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define SWIGTYPE_p___FILE swig_types[0]
+#define SWIGTYPE_p_char swig_types[1]
+#define SWIGTYPE_p_int swig_types[2]
+#define SWIGTYPE_p_kv_s swig_types[3]
+#define SWIGTYPE_p_kva_s swig_types[4]
+#define SWIGTYPE_p_p_char swig_types[5]
+#define SWIGTYPE_p_profattr_s swig_types[6]
+#define SWIGTYPE_p_profstr_s swig_types[7]
+#define SWIGTYPE_p_uid_t swig_types[8]
+#define SWIGTYPE_p_userattr_s swig_types[9]
+#define SWIGTYPE_p_userstr_s swig_types[10]
+static swig_type_info *swig_types[12];
+static swig_module_info swig_module = {swig_types, 11, 0, 0, 0, 0};
+#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+
+/* -------- TYPES TABLE (END) -------- */
+
+#define SWIG_init    boot_secdb
+
+#define SWIG_name   "secdbc::boot_secdb"
+#define SWIG_prefix "secdbc::"
+
+#define SWIGVERSION 0x010335 
+#define SWIG_VERSION SWIGVERSION
+
+
+#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
+#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
+
+
+#ifdef __cplusplus
+extern "C"
+#endif
+#ifndef PERL_OBJECT
+#ifndef MULTIPLICITY
+SWIGEXPORT void SWIG_init (CV* cv);
+#else
+SWIGEXPORT void SWIG_init (pTHXo_ CV* cv);
+#endif
+#else
+SWIGEXPORT void SWIG_init (CV *cv, CPerlObj *);
+#endif
+
+ 
+#include "prof_attr.h"
+#include "secdb.h"
+#include "user_attr.h"
+
+
+SWIGINTERNINLINE SV *
+SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+{
+  SV *obj = sv_newmortal();
+  if (carray) {
+    sv_setpvn(obj, carray, size);
+  } else {
+    sv_setsv(obj, &PL_sv_undef);
+  }
+  return obj;
+}
+
+
+SWIGINTERNINLINE SV * 
+SWIG_FromCharPtr(const char *cptr)
+{ 
+  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
+}
+
+
+SWIGINTERNINLINE SV *
+SWIG_From_long  SWIG_PERL_DECL_ARGS_1(long value)
+{    
+  SV *obj = sv_newmortal();
+  sv_setiv(obj, (IV) value);
+  return obj;
+}
+
+
+SWIGINTERNINLINE SV *
+SWIG_From_int  SWIG_PERL_DECL_ARGS_1(int value)
+{    
+  return SWIG_From_long  SWIG_PERL_CALL_ARGS_1(value);
+}
+
+
+SWIGINTERN swig_type_info*
+SWIG_pchar_descriptor(void)
+{
+  static int init = 0;
+  static swig_type_info* info = 0;
+  if (!init) {
+    info = SWIG_TypeQuery("_p_char");
+    init = 1;
+  }
+  return info;
+}
+
+
+SWIGINTERN int
+SWIG_AsCharPtrAndSize(SV *obj, char** cptr, size_t* psize, int *alloc)
+{
+  if (SvPOK(obj)) {
+    STRLEN len = 0;
+    char *cstr = SvPV(obj, len); 
+    size_t size = len + 1;
+    if (cptr)  {
+      if (alloc) {
+	if (*alloc == SWIG_NEWOBJ) {
+	  *cptr = (char *)memcpy((char *)malloc((size)*sizeof(char)), cstr, sizeof(char)*(size));
+	} else {
+	  *cptr = cstr;
+	  *alloc = SWIG_OLDOBJ;
+	}
+      }
+    }
+    if (psize) *psize = size;
+    return SWIG_OK;
+  } else {
+    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+    if (pchar_descriptor) {
+      char* vptr = 0; 
+      if (SWIG_ConvertPtr(obj, (void**)&vptr, pchar_descriptor, 0) == SWIG_OK) {
+	if (cptr) *cptr = vptr;
+	if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
+	if (alloc) *alloc = SWIG_OLDOBJ;
+	return SWIG_OK;
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+
+
+
+#include <limits.h>
+#if !defined(SWIG_NO_LLONG_MAX)
+# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+#   define LLONG_MAX __LONG_LONG_MAX__
+#   define LLONG_MIN (-LLONG_MAX - 1LL)
+#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+# endif
+#endif
+
+
+SWIGINTERN int
+SWIG_AsVal_double SWIG_PERL_DECL_ARGS_2(SV *obj, double *val)
+{
+  if (SvNIOK(obj)) {
+    if (val) *val = SvNV(obj);
+    return SWIG_OK;
+  } else if (SvIOK(obj)) {
+    if (val) *val = (double) SvIV(obj);
+    return SWIG_AddCast(SWIG_OK);
+  } else {
+    const char *nptr = SvPV_nolen(obj);
+    if (nptr) {
+      char *endptr;
+      double v = strtod(nptr, &endptr);
+      if (errno == ERANGE) {
+	errno = 0;
+	return SWIG_OverflowError;
+      } else {
+	if (*endptr == '\0') {
+	  if (val) *val = v;
+	  return SWIG_Str2NumCast(SWIG_OK);
+	}
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+#include <float.h>
+
+
+#include <math.h>
+
+
+SWIGINTERNINLINE int
+SWIG_CanCastAsInteger(double *d, double min, double max) {
+  double x = *d;
+  if ((min <= x && x <= max)) {
+   double fx = floor(x);
+   double cx = ceil(x);
+   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
+   if ((errno == EDOM) || (errno == ERANGE)) {
+     errno = 0;
+   } else {
+     double summ, reps, diff;
+     if (rd < x) {
+       diff = x - rd;
+     } else if (rd > x) {
+       diff = rd - x;
+     } else {
+       return 1;
+     }
+     summ = rd + x;
+     reps = diff/summ;
+     if (reps < 8*DBL_EPSILON) {
+       *d = rd;
+       return 1;
+     }
+   }
+  }
+  return 0;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_long SWIG_PERL_DECL_ARGS_2(SV *obj, long* val)
+{
+  if (SvIOK(obj)) {
+    if (val) *val = SvIV(obj);
+    return SWIG_OK;
+  } else {
+    int dispatch = 0;
+    const char *nptr = SvPV_nolen(obj);
+    if (nptr) {
+      char *endptr;
+      long v;
+      errno = 0;
+      v = strtol(nptr, &endptr,0);
+      if (errno == ERANGE) {
+	errno = 0;
+	return SWIG_OverflowError;
+      } else {
+	if (*endptr == '\0') {
+	  if (val) *val = v;
+	  return SWIG_Str2NumCast(SWIG_OK);
+	}
+      }
+    }
+    if (!dispatch) {
+      double d;
+      int res = SWIG_AddCast(SWIG_AsVal_double SWIG_PERL_CALL_ARGS_2(obj,&d));
+      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
+	if (val) *val = (long)(d);
+	return res;
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_int SWIG_PERL_DECL_ARGS_2(SV * obj, int *val)
+{
+  long v;
+  int res = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(obj, &v);
+  if (SWIG_IsOK(res)) {
+    if ((v < INT_MIN || v > INT_MAX)) {
+      return SWIG_OverflowError;
+    } else {
+      if (val) *val = (int)(v);
+    }
+  }  
+  return res;
+}
+
+
+SWIGINTERNINLINE SV *
+SWIG_From_char  SWIG_PERL_DECL_ARGS_1(char c) 
+{ 
+  return SWIG_FromCharPtrAndSize(&c,1);
+}
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef PERL_OBJECT
+#define MAGIC_CLASS _wrap_secdb_var::
+class _wrap_secdb_var : public CPerlObj {
+public:
+#else
+#define MAGIC_CLASS
+#endif
+SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *SWIGUNUSEDPARM(sv), MAGIC *SWIGUNUSEDPARM(mg)) {
+    MAGIC_PPERL
+    croak("Value is read-only.");
+    return 0;
+}
+
+
+#ifdef PERL_OBJECT
+};
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+XS(_wrap_profstr_t_name_set) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profstr_t_name_set(self,name);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_name_set" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profstr_t_name_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->name) free((char*)arg1->name);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->name = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->name = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_name_get) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profstr_t_name_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_name_get" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    result = (char *) ((arg1)->name);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_res1_set) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profstr_t_res1_set(self,res1);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_res1_set" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profstr_t_res1_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res1) free((char*)arg1->res1);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res1 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res1 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_res1_get) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profstr_t_res1_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_res1_get" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    result = (char *) ((arg1)->res1);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_res2_set) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profstr_t_res2_set(self,res2);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_res2_set" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profstr_t_res2_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res2) free((char*)arg1->res2);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res2 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res2 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_res2_get) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profstr_t_res2_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_res2_get" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    result = (char *) ((arg1)->res2);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_desc_set) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profstr_t_desc_set(self,desc);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_desc_set" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profstr_t_desc_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->desc) free((char*)arg1->desc);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->desc = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->desc = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_desc_get) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profstr_t_desc_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_desc_get" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    result = (char *) ((arg1)->desc);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_attr_set) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profstr_t_attr_set(self,attr);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_attr_set" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profstr_t_attr_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->attr) free((char*)arg1->attr);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->attr = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->attr = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profstr_t_attr_get) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profstr_t_attr_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profstr_t_attr_get" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    result = (char *) ((arg1)->attr);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_new_profstr_t) {
+  {
+    profstr_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: new_profstr_t();");
+    }
+    result = (profstr_t *)calloc(1, sizeof(profstr_t));
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_profstr_s, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_delete_profstr_t) {
+  {
+    profstr_t *arg1 = (profstr_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: delete_profstr_t(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profstr_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_profstr_t" "', argument " "1"" of type '" "profstr_t *""'"); 
+    }
+    arg1 = (profstr_t *)(argp1);
+    free((char *) arg1);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_name_set) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profattr_t_name_set(self,name);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_name_set" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profattr_t_name_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->name) free((char*)arg1->name);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->name = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->name = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_name_get) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profattr_t_name_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_name_get" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    result = (char *) ((arg1)->name);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_res1_set) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profattr_t_res1_set(self,res1);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_res1_set" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profattr_t_res1_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res1) free((char*)arg1->res1);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res1 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res1 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_res1_get) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profattr_t_res1_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_res1_get" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    result = (char *) ((arg1)->res1);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_res2_set) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profattr_t_res2_set(self,res2);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_res2_set" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profattr_t_res2_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res2) free((char*)arg1->res2);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res2 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res2 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_res2_get) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profattr_t_res2_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_res2_get" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    result = (char *) ((arg1)->res2);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_desc_set) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profattr_t_desc_set(self,desc);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_desc_set" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profattr_t_desc_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->desc) free((char*)arg1->desc);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->desc = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->desc = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_desc_get) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profattr_t_desc_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_desc_get" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    result = (char *) ((arg1)->desc);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_attr_set) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    kva_t *arg2 = (kva_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    void *argp2 = 0 ;
+    int res2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: profattr_t_attr_set(self,attr);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_attr_set" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_kva_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "profattr_t_attr_set" "', argument " "2"" of type '" "kva_t *""'"); 
+    }
+    arg2 = (kva_t *)(argp2);
+    if (arg1) (arg1)->attr = arg2;
+    
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_profattr_t_attr_get) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    kva_t *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: profattr_t_attr_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "profattr_t_attr_get" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    result = (kva_t *) ((arg1)->attr);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kva_s, 0 | SWIG_SHADOW); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_new_profattr_t) {
+  {
+    profattr_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: new_profattr_t();");
+    }
+    result = (profattr_t *)calloc(1, sizeof(profattr_t));
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_profattr_s, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_delete_profattr_t) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: delete_profattr_t(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_profattr_t" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    free((char *) arg1);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_getprofnam) {
+  {
+    char *arg1 = (char *) 0 ;
+    profattr_t *result = 0 ;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: getprofnam(char const *);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getprofnam" "', argument " "1"" of type '" "char const *""'");
+    }
+    arg1 = (char *)(buf1);
+    result = (profattr_t *)getprofnam((char const *)arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_profattr_s, 0 | SWIG_SHADOW); argvi++ ;
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_getprofattr) {
+  {
+    profattr_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: getprofattr();");
+    }
+    result = (profattr_t *)getprofattr();
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_profattr_s, 0 | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_getproflist) {
+  {
+    char *arg1 = (char *) 0 ;
+    char **arg2 = (char **) 0 ;
+    int *arg3 = (int *) 0 ;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    void *argp2 = 0 ;
+    int res2 = 0 ;
+    void *argp3 = 0 ;
+    int res3 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 3) || (items > 3)) {
+      SWIG_croak("Usage: getproflist(char const *,char **,int *);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getproflist" "', argument " "1"" of type '" "char const *""'");
+    }
+    arg1 = (char *)(buf1);
+    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_p_char, 0 |  0 );
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "getproflist" "', argument " "2"" of type '" "char **""'"); 
+    }
+    arg2 = (char **)(argp2);
+    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_int, 0 |  0 );
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "getproflist" "', argument " "3"" of type '" "int *""'"); 
+    }
+    arg3 = (int *)(argp3);
+    getproflist((char const *)arg1,arg2,arg3);
+    
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    
+    
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_setprofattr) {
+  {
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: setprofattr();");
+    }
+    setprofattr();
+    
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_endprofattr) {
+  {
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: endprofattr();");
+    }
+    endprofattr();
+    
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_free_profattr) {
+  {
+    profattr_t *arg1 = (profattr_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: free_profattr(profattr_t *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_profattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "free_profattr" "', argument " "1"" of type '" "profattr_t *""'"); 
+    }
+    arg1 = (profattr_t *)(argp1);
+    free_profattr(arg1);
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_free_proflist) {
+  {
+    char **arg1 = (char **) 0 ;
+    int arg2 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int val2 ;
+    int ecode2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: free_proflist(char **,int);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_p_char, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "free_proflist" "', argument " "1"" of type '" "char **""'"); 
+    }
+    arg1 = (char **)(argp1);
+    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
+    if (!SWIG_IsOK(ecode2)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "free_proflist" "', argument " "2"" of type '" "int""'");
+    } 
+    arg2 = (int)(val2);
+    free_proflist(arg1,arg2);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_name_set) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userstr_t_name_set(self,name);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_name_set" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userstr_t_name_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->name) free((char*)arg1->name);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->name = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->name = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_name_get) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userstr_t_name_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_name_get" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    result = (char *) ((arg1)->name);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_qualifier_set) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userstr_t_qualifier_set(self,qualifier);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_qualifier_set" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userstr_t_qualifier_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->qualifier) free((char*)arg1->qualifier);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->qualifier = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->qualifier = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_qualifier_get) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userstr_t_qualifier_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_qualifier_get" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    result = (char *) ((arg1)->qualifier);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_res1_set) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userstr_t_res1_set(self,res1);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_res1_set" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userstr_t_res1_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res1) free((char*)arg1->res1);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res1 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res1 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_res1_get) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userstr_t_res1_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_res1_get" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    result = (char *) ((arg1)->res1);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_res2_set) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userstr_t_res2_set(self,res2);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_res2_set" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userstr_t_res2_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res2) free((char*)arg1->res2);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res2 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res2 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_res2_get) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userstr_t_res2_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_res2_get" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    result = (char *) ((arg1)->res2);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_attr_set) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userstr_t_attr_set(self,attr);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_attr_set" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userstr_t_attr_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->attr) free((char*)arg1->attr);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->attr = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->attr = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userstr_t_attr_get) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userstr_t_attr_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userstr_t_attr_get" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    result = (char *) ((arg1)->attr);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_new_userstr_t) {
+  {
+    userstr_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: new_userstr_t();");
+    }
+    result = (userstr_t *)calloc(1, sizeof(userstr_t));
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_userstr_s, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_delete_userstr_t) {
+  {
+    userstr_t *arg1 = (userstr_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: delete_userstr_t(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userstr_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_userstr_t" "', argument " "1"" of type '" "userstr_t *""'"); 
+    }
+    arg1 = (userstr_t *)(argp1);
+    free((char *) arg1);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_name_set) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userattr_t_name_set(self,name);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_name_set" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userattr_t_name_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->name) free((char*)arg1->name);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->name = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->name = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_name_get) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userattr_t_name_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_name_get" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    result = (char *) ((arg1)->name);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_qualifier_set) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userattr_t_qualifier_set(self,qualifier);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_qualifier_set" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userattr_t_qualifier_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->qualifier) free((char*)arg1->qualifier);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->qualifier = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->qualifier = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_qualifier_get) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userattr_t_qualifier_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_qualifier_get" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    result = (char *) ((arg1)->qualifier);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_res1_set) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userattr_t_res1_set(self,res1);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_res1_set" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userattr_t_res1_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res1) free((char*)arg1->res1);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res1 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res1 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_res1_get) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userattr_t_res1_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_res1_get" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    result = (char *) ((arg1)->res1);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_res2_set) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userattr_t_res2_set(self,res2);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_res2_set" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userattr_t_res2_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->res2) free((char*)arg1->res2);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->res2 = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->res2 = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_res2_get) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userattr_t_res2_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_res2_get" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    result = (char *) ((arg1)->res2);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_attr_set) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    kva_t *arg2 = (kva_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    void *argp2 = 0 ;
+    int res2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: userattr_t_attr_set(self,attr);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_attr_set" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_kva_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "userattr_t_attr_set" "', argument " "2"" of type '" "kva_t *""'"); 
+    }
+    arg2 = (kva_t *)(argp2);
+    if (arg1) (arg1)->attr = arg2;
+    
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_userattr_t_attr_get) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    kva_t *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: userattr_t_attr_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "userattr_t_attr_get" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    result = (kva_t *) ((arg1)->attr);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kva_s, 0 | SWIG_SHADOW); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_new_userattr_t) {
+  {
+    userattr_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: new_userattr_t();");
+    }
+    result = (userattr_t *)calloc(1, sizeof(userattr_t));
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_userattr_s, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_delete_userattr_t) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: delete_userattr_t(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_userattr_t" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    free((char *) arg1);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_getusernam) {
+  {
+    char *arg1 = (char *) 0 ;
+    userattr_t *result = 0 ;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: getusernam(char const *);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getusernam" "', argument " "1"" of type '" "char const *""'");
+    }
+    arg1 = (char *)(buf1);
+    result = (userattr_t *)getusernam((char const *)arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_userattr_s, 0 | SWIG_SHADOW); argvi++ ;
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_getuseruid) {
+  {
+    uid_t arg1 ;
+    userattr_t *result = 0 ;
+    void *argp1 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: getuseruid(uid);");
+    }
+    {
+      res1 = SWIG_ConvertPtr(ST(0), &argp1, SWIGTYPE_p_uid_t,  0 );
+      if (!SWIG_IsOK(res1)) {
+        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getuseruid" "', argument " "1"" of type '" "uid_t""'"); 
+      }  
+      if (!argp1) {
+        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "getuseruid" "', argument " "1"" of type '" "uid_t""'");
+      } else {
+        arg1 = *((uid_t *)(argp1));
+      }
+    }
+    result = (userattr_t *)getuseruid(arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_userattr_s, 0 | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_getuserattr) {
+  {
+    userattr_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: getuserattr();");
+    }
+    result = (userattr_t *)getuserattr();
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_userattr_s, 0 | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_fgetuserattr) {
+  {
+    struct __FILE *arg1 = (struct __FILE *) 0 ;
+    userattr_t *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: fgetuserattr(struct __FILE *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p___FILE, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fgetuserattr" "', argument " "1"" of type '" "struct __FILE *""'"); 
+    }
+    arg1 = (struct __FILE *)(argp1);
+    result = (userattr_t *)fgetuserattr(arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_userattr_s, 0 | SWIG_SHADOW); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_setuserattr) {
+  {
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: setuserattr();");
+    }
+    setuserattr();
+    
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_enduserattr) {
+  {
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: enduserattr();");
+    }
+    enduserattr();
+    
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_free_userattr) {
+  {
+    userattr_t *arg1 = (userattr_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: free_userattr(userattr_t *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_userattr_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "free_userattr" "', argument " "1"" of type '" "userattr_t *""'"); 
+    }
+    arg1 = (userattr_t *)(argp1);
+    free_userattr(arg1);
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kv_t_key_set) {
+  {
+    kv_t *arg1 = (kv_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: kv_t_key_set(self,key);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kv_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kv_t_key_set" "', argument " "1"" of type '" "kv_t *""'"); 
+    }
+    arg1 = (kv_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "kv_t_key_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->key) free((char*)arg1->key);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->key = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->key = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kv_t_key_get) {
+  {
+    kv_t *arg1 = (kv_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: kv_t_key_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kv_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kv_t_key_get" "', argument " "1"" of type '" "kv_t *""'"); 
+    }
+    arg1 = (kv_t *)(argp1);
+    result = (char *) ((arg1)->key);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kv_t_value_set) {
+  {
+    kv_t *arg1 = (kv_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: kv_t_value_set(self,value);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kv_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kv_t_value_set" "', argument " "1"" of type '" "kv_t *""'"); 
+    }
+    arg1 = (kv_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "kv_t_value_set" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    if (arg1->value) free((char*)arg1->value);
+    if (arg2) {
+      size_t size = strlen((const char *)(arg2)) + 1;
+      arg1->value = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+    } else {
+      arg1->value = 0;
+    }
+    
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kv_t_value_get) {
+  {
+    kv_t *arg1 = (kv_t *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: kv_t_value_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kv_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kv_t_value_get" "', argument " "1"" of type '" "kv_t *""'"); 
+    }
+    arg1 = (kv_t *)(argp1);
+    result = (char *) ((arg1)->value);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_new_kv_t) {
+  {
+    kv_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: new_kv_t();");
+    }
+    result = (kv_t *)calloc(1, sizeof(kv_t));
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kv_s, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_delete_kv_t) {
+  {
+    kv_t *arg1 = (kv_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: delete_kv_t(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kv_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_kv_t" "', argument " "1"" of type '" "kv_t *""'"); 
+    }
+    arg1 = (kv_t *)(argp1);
+    free((char *) arg1);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kva_t_length_set) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    int arg2 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int val2 ;
+    int ecode2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: kva_t_length_set(self,length);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kva_t_length_set" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
+    if (!SWIG_IsOK(ecode2)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "kva_t_length_set" "', argument " "2"" of type '" "int""'");
+    } 
+    arg2 = (int)(val2);
+    if (arg1) (arg1)->length = arg2;
+    
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kva_t_length_get) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    int result;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: kva_t_length_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kva_t_length_get" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    result = (int) ((arg1)->length);
+    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kva_t_data_set) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    kv_t *arg2 = (kv_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    void *argp2 = 0 ;
+    int res2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: kva_t_data_set(self,data);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kva_t_data_set" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_kv_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "kva_t_data_set" "', argument " "2"" of type '" "kv_t *""'"); 
+    }
+    arg2 = (kv_t *)(argp2);
+    if (arg1) (arg1)->data = arg2;
+    
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kva_t_data_get) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    kv_t *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: kva_t_data_get(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kva_t_data_get" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    result = (kv_t *) ((arg1)->data);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kv_s, 0 | SWIG_SHADOW); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_new_kva_t) {
+  {
+    kva_t *result = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 0) || (items > 0)) {
+      SWIG_croak("Usage: new_kva_t();");
+    }
+    result = (kva_t *)calloc(1, sizeof(kva_t));
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kva_s, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
+    XSRETURN(argvi);
+  fail:
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_delete_kva_t) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: delete_kva_t(self);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, SWIG_POINTER_DISOWN |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_kva_t" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    free((char *) arg1);
+    
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap_kva_match) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: kva_match(kva_t *,char *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kva_match" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "kva_match" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    result = (char *)kva_match(arg1,arg2);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__auth_match) {
+  {
+    char *arg1 = (char *) 0 ;
+    char *arg2 = (char *) 0 ;
+    int result;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 2) || (items > 2)) {
+      SWIG_croak("Usage: _auth_match(char const *,char const *);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_auth_match" "', argument " "1"" of type '" "char const *""'");
+    }
+    arg1 = (char *)(buf1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_auth_match" "', argument " "2"" of type '" "char const *""'");
+    }
+    arg2 = (char *)(buf2);
+    result = (int)_auth_match((char const *)arg1,(char const *)arg2);
+    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__argv_to_csl) {
+  {
+    char **arg1 = (char **) 0 ;
+    char *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _argv_to_csl(strings);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_p_char, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_argv_to_csl" "', argument " "1"" of type '" "char **""'"); 
+    }
+    arg1 = (char **)(argp1);
+    result = (char *)_argv_to_csl(arg1);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__csl_to_argv) {
+  {
+    char *arg1 = (char *) 0 ;
+    char **result = 0 ;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _csl_to_argv(csl);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_csl_to_argv" "', argument " "1"" of type '" "char *""'");
+    }
+    arg1 = (char *)(buf1);
+    result = (char **)_csl_to_argv(arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_char, 0 | 0); argvi++ ;
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__do_unescape) {
+  {
+    char *arg1 = (char *) 0 ;
+    char *result = 0 ;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _do_unescape(src);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_do_unescape" "', argument " "1"" of type '" "char *""'");
+    }
+    arg1 = (char *)(buf1);
+    result = (char *)_do_unescape(arg1);
+    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__free_argv) {
+  {
+    char **arg1 = (char **) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _free_argv(p_argv);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_p_char, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_free_argv" "', argument " "1"" of type '" "char **""'"); 
+    }
+    arg1 = (char **)(argp1);
+    _free_argv(arg1);
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__insert2kva) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    char *arg3 = (char *) 0 ;
+    int result;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int res3 ;
+    char *buf3 = 0 ;
+    int alloc3 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 3) || (items > 3)) {
+      SWIG_croak("Usage: _insert2kva(kva_t *,char *,char *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_insert2kva" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_insert2kva" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "_insert2kva" "', argument " "3"" of type '" "char *""'");
+    }
+    arg3 = (char *)(buf3);
+    result = (int)_insert2kva(arg1,arg2,arg3);
+    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__kva2str) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    char *arg2 = (char *) 0 ;
+    int arg3 ;
+    char *arg4 = (char *) 0 ;
+    char *arg5 = (char *) 0 ;
+    int result;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int val3 ;
+    int ecode3 = 0 ;
+    int res4 ;
+    char *buf4 = 0 ;
+    int alloc4 = 0 ;
+    int res5 ;
+    char *buf5 = 0 ;
+    int alloc5 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 5) || (items > 5)) {
+      SWIG_croak("Usage: _kva2str(kva_t *,char *,int,char *,char *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_kva2str" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_kva2str" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
+    if (!SWIG_IsOK(ecode3)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "_kva2str" "', argument " "3"" of type '" "int""'");
+    } 
+    arg3 = (int)(val3);
+    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "_kva2str" "', argument " "4"" of type '" "char *""'");
+    }
+    arg4 = (char *)(buf4);
+    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "_kva2str" "', argument " "5"" of type '" "char *""'");
+    }
+    arg5 = (char *)(buf5);
+    result = (int)_kva2str(arg1,arg2,arg3,arg4,arg5);
+    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    
+    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
+    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
+    XSRETURN(argvi);
+  fail:
+    
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    
+    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
+    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__kva_dup) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    kva_t *result = 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _kva_dup(kva_t *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_kva_dup" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    result = (kva_t *)_kva_dup(arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kva_s, 0 | SWIG_SHADOW); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__kva_free) {
+  {
+    kva_t *arg1 = (kva_t *) 0 ;
+    void *argp1 = 0 ;
+    int res1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _kva_free(kva_t *);");
+    }
+    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_kva_s, 0 |  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_kva_free" "', argument " "1"" of type '" "kva_t *""'"); 
+    }
+    arg1 = (kva_t *)(argp1);
+    _kva_free(arg1);
+    
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__new_kva) {
+  {
+    int arg1 ;
+    kva_t *result = 0 ;
+    int val1 ;
+    int ecode1 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 1) || (items > 1)) {
+      SWIG_croak("Usage: _new_kva(size);");
+    }
+    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
+    if (!SWIG_IsOK(ecode1)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "_new_kva" "', argument " "1"" of type '" "int""'");
+    } 
+    arg1 = (int)(val1);
+    result = (kva_t *)_new_kva(arg1);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kva_s, 0 | SWIG_SHADOW); argvi++ ;
+    
+    XSRETURN(argvi);
+  fail:
+    
+    SWIG_croak_null();
+  }
+}
+
+
+XS(_wrap__str2kva) {
+  {
+    char *arg1 = (char *) 0 ;
+    char *arg2 = (char *) 0 ;
+    char *arg3 = (char *) 0 ;
+    kva_t *result = 0 ;
+    int res1 ;
+    char *buf1 = 0 ;
+    int alloc1 = 0 ;
+    int res2 ;
+    char *buf2 = 0 ;
+    int alloc2 = 0 ;
+    int res3 ;
+    char *buf3 = 0 ;
+    int alloc3 = 0 ;
+    int argvi = 0;
+    dXSARGS;
+    
+    if ((items < 3) || (items > 3)) {
+      SWIG_croak("Usage: _str2kva(char *,char *,char *);");
+    }
+    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_str2kva" "', argument " "1"" of type '" "char *""'");
+    }
+    arg1 = (char *)(buf1);
+    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_str2kva" "', argument " "2"" of type '" "char *""'");
+    }
+    arg2 = (char *)(buf2);
+    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "_str2kva" "', argument " "3"" of type '" "char *""'");
+    }
+    arg3 = (char *)(buf3);
+    result = (kva_t *)_str2kva(arg1,arg2,arg3);
+    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_kva_s, 0 | SWIG_SHADOW); argvi++ ;
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+    XSRETURN(argvi);
+  fail:
+    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+    SWIG_croak_null();
+  }
+}
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static swig_type_info _swigt__p___FILE = {"_p___FILE", "struct __FILE *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_kv_s = {"_p_kv_s", "struct kv_s *|kv_t *", 0, 0, (void*)"secdb::kv_t", 0};
+static swig_type_info _swigt__p_kva_s = {"_p_kva_s", "struct kva_s *|kva_t *", 0, 0, (void*)"secdb::kva_t", 0};
+static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_profattr_s = {"_p_profattr_s", "profattr_t *|struct profattr_s *", 0, 0, (void*)"secdb::profattr_t", 0};
+static swig_type_info _swigt__p_profstr_s = {"_p_profstr_s", "struct profstr_s *|profstr_t *", 0, 0, (void*)"secdb::profstr_t", 0};
+static swig_type_info _swigt__p_uid_t = {"_p_uid_t", "uid_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_userattr_s = {"_p_userattr_s", "userattr_t *|struct userattr_s *", 0, 0, (void*)"secdb::userattr_t", 0};
+static swig_type_info _swigt__p_userstr_s = {"_p_userstr_s", "struct userstr_s *|userstr_t *", 0, 0, (void*)"secdb::userstr_t", 0};
+
+static swig_type_info *swig_type_initial[] = {
+  &_swigt__p___FILE,
+  &_swigt__p_char,
+  &_swigt__p_int,
+  &_swigt__p_kv_s,
+  &_swigt__p_kva_s,
+  &_swigt__p_p_char,
+  &_swigt__p_profattr_s,
+  &_swigt__p_profstr_s,
+  &_swigt__p_uid_t,
+  &_swigt__p_userattr_s,
+  &_swigt__p_userstr_s,
+};
+
+static swig_cast_info _swigc__p___FILE[] = {  {&_swigt__p___FILE, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_kv_s[] = {  {&_swigt__p_kv_s, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_kva_s[] = {  {&_swigt__p_kva_s, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_profattr_s[] = {  {&_swigt__p_profattr_s, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_profstr_s[] = {  {&_swigt__p_profstr_s, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_uid_t[] = {  {&_swigt__p_uid_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_userattr_s[] = {  {&_swigt__p_userattr_s, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_userstr_s[] = {  {&_swigt__p_userstr_s, 0, 0, 0},{0, 0, 0, 0}};
+
+static swig_cast_info *swig_cast_initial[] = {
+  _swigc__p___FILE,
+  _swigc__p_char,
+  _swigc__p_int,
+  _swigc__p_kv_s,
+  _swigc__p_kva_s,
+  _swigc__p_p_char,
+  _swigc__p_profattr_s,
+  _swigc__p_profstr_s,
+  _swigc__p_uid_t,
+  _swigc__p_userattr_s,
+  _swigc__p_userstr_s,
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_constant_info swig_constants[] = {
+{0,0,0,0,0,0}
+};
+#ifdef __cplusplus
+}
+#endif
+static swig_variable_info swig_variables[] = {
+{0,0,0,0}
+};
+static swig_command_info swig_commands[] = {
+{"secdbc::profstr_t_name_set", _wrap_profstr_t_name_set},
+{"secdbc::profstr_t_name_get", _wrap_profstr_t_name_get},
+{"secdbc::profstr_t_res1_set", _wrap_profstr_t_res1_set},
+{"secdbc::profstr_t_res1_get", _wrap_profstr_t_res1_get},
+{"secdbc::profstr_t_res2_set", _wrap_profstr_t_res2_set},
+{"secdbc::profstr_t_res2_get", _wrap_profstr_t_res2_get},
+{"secdbc::profstr_t_desc_set", _wrap_profstr_t_desc_set},
+{"secdbc::profstr_t_desc_get", _wrap_profstr_t_desc_get},
+{"secdbc::profstr_t_attr_set", _wrap_profstr_t_attr_set},
+{"secdbc::profstr_t_attr_get", _wrap_profstr_t_attr_get},
+{"secdbc::new_profstr_t", _wrap_new_profstr_t},
+{"secdbc::delete_profstr_t", _wrap_delete_profstr_t},
+{"secdbc::profattr_t_name_set", _wrap_profattr_t_name_set},
+{"secdbc::profattr_t_name_get", _wrap_profattr_t_name_get},
+{"secdbc::profattr_t_res1_set", _wrap_profattr_t_res1_set},
+{"secdbc::profattr_t_res1_get", _wrap_profattr_t_res1_get},
+{"secdbc::profattr_t_res2_set", _wrap_profattr_t_res2_set},
+{"secdbc::profattr_t_res2_get", _wrap_profattr_t_res2_get},
+{"secdbc::profattr_t_desc_set", _wrap_profattr_t_desc_set},
+{"secdbc::profattr_t_desc_get", _wrap_profattr_t_desc_get},
+{"secdbc::profattr_t_attr_set", _wrap_profattr_t_attr_set},
+{"secdbc::profattr_t_attr_get", _wrap_profattr_t_attr_get},
+{"secdbc::new_profattr_t", _wrap_new_profattr_t},
+{"secdbc::delete_profattr_t", _wrap_delete_profattr_t},
+{"secdbc::getprofnam", _wrap_getprofnam},
+{"secdbc::getprofattr", _wrap_getprofattr},
+{"secdbc::getproflist", _wrap_getproflist},
+{"secdbc::setprofattr", _wrap_setprofattr},
+{"secdbc::endprofattr", _wrap_endprofattr},
+{"secdbc::free_profattr", _wrap_free_profattr},
+{"secdbc::free_proflist", _wrap_free_proflist},
+{"secdbc::userstr_t_name_set", _wrap_userstr_t_name_set},
+{"secdbc::userstr_t_name_get", _wrap_userstr_t_name_get},
+{"secdbc::userstr_t_qualifier_set", _wrap_userstr_t_qualifier_set},
+{"secdbc::userstr_t_qualifier_get", _wrap_userstr_t_qualifier_get},
+{"secdbc::userstr_t_res1_set", _wrap_userstr_t_res1_set},
+{"secdbc::userstr_t_res1_get", _wrap_userstr_t_res1_get},
+{"secdbc::userstr_t_res2_set", _wrap_userstr_t_res2_set},
+{"secdbc::userstr_t_res2_get", _wrap_userstr_t_res2_get},
+{"secdbc::userstr_t_attr_set", _wrap_userstr_t_attr_set},
+{"secdbc::userstr_t_attr_get", _wrap_userstr_t_attr_get},
+{"secdbc::new_userstr_t", _wrap_new_userstr_t},
+{"secdbc::delete_userstr_t", _wrap_delete_userstr_t},
+{"secdbc::userattr_t_name_set", _wrap_userattr_t_name_set},
+{"secdbc::userattr_t_name_get", _wrap_userattr_t_name_get},
+{"secdbc::userattr_t_qualifier_set", _wrap_userattr_t_qualifier_set},
+{"secdbc::userattr_t_qualifier_get", _wrap_userattr_t_qualifier_get},
+{"secdbc::userattr_t_res1_set", _wrap_userattr_t_res1_set},
+{"secdbc::userattr_t_res1_get", _wrap_userattr_t_res1_get},
+{"secdbc::userattr_t_res2_set", _wrap_userattr_t_res2_set},
+{"secdbc::userattr_t_res2_get", _wrap_userattr_t_res2_get},
+{"secdbc::userattr_t_attr_set", _wrap_userattr_t_attr_set},
+{"secdbc::userattr_t_attr_get", _wrap_userattr_t_attr_get},
+{"secdbc::new_userattr_t", _wrap_new_userattr_t},
+{"secdbc::delete_userattr_t", _wrap_delete_userattr_t},
+{"secdbc::getusernam", _wrap_getusernam},
+{"secdbc::getuseruid", _wrap_getuseruid},
+{"secdbc::getuserattr", _wrap_getuserattr},
+{"secdbc::fgetuserattr", _wrap_fgetuserattr},
+{"secdbc::setuserattr", _wrap_setuserattr},
+{"secdbc::enduserattr", _wrap_enduserattr},
+{"secdbc::free_userattr", _wrap_free_userattr},
+{"secdbc::kv_t_key_set", _wrap_kv_t_key_set},
+{"secdbc::kv_t_key_get", _wrap_kv_t_key_get},
+{"secdbc::kv_t_value_set", _wrap_kv_t_value_set},
+{"secdbc::kv_t_value_get", _wrap_kv_t_value_get},
+{"secdbc::new_kv_t", _wrap_new_kv_t},
+{"secdbc::delete_kv_t", _wrap_delete_kv_t},
+{"secdbc::kva_t_length_set", _wrap_kva_t_length_set},
+{"secdbc::kva_t_length_get", _wrap_kva_t_length_get},
+{"secdbc::kva_t_data_set", _wrap_kva_t_data_set},
+{"secdbc::kva_t_data_get", _wrap_kva_t_data_get},
+{"secdbc::new_kva_t", _wrap_new_kva_t},
+{"secdbc::delete_kva_t", _wrap_delete_kva_t},
+{"secdbc::kva_match", _wrap_kva_match},
+{"secdbc::_auth_match", _wrap__auth_match},
+{"secdbc::_argv_to_csl", _wrap__argv_to_csl},
+{"secdbc::_csl_to_argv", _wrap__csl_to_argv},
+{"secdbc::_do_unescape", _wrap__do_unescape},
+{"secdbc::_free_argv", _wrap__free_argv},
+{"secdbc::_insert2kva", _wrap__insert2kva},
+{"secdbc::_kva2str", _wrap__kva2str},
+{"secdbc::_kva_dup", _wrap__kva_dup},
+{"secdbc::_kva_free", _wrap__kva_free},
+{"secdbc::_new_kva", _wrap__new_kva},
+{"secdbc::_str2kva", _wrap__str2kva},
+{0,0}
+};
+/* -----------------------------------------------------------------------------
+ * Type initialization:
+ * This problem is tough by the requirement that no dynamic 
+ * memory is used. Also, since swig_type_info structures store pointers to 
+ * swig_cast_info structures and swig_cast_info structures store pointers back
+ * to swig_type_info structures, we need some lookup code at initialization. 
+ * The idea is that swig generates all the structures that are needed. 
+ * The runtime then collects these partially filled structures. 
+ * The SWIG_InitializeModule function takes these initial arrays out of 
+ * swig_module, and does all the lookup, filling in the swig_module.types
+ * array with the correct data and linking the correct swig_cast_info
+ * structures together.
+ *
+ * The generated swig_type_info structures are assigned staticly to an initial 
+ * array. We just loop through that array, and handle each type individually.
+ * First we lookup if this type has been already loaded, and if so, use the
+ * loaded structure instead of the generated one. Then we have to fill in the
+ * cast linked list. The cast data is initially stored in something like a
+ * two-dimensional array. Each row corresponds to a type (there are the same
+ * number of rows as there are in the swig_type_initial array). Each entry in
+ * a column is one of the swig_cast_info structures for that type.
+ * The cast_initial array is actually an array of arrays, because each row has
+ * a variable number of columns. So to actually build the cast linked list,
+ * we find the array of casts associated with the type, and loop through it 
+ * adding the casts to the list. The one last trick we need to do is making
+ * sure the type pointer in the swig_cast_info struct is correct.
+ *
+ * First off, we lookup the cast->type name to see if it is already loaded. 
+ * There are three cases to handle:
+ *  1) If the cast->type has already been loaded AND the type we are adding
+ *     casting info to has not been loaded (it is in this module), THEN we
+ *     replace the cast->type pointer with the type pointer that has already
+ *     been loaded.
+ *  2) If BOTH types (the one we are adding casting info to, and the 
+ *     cast->type) are loaded, THEN the cast info has already been loaded by
+ *     the previous module so we just ignore it.
+ *  3) Finally, if cast->type has not already been loaded, then we add that
+ *     swig_cast_info to the linked list (because the cast->type) pointer will
+ *     be correct.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#if 0
+} /* c-mode */
+#endif
+#endif
+
+#if 0
+#define SWIGRUNTIME_DEBUG
+#endif
+
+
+SWIGRUNTIME void
+SWIG_InitializeModule(void *clientdata) {
+  size_t i;
+  swig_module_info *module_head, *iter;
+  int found, init;
+  
+  clientdata = clientdata;
+  
+  /* check to see if the circular list has been setup, if not, set it up */
+  if (swig_module.next==0) {
+    /* Initialize the swig_module */
+    swig_module.type_initial = swig_type_initial;
+    swig_module.cast_initial = swig_cast_initial;
+    swig_module.next = &swig_module;
+    init = 1;
+  } else {
+    init = 0;
+  }
+  
+  /* Try and load any already created modules */
+  module_head = SWIG_GetModule(clientdata);
+  if (!module_head) {
+    /* This is the first module loaded for this interpreter */
+    /* so set the swig module into the interpreter */
+    SWIG_SetModule(clientdata, &swig_module);
+    module_head = &swig_module;
+  } else {
+    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+    found=0;
+    iter=module_head;
+    do {
+      if (iter==&swig_module) {
+        found=1;
+        break;
+      }
+      iter=iter->next;
+    } while (iter!= module_head);
+    
+    /* if the is found in the list, then all is done and we may leave */
+    if (found) return;
+    /* otherwise we must add out module into the list */
+    swig_module.next = module_head->next;
+    module_head->next = &swig_module;
+  }
+  
+  /* When multiple interpeters are used, a module could have already been initialized in
+       a different interpreter, but not yet have a pointer in this interpreter.
+       In this case, we do not want to continue adding types... everything should be
+       set up already */
+  if (init == 0) return;
+  
+  /* Now work on filling in swig_module.types */
+#ifdef SWIGRUNTIME_DEBUG
+  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+#endif
+  for (i = 0; i < swig_module.size; ++i) {
+    swig_type_info *type = 0;
+    swig_type_info *ret;
+    swig_cast_info *cast;
+    
+#ifdef SWIGRUNTIME_DEBUG
+    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+#endif
+    
+    /* if there is another module already loaded */
+    if (swig_module.next != &swig_module) {
+      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+    }
+    if (type) {
+      /* Overwrite clientdata field */
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: found type %s\n", type->name);
+#endif
+      if (swig_module.type_initial[i]->clientdata) {
+        type->clientdata = swig_module.type_initial[i]->clientdata;
+#ifdef SWIGRUNTIME_DEBUG
+        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+#endif
+      }
+    } else {
+      type = swig_module.type_initial[i];
+    }
+    
+    /* Insert casting types */
+    cast = swig_module.cast_initial[i];
+    while (cast->type) {
+      /* Don't need to add information already in the list */
+      ret = 0;
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+#endif
+      if (swig_module.next != &swig_module) {
+        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+#ifdef SWIGRUNTIME_DEBUG
+        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+#endif
+      }
+      if (ret) {
+        if (type == swig_module.type_initial[i]) {
+#ifdef SWIGRUNTIME_DEBUG
+          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+#endif
+          cast->type = ret;
+          ret = 0;
+        } else {
+          /* Check for casting already in the list */
+          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+#ifdef SWIGRUNTIME_DEBUG
+          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+#endif
+          if (!ocast) ret = 0;
+        }
+      }
+      
+      if (!ret) {
+#ifdef SWIGRUNTIME_DEBUG
+        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+#endif
+        if (type->cast) {
+          type->cast->prev = cast;
+          cast->next = type->cast;
+        }
+        type->cast = cast;
+      }
+      cast++;
+    }
+    /* Set entry in modules->types array equal to the type */
+    swig_module.types[i] = type;
+  }
+  swig_module.types[i] = 0;
+  
+#ifdef SWIGRUNTIME_DEBUG
+  printf("**** SWIG_InitializeModule: Cast List ******\n");
+  for (i = 0; i < swig_module.size; ++i) {
+    int j = 0;
+    swig_cast_info *cast = swig_module.cast_initial[i];
+    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+    while (cast->type) {
+      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+      cast++;
+      ++j;
+    }
+    printf("---- Total casts: %d\n",j);
+  }
+  printf("**** SWIG_InitializeModule: Cast List ******\n");
+#endif
+}
+
+/* This function will propagate the clientdata field of type to
+* any new swig_type_info structures that have been added into the list
+* of equivalent types.  It is like calling
+* SWIG_TypeClientData(type, clientdata) a second time.
+*/
+SWIGRUNTIME void
+SWIG_PropagateClientData(void) {
+  size_t i;
+  swig_cast_info *equiv;
+  static int init_run = 0;
+  
+  if (init_run) return;
+  init_run = 1;
+  
+  for (i = 0; i < swig_module.size; i++) {
+    if (swig_module.types[i]->clientdata) {
+      equiv = swig_module.types[i]->cast;
+      while (equiv) {
+        if (!equiv->converter) {
+          if (equiv->type && !equiv->type->clientdata)
+          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+        }
+        equiv = equiv->next;
+      }
+    }
+  }
+}
+
+#ifdef __cplusplus
+#if 0
+{
+  /* c-mode */
+#endif
+}
+#endif
+
+
+
+#ifdef __cplusplus
+extern "C"
+#endif
+
+XS(SWIG_init) {
+  dXSARGS;
+  int i;
+  
+  SWIG_InitializeModule(0);
+  
+  /* Install commands */
+  for (i = 0; swig_commands[i].name; i++) {
+    newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
+  }
+  
+  /* Install variables */
+  for (i = 0; swig_variables[i].name; i++) {
+    SV *sv;
+    sv = get_sv((char*) swig_variables[i].name, TRUE | 0x2 | GV_ADDMULTI);
+    if (swig_variables[i].type) {
+      SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type,0);
+    } else {
+      sv_setiv(sv,(IV) 0);
+    }
+    swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
+  }
+  
+  /* Install constant */
+  for (i = 0; swig_constants[i].type; i++) {
+    SV *sv;
+    sv = get_sv((char*)swig_constants[i].name, TRUE | 0x2 | GV_ADDMULTI);
+    switch(swig_constants[i].type) {
+    case SWIG_INT:
+      sv_setiv(sv, (IV) swig_constants[i].lvalue);
+      break;
+    case SWIG_FLOAT:
+      sv_setnv(sv, (double) swig_constants[i].dvalue);
+      break;
+    case SWIG_STRING:
+      sv_setpv(sv, (char *) swig_constants[i].pvalue);
+      break;
+    case SWIG_POINTER:
+      SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype),0);
+      break;
+    case SWIG_BINARY:
+      SWIG_MakePackedObj(sv, swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype));
+      break;
+    default:
+      break;
+    }
+    SvREADONLY_on(sv);
+  }
+  
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_FILENAME", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("/etc/security/prof_attr"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_DB_NAME", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("prof_attr.org_dir"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_DB_NCOL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(5)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_DB_NKEYCOL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_DB_TBLT", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("prof_attr_tbl"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_NAME_DEFAULT_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("nobody"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_COL0_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("name"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_COL1_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("res1"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_COL2_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("res2"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_COL3_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("desc"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_COL4_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("attr"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "DEF_PROF", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("PROFS_GRANTED="));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "DEF_CONSUSER", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("CONSOLE_USER="));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "MAXPROFS", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(4096)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_KEYCOL0", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_AUTHS_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("auths"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_PROFS_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("profiles"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "PROFATTR_PRIVS_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("privs"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  SWIG_TypeClientData(SWIGTYPE_p_profstr_s, (void*) "secdb::profstr_t");
+  SWIG_TypeClientData(SWIGTYPE_p_profattr_s, (void*) "secdb::profattr_t");
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_FILENAME", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("/etc/user_attr"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_DB_NAME", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("user_attr.org_dir"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_DB_NCOL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(5)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_DB_NKEYCOL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(2)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_DB_TBL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("user_attr_tbl"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_NAME_DEFAULT_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("nobody"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_COL0_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("name"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_COL1_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("qualifier"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_COL2_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("res1"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_COL3_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("res2"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_COL4_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("attr"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "DEF_LIMITPRIV", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("PRIV_LIMIT="));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "DEF_DFLTPRIV", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("PRIV_DEFAULT="));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_KEYCOL0", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_KEYCOL1", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("lock"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_LOCKED_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("locked"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_OPEN_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("open"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_FIXED_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("fixed"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_GEN_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("gen"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_GEN_AUTOMATIC_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("automatic"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_GEN_MANUAL_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("manual"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_GEN_SYSDEF_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("sysdef"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_PROFILES_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("profiles"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_PROFILES_NONE_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("none"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_ROLES_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("roles"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_ROLES_NONE_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("none"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_DEFAULTPROJ_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("project"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_IDLETIME_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("idletime"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_IDLECMD_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("idlecmd"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_IDLECMD_LOCK_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("lock"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_IDLECMD_LOGOUT_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("logout"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_TYPE_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("type"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_TYPE_NORMAL_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("normal"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_TYPE_ADMIN_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("admin"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_TYPE_NONADMIN_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("role"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_AUTHS_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("auths"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LIMPRIV_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("limitpriv"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_DFLTPRIV_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("defaultpriv"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_AFTER_RETRIES_KW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("lock_after_retries"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_CLEARANCE", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("clearance"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LABELVIEW", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("labelview"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LABELVIEW_EXTERNAL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("external"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LABELVIEW_HIDESL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("hidesl"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_HIDESL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("hidesl"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LABELVIEW_INTERNAL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("internal"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LABELVIEW_SHOWSL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("showsl"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LABELTRANS", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("labeltrans"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_NO", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("no"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_LOCK_YES", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("yes"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_MINLABEL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("min_label"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_PASSWD", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("password"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_PASSWD_AUTOMATIC", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("automatic"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_PASSWD_MANUAL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("manual"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "USERATTR_TYPE_ROLE", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("role"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  SWIG_TypeClientData(SWIGTYPE_p_userstr_s, (void*) "secdb::userstr_t");
+  SWIG_TypeClientData(SWIGTYPE_p_userattr_s, (void*) "secdb::userattr_t");
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "DEFAULT_POLICY", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("solaris"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "SUSER_POLICY", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("suser"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_ACTION", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("act"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_COMMAND", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("cmd"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_JAVA_CLASS", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("java_class"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_JAVA_METHOD", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("java_method"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_ASSIGN", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("="));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_DELIMITER", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr(";"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_EMPTY", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr(""));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_ESCAPE", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_char  SWIG_PERL_CALL_ARGS_1((char)('\\')));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_ADD_KEYS", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(16)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_SPECIAL", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("=;:\\"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_TOKEN_DELIMIT", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr(":"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_WILDCARD", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("*"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_WILDCHAR", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_char  SWIG_PERL_CALL_ARGS_1((char)('*')));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_ACTION_WILDCARD", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_FromCharPtr("*;*;*;*;*"));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_FLAG_NONE", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x0000)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "KV_FLAG_REQUIRED", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x0001)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "ATTR_FOUND", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "ATTR_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(-1)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  /*@SWIG:/usr/share/swig/1.3.35/perl5/perltypemaps.swg,64,%set_constant@*/ do {
+    SV *sv = get_sv((char*) SWIG_prefix "ATTR_NO_RECOVERY", TRUE | 0x2 | GV_ADDMULTI);
+    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(-2)));
+    SvREADONLY_on(sv);
+  } while(0) /*@SWIG@*/;
+  SWIG_TypeClientData(SWIGTYPE_p_kv_s, (void*) "secdb::kv_t");
+  SWIG_TypeClientData(SWIGTYPE_p_kva_s, (void*) "secdb::kva_t");
+  ST(0) = &PL_sv_yes;
+  XSRETURN(1);
+}
+
