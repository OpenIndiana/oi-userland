--- webkitgtk-2.10.4/Source/JavaScriptCore/dfg/DFGOperations.cpp.1	2015-12-06 06:20:06.774777256 +0300
+++ webkitgtk-2.10.4/Source/JavaScriptCore/dfg/DFGOperations.cpp	2015-12-06 06:20:30.172814891 +0300
@@ -1176,7 +1176,7 @@
 
 double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
 {
-    return fmod(a, b);
+    return fmod((double)a,(double)b);
 }
 
 JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)
--- webkitgtk-2.10.4/Source/JavaScriptCore/dfg/DFGStaticExecutionCountEstimationPhase.cpp.1	2015-12-06 06:23:50.615719207 +0300
+++ webkitgtk-2.10.4/Source/JavaScriptCore/dfg/DFGStaticExecutionCountEstimationPhase.cpp	2015-12-06 06:28:41.130831571 +0300
@@ -52,7 +52,7 @@
             if (!block)
                 continue;
 
-            block->executionCount = pow(10, m_graph.m_naturalLoops.loopDepth(block));
+            block->executionCount = powf(10, m_graph.m_naturalLoops.loopDepth(block));
         }
         
         // Estimate branch weights based on execution counts. This isn't quite correct. It'll
--- webkitgtk-2.10.4/Source/WebCore/rendering/shapes/BoxShape.cpp.1	2015-12-06 22:22:41.366689701 +0300
+++ webkitgtk-2.10.4/Source/WebCore/rendering/shapes/BoxShape.cpp	2015-12-06 22:39:42.943299176 +0300
@@ -43,7 +43,7 @@
 
     LayoutUnit ratio = radius / margin;
     if (ratio < 1)
-        return radius + (margin * (1 + pow(ratio - 1, 3)));
+        return radius + (margin * (1 + pow(double(ratio) - 1, 3)));
 
     return radius + margin;
 }
--- webkitgtk-2.10.4/Source/WebCore/rendering/shapes/RasterShape.cpp.1	2015-12-06 22:45:15.927162094 +0300
+++ webkitgtk-2.10.4/Source/WebCore/rendering/shapes/RasterShape.cpp	2015-12-06 22:46:17.707715422 +0300
@@ -142,7 +142,7 @@
         return *m_intervals;
 
     int shapeMarginInt = clampToPositiveInteger(ceil(shapeMargin()));
-    int maxShapeMarginInt = std::max(m_marginRectSize.width(), m_marginRectSize.height()) * sqrt(2);
+    int maxShapeMarginInt = std::max(m_marginRectSize.width(), m_marginRectSize.height()) * sqrt((double)2);
     if (!m_marginIntervals)
         m_marginIntervals = m_intervals->computeShapeMarginIntervals(std::min(shapeMarginInt, maxShapeMarginInt));
 
