--- opensmalltalk-vm-sun-v5.0.65/platforms/unix/vm/sqUnixMain.c	Fri Aug  2 20:38:44 2024
+++ p0/opensmalltalk-vm-sun-v5.0.65/platforms/unix/vm/sqUnixMain.c	Sun Aug  4 15:53:15 2024
@@ -59,7 +59,6 @@
 #include <errno.h>
 #include <signal.h>
 #include <fcntl.h>
-#include <dlfcn.h>
 #if !defined(NOEXECINFO) && defined(HAVE_EXECINFO_H)
 # include <execinfo.h>
 # define BACKTRACE_DEPTH 64
@@ -91,7 +90,7 @@
 #define DefaultHeapSize		  20	     	/* megabytes BEYOND actual image size */
 #define DefaultMmapSize		1024     	/* megabytes of virtual memory */
 
-       char  *documentName= 0;			/* name if launched from document */
+       char  *documentName= 0;			/* name if launced from document */
        char   shortImageName[MAXPATHLEN+1];	/* image name */
        char   imageName[MAXPATHLEN+1];		/* full path to image */
 static char   vmName[MAXPATHLEN+1];		/* full path to vm */
@@ -114,10 +113,17 @@
 
 static int    useItimer=	1;	/* 0 to disable itimer-based clock */
 static int    installHandlers=	1;	/* 0 to disable sigusr1 & sigsegv handlers */
-static int    noEvents=		0;	/* 1 to disable new event handling */
+       int    noEvents=		0;	/* 1 to disable new event handling */
        int    noSoundMixer=	0;	/* 1 to disable writing sound mixer levels */
        char  *squeakPlugins=	0;	/* plugin path */
        int    runAsSingleInstance=0;
+#if !STACKVM && !COGVM
+       int    useJit=		0;	/* use default */
+       int    jitProcs=		0;	/* use default */
+       int    jitMaxPIC=	0;	/* use default */
+#else
+# define useJit 0
+#endif
        int    withSpy=		0;
 
        int    uxDropFileCount=	0;	/* number of dropped items	*/
@@ -134,7 +140,9 @@
 #endif
 
 int sqIgnorePluginErrors	= 0;
+int runInterpreter		= 1;
 
+
 #include "SqDisplay.h"
 #include "SqSound.h"
 
@@ -556,9 +564,12 @@
 
 /*** event handling ***/
 
+
 sqInt inputEventSemaIndex= 0;
 
+
 /* set asynchronous input event semaphore  */
+
 sqInt
 ioSetInputSemaphore(sqInt semaIndex)
 {
@@ -1078,18 +1089,15 @@
 			"    x16 %14p x17 %14p x18 %14p x19 %14p\n"
 			"    x20 %14p x21 %14p x22 %14p x23 %14p\n"
 			"    x24 %14p x25 %14p x26 %14p x27 %14p\n"
-			"    x29 %14p  fp %14p  lr %14p  sp %14p\n"
-			"     pc %14p pstate 0x%08x fault @ %14p\n",
-			v(regs[ 0]), v(regs[ 1]), v(regs[ 2]), v(regs[ 3]),
-			v(regs[ 4]), v(regs[ 5]), v(regs[ 6]), v(regs[ 7]),
-			v(regs[ 8]), v(regs[ 9]), v(regs[10]), v(regs[11]),
-			v(regs[12]), v(regs[13]), v(regs[14]), v(regs[15]),
-			v(regs[16]), v(regs[17]), v(regs[18]), v(regs[19]),
-			v(regs[20]), v(regs[21]), v(regs[22]), v(regs[23]),
-			v(regs[24]), v(regs[25]), v(regs[26]), v(regs[27]),
-			v(regs[28]), v(regs[29]), v(regs[30]), v(uap->uc_mcontext.sp),
-			v(uap->uc_mcontext.pc), uap->uc_mcontext.pstate,
-			v(uap->uc_mcontext.fault_address));
+			"    x29 %14p  fp %14p  lr %14p  sp %14p\n",
+			regs[0], regs[1], regs[2], regs[3],
+			regs[4], regs[5], regs[6], regs[7],
+			regs[8], regs[9], regs[10], regs[11],
+			regs[12], regs[13], regs[14], regs[15],
+			regs[16], regs[17], regs[18], regs[19],
+			regs[20], regs[21], regs[22], regs[23],
+			regs[24], regs[25], regs[26], regs[27],
+			regs[28], regs[29], regs[30], (void *)(uap->uc_mcontext.sp));
 	return v(uap->uc_mcontext.pc);
 # elif __linux__ && (defined(__arm__) || defined(__arm32__) || defined(ARM32))
 	struct sigcontext *regs = &uap->uc_mcontext;
@@ -1163,7 +1171,7 @@
 }
 
 static void
-sigusr1(int sig, siginfo_t *info, void *uap)
+sigusr1(int sig, siginfo_t *info, ucontext_t *uap)
 {
 	int saved_errno = errno;
 	time_t now = time(NULL);
@@ -1191,7 +1199,7 @@
 ioCanCatchFFIExceptions() { return 1; }
 
 static void
-sigsegv(int sig, siginfo_t *info, void *uap)
+sigsegv(int sig, siginfo_t *info, ucontext_t *uap)
 {
 	time_t now = time(NULL);
 	char ctimebuf[32];
@@ -1206,7 +1214,7 @@
 
 	if (!inFault) {
 		extern sqInt primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc);
-		primitiveFailForFFIExceptionat(sig, ((ucontext_t *)uap)->_PC_IN_UCONTEXT);
+		primitiveFailForFFIExceptionat(sig, uap->_PC_IN_UCONTEXT);
 		inFault = 1;
 		crashdump = crashDumpFile();
 		ctime_r(&now,ctimebuf);
@@ -1492,6 +1500,22 @@
   return value;
 }
 
+#if !STACKVM && !COGVM
+static int
+jitArgs(char *str)
+{
+  char *endptr= str;
+  int  args= 3;				/* default JIT mode = fast compiler */
+  
+  if (*str == '\0') return args;
+  if (*str != ',')
+    args= strtol(str, &endptr, 10);	/* mode */
+  while (*endptr == ',')		/* [,debugFlag]* */
+    args|= (1 << (strtol(endptr + 1, &endptr, 10) + 8));
+  return args;
+}
+#endif /* !STACKVM && !COGVM */
+
 /* ----------------- built-in main vm module */
 
 # include <locale.h>
@@ -1518,6 +1542,11 @@
   if ((ev= getenv("SQUEAK_PLUGINS")))	squeakPlugins= strdup(ev);
   if ((ev= getenv("SQUEAK_NOEVENTS")))	noEvents= 1;
   if ((ev= getenv("SQUEAK_NOTIMER")))	useItimer= 0;
+#if !STACKVM && !COGVM
+  if ((ev= getenv("SQUEAK_JIT")))	useJit= jitArgs(ev);
+  if ((ev= getenv("SQUEAK_PROCS")))	jitProcs= atoi(ev);
+  if ((ev= getenv("SQUEAK_MAXPIC")))	jitMaxPIC= atoi(ev);
+#endif /* !STACKVM && !COGVM */
   if ((ev= getenv("SQUEAK_ENCODING")))	setEncoding(&sqTextEncoding, ev);
   if ((ev= getenv("SQUEAK_PATHENC")))	setEncoding(&uxPathEncoding, ev);
   if ((ev= getenv("SQUEAK_TEXTENC")))	setEncoding(&uxTextEncoding, ev);
@@ -1621,6 +1650,11 @@
   else if (!strcmp(argv[0], VMOPTION("blockonwarn")))  { erroronwarn = blockOnError = 1; return 1; }
   else if (!strcmp(argv[0], VMOPTION("exitonwarn")))   { erroronwarn    = 1; return 1; }
   else if (!strcmp(argv[0], VMOPTION("timephases")))   { printPhaseTime(1) ; return 1; }
+#if !STACKVM && !COGVM
+  else if (!strncmp(argv[0],VMOPTION("jit"), 4))    { useJit  = jitArgs(argv[0]+4); return 1; }
+  else if (!strcmp(argv[0], VMOPTION("nojit")))     { useJit  = 0; return 1; }
+  else if (!strcmp(argv[0], VMOPTION("spy")))       { withSpy = 1; return 1; }
+#endif /* !STACKVM && !COGVM */
 #if defined(AIO_DEBUG)
   else if (!strcmp(argv[0], VMOPTION("aiolog")))	{ aioDebugLogging = 1; return 1; }
 #endif
@@ -1630,6 +1664,10 @@
   else if (!strcmp(argv[0], VMOPTION("single")))    { runAsSingleInstance=1; return 1; }
   /* option requires an argument */
   else if (argc > 1 && !strcmp(argv[0], VMOPTION("memory")))   { extraMemory  = strtobkmg(argv[1]); return 2; }
+#if !STACKVM && !COGVM
+  else if (argc > 1 && !strcmp(argv[0], VMOPTION("procs")))    { jitProcs     = atoi(argv[1]);     return 2; }
+  else if (argc > 1 && !strcmp(argv[0], VMOPTION("maxpic")))   { jitMaxPIC    = atoi(argv[1]);     return 2; }
+#endif /* !STACKVM && !COGVM */
 #if !SPURVM
   else if (argc > 1 && !strcmp(argv[0], VMOPTION("mmap")))     { useMmap      = strtobkmg(argv[1]); return 2; }
 #endif
@@ -1881,6 +1919,9 @@
 	printf("Deprecated:\n");
 	printf("  "VMOPTION("display")" <dpy>        equivalent to '-vm-display-X11 "VMOPTION("display")" <dpy>'\n");
 	printf("  "VMOPTION("headless")"             equivalent to '-vm-display-X11 "VMOPTION("headless")"'\n");
+# if !STACKVM
+	printf("  "VMOPTION("jit")"                  enable the dynamic compiler (if available)\n");
+# endif
 	printf("  "VMOPTION("nodisplay")"            equivalent to '-vm-display-null'\n");
 	printf("  "VMOPTION("nomixer")"              disable modification of mixer settings\n");
 	printf("  "VMOPTION("nosound")"              equivalent to '-vm-sound-null'\n");
@@ -1933,6 +1974,15 @@
   }
   modulesDo(m)
     m->printUsage();
+  if (useJit)
+    {
+      printf("\njit <option>s:\n");
+      printf("  "VMOPTION("align")" <n>            align functions at <n>-byte boundaries\n");
+      printf("  "VMOPTION("jit")"<o>[,<d>...]      set optimisation [and debug] levels\n");
+      printf("  "VMOPTION("maxpic")" <n>           set maximum PIC size to <n> entries\n");
+      printf("  "VMOPTION("procs")" <n>            allow <n> concurrent volatile processes\n");
+      printf("  "VMOPTION("spy")"                  enable the system spy\n");
+    }
   printf("\nNotes:\n");
   printf("  <imageName> defaults to `" DEFAULT_IMAGE_NAME "'.\n");
   modulesDo(m)
@@ -2101,48 +2151,29 @@
     /* read the image file and allocate memory for Squeak heap */
     int fd;
     struct stat sb;
-
-	// first check for an embedded image
-	void *handle = dlopen(NULL, RTLD_NOW);
-	void *embeddedImage;
-	if (handle && (embeddedImage = dlsym(handle,"embeddedImage"))) {
-		strcpy(shortImageName,dlsym(handle,"embeddedImageName"));
-		fd = ((char *)embeddedImage)[0] == GZIPMagic0 && ((char *)embeddedImage)[1] == GZIPMagic1
-				? ImageIsEmbeddedAndCompressed
-				: ImageIsEmbedded;
-		unsigned long *imageSize = dlsym(handle,"embeddedImageSize");
-		unsigned long *compressedSize = dlsym(handle,"embeddedCompressedDataSize");
-		dlclose(handle);
-		noteEmbeddedImage(embeddedImage,
-						  *imageSize,
-						  compressedSize ? *compressedSize : 0);
-		sb.st_size = *imageSize;
-	}
-	else {
-		char imagePath[MAXPATHLEN];
-		sq2uxPath(shortImageName, strlen(shortImageName), imagePath, MAXPATHLEN - 1, 1);
-		if (-1 == stat(imagePath, &sb)
-		 || (!S_ISREG(sb.st_mode) && !S_ISLNK(sb.st_mode)))
-			imageNotFound(imagePath); // imageNotFound will exit
-		fd = sqImageFileOpen(imagePath, "rb"); // sqImageFileOpen handles the errors. fd is valid here
+    char imagePath[MAXPATHLEN];
+    sq2uxPath(shortImageName, strlen(shortImageName), imagePath, MAXPATHLEN - 1, 1);
+    if (-1 == stat(imagePath, &sb) || (!S_ISREG(sb.st_mode) && !S_ISLNK(sb.st_mode))) {
+        imageNotFound(imagePath); // imageNotFound will exit
+    }
+    fd = sqImageFileOpen(imagePath, "rb"); // sqImageFileOpen handles the errors. fd is valid here
 #ifdef DEBUG_IMAGE
-		printf("fstat(%d) => %d\n", fd, fstat(fd, &sb));
+    printf("fstat(%d) => %d\n", fd, fstat(fd, &sb));
 #endif
-		recordFullPathForImageName(shortImageName); /* full image path */
-	}
 
+    recordFullPathForImageName(shortImageName); /* full image path */
     if (extraMemory)
         useMmap= 0;
     else
         extraMemory= DefaultHeapSize * 1024 * 1024;
 #ifdef DEBUG_IMAGE
-	printf("image size %ld + heap size %ld (useMmap = %d)\n", (long)sb.st_size, extraMemory, useMmap);
+    printf("image size %ld + heap size %ld (useMmap = %d)\n", (long)sb.st_size, extraMemory, useMmap);
 #endif
 #if SPURVM
     readImageFromFileHeapSizeStartingAt(fd, 0, 0);
 #else
-	extraMemory += (long)sb.st_size;
-	readImageFromFileHeapSizeStartingAt(fd, extraMemory, 0);
+    extraMemory += (long)sb.st_size;
+    readImageFromFileHeapSizeStartingAt(fd, extraMemory, 0);
 #endif
     sqImageFileClose(fd);
 }
@@ -2263,6 +2294,31 @@
    */
   dpy->winOpen(runAsSingleInstance ? squeakArgCnt : 0, squeakArgVec);
 
+#if defined(HAVE_LIBDL) && !STACKVM
+  if (useJit)
+    {
+      /* first try to find an internal dynamic compiler... */
+      void *handle= ioLoadModule(0);
+      void *comp= ioFindExternalFunctionIn("j_interpret", handle);
+      /* ...and if that fails... */
+      if (comp == 0)
+	{
+	  /* ...try to find an external one */
+	  handle= ioLoadModule("SqueakCompiler");
+	  if (handle != 0)
+	    comp= ioFindExternalFunctionIn("j_interpret", handle);
+	}
+      if (comp)
+	{
+	  ((void (*)(void))comp)();
+	  fprintf(stderr, "handing control back to interpret() -- have a nice day\n");
+	}
+      else
+	printf("could not find j_interpret\n");
+      exit(1);
+    }
+#endif /* defined(HAVE_LIBDL) && !STACKVM */
+
   if (installHandlers) {
 	struct sigaction sigusr1_handler_action, sigsegv_handler_action;
 
@@ -2285,8 +2341,10 @@
 #endif
 
   /* run Squeak */
-  printPhaseTime(2);
-  interpret();
+  if (runInterpreter) {
+	printPhaseTime(2);
+    interpret();
+  }
 
   /* we need these, even if not referenced from main executable */
   (void)sq2uxPath;
@@ -2402,12 +2460,13 @@
 
 
 #if COGVM
-// Support code for Cog.
-// a) Answer whether the C frame pointer is in use, for capture of the C stack
-//    pointers.
-// b) answer the amount of headroom to ensure in a Cog stack page, including
-//    the size of the redzone, if any. This allows signal/interrupt delivery
-//    while executing jitted Smalltalk code.
+/*
+ * Support code for Cog.
+ * a) Answer whether the C frame pointer is in use, for capture of the C stack
+ *    pointers.
+ * b) answer the amount of stack room to ensure in a Cog stack page, including
+ *    the size of the redzone, if any.
+ */
 
 int
 isCFramePointerInUse(usqIntptr_t *cFrmPtrPtr, usqIntptr_t *cStkPtrPtr)
@@ -2420,41 +2479,31 @@
 	return *cFrmPtrPtr >= *cStkPtrPtr && *cFrmPtrPtr <= currentCSP;
 }
 
-// Answer an approximation of the size of the redzone (if any).  Do so by
-// sending a signal to the process and computing the difference between the
-// stack pointer in the signal handler and that in the caller. Assumes stacks
-// descend.
-// In calculating the redzone size we must ensure that the signal sender is the
-// same thread as the signal catcher, otherwise we're measuring the distance
-// between thread stacks, not the distance between a stack frame and an
-// interrupt handler (!!).
+/* Answer an approximation of the size of the redzone (if any).  Do so by
+ * sending a signal to the process and computing the difference between the
+ * stack pointer in the signal handler and that in the caller. Assumes stacks
+ * descend.
+ */
 
 #if !defined(min)
 # define min(x,y) (((x)>(y))?(y):(x))
 #endif
-
 static char * volatile p = 0;
-static sqOSThread signalling_thread;
 
 static void
-sighandler(int sig)
-{
-	assert(ioOSThreadsEqual(signalling_thread,ioCurrentOSThread()));
-	p = (char *)&sig;
-}
+sighandler(int sig, siginfo_t *info, void *uap)
+{ p = (char *)&sig; }
 
 static int
 getRedzoneSize()
 {
 	struct sigaction handler_action, old;
-	handler_action.sa_handler = sighandler;
-	handler_action.sa_flags = SA_NODEFER;
+	handler_action.sa_sigaction = sighandler;
+	handler_action.sa_flags = SA_NODEFER | SA_SIGINFO;
 	sigemptyset(&handler_action.sa_mask);
 	(void)sigaction(SIGPROF, &handler_action, &old);
 
-	signalling_thread = ioCurrentOSThread();
-
-	do pthread_kill(signalling_thread,SIGPROF); while (!p);
+	do kill(getpid(),SIGPROF); while (!p);
 	(void)sigaction(SIGPROF, &old, 0);
 	return (char *)min(&old,&handler_action) - p;
 }
@@ -2462,12 +2511,12 @@
 sqInt reportStackHeadroom;
 static int stackPageHeadroom;
 
-// Answer the redzone size plus space for any signal handlers to run in.
-// N.B. Space for signal handers may include space for the dynamic linker to
-// run in since signal handlers may reference other functions, and linking may
-// be lazy.  The reportheadroom switch can be used to check empirically that
-// there is sufficient headroom.
-
+/* Answer the redzone size plus space for any signal handlers to run in.
+ * N.B. Space for signal handers may include space for the dynamic linker to
+ * run in since signal handlers may reference other functions, and linking may
+ * be lazy.  The reportheadroom switch can be used to check empirically that
+ * there is sufficient headroom.
+ */
 int
 osCogStackPageHeadroom()
 {
@@ -2475,4 +2524,4 @@
 		stackPageHeadroom = getRedzoneSize() + 1024;
 	return stackPageHeadroom;
 }
-#endif // COGVM
+#endif /* COGVM */
