--- squeak-4-3799/src/plugins/VectorEnginePlugin/VectorEnginePlugin.c	1970-01-01 01:00:00.000000000 +0000
+++ p0/squeak-4-3799/src/plugins/VectorEnginePlugin/VectorEnginePlugin.c	2021-04-18 11:08:19.117252383 +0000
@@ -0,0 +1,2215 @@
+/* Smalltalk from Cuis 5.0 with VMMaker 4.19.5 translated as C source on 17 April 2021 8:50:35.484957 pm */
+/* Automatically generated by PluginMaker (VMMaker) from 	VectorEnginePlugin */
+
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+/* Default EXPORT macro that does nothing (see comment in sq.h): */
+#define EXPORT(returnType) returnType
+
+/* Do not include the entire sq.h file but just those parts needed. */
+/*  The virtual machine proxy definition */
+#include "sqVirtualMachine.h"
+/* Configuration options */
+#include "sqConfig.h"
+/* Platform specific definitions */
+#include "sqPlatformSpecific.h"
+
+#define true 1
+#define false 0
+#define null 0  /* using 'null' because nil is predefined in Think C */
+#ifdef SQUEAK_BUILTIN_PLUGIN
+#undef EXPORT
+// was #undef EXPORT(returnType) but screws NorCroft cc
+#define EXPORT(returnType) static returnType
+#endif
+#include <stdint.h>
+
+#include "sqMemoryAccess.h"
+
+
+/*** Constants ***/
+
+/*** Function Prototypes ***/
+#pragma export on
+EXPORT(sqInt) primAntiAliasingWidthsubPixelDelta(void);
+EXPORT(sqInt) primArc(void);
+#pragma export off
+static sqInt blendFillOnlyAtredIsInsidegreenIsInsideblueIsInside(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside);
+#pragma export on
+EXPORT(sqInt) primBlendFillOnly(void);
+#pragma export off
+static sqInt blendStrokeAndFillAtredIsInsidegreenIsInsideblueIsInside(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside);
+#pragma export on
+EXPORT(sqInt) primBlendStrokeAndFill(void);
+#pragma export off
+static sqInt blendStrokeOnlyAt(sqInt pixelIndex);
+#pragma export on
+EXPORT(sqInt) primBlendStrokeOnly(void);
+EXPORT(sqInt) primClipCurrentMorph(void);
+EXPORT(sqInt) primClipLeftclipTopclipRightclipBottom(void);
+EXPORT(sqInt) primCubicBezier(void);
+EXPORT(sqInt) primCurrentMorphIdcurrentClipsSubmorphs(void);
+EXPORT(sqInt) primDisplayString(void);
+EXPORT(sqInt) primDisplayUtf32(void);
+EXPORT(sqInt) primDisplayUtf8(void);
+EXPORT(sqInt) primFillRGBA(void);
+EXPORT(const char*) getModuleName(void);
+#pragma export off
+static sqInt halt(void);
+#pragma export on
+EXPORT(sqInt) primInitializePath(void);
+EXPORT(sqInt) primLine(void);
+EXPORT(sqInt) primNewTrajectoryFragment(void);
+EXPORT(sqInt) primQuadraticBezier(void);
+EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
+EXPORT(sqInt) primSpanBottom(void);
+EXPORT(sqInt) primSpanLeft(void);
+EXPORT(sqInt) primSpanRight(void);
+EXPORT(sqInt) primSpanTop(void);
+EXPORT(sqInt) primStrokeRGBA(void);
+EXPORT(sqInt) primStrokeWidth(void);
+EXPORT(sqInt) primSetTarget(void);
+EXPORT(sqInt) primTextTxSet(void);
+#pragma export off
+static sqInt updateAlphasForXy(float x, float y);
+static sqInt updateEdgeCountAtXy(float x, float y);
+/*** Variables ***/
+static uint32_t * alphaMask;
+static float antiAliasingWidth;
+static float auxAntiAliasingWidthScaledInverse;
+static float auxStrokeWidthDilatedHalf;
+static float auxStrokeWidthDilatedHalfSquared;
+static float auxStrokeWidthErodedHalfSquared;
+static sqInt clipBottom;
+static sqInt clipCurrentMorph;
+static sqInt clipLeft;
+static sqInt clipRight;
+static sqInt clipTop;
+static sqInt currentClipsSubmorphs;
+static uint32_t currentMorphId;
+static uint32_t * edgeCounts;
+static float fillA;
+static float fillB;
+static float fillG;
+static float fillR;
+
+#ifdef SQUEAK_BUILTIN_PLUGIN
+extern
+#endif
+struct VirtualMachine* interpreterProxy;
+static const char *moduleName =
+#ifdef SQUEAK_BUILTIN_PLUGIN
+	"VectorEnginePlugin 17 April 2021 (i)"
+#else
+	"VectorEnginePlugin 17 April 2021 (e)"
+#endif
+;
+static uint32_t * morphIds;
+static sqInt prevYTruncated;
+static sqInt simulator;
+static float spanBottom;
+static float spanLeft;
+static float spanRight;
+static float spanTop;
+static float strokeA;
+static float strokeB;
+static float strokeG;
+static float strokeR;
+static float strokeWidth;
+static float subPixelDelta;
+static uint32_t * targetBits;
+static sqInt targetHeight;
+static sqInt targetWidth;
+static float textTxA11;
+static float textTxA12;
+static float textTxA13;
+static float textTxA21;
+static float textTxA22;
+static float textTxA23;
+
+
+EXPORT(sqInt) primAntiAliasingWidthsubPixelDelta(void) {
+	double aFloat;
+	double otherFloat;
+
+	aFloat = interpreterProxy->stackFloatValue(1);
+	otherFloat = interpreterProxy->stackFloatValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	antiAliasingWidth = aFloat;
+	auxAntiAliasingWidthScaledInverse = 127.0 / aFloat;
+	subPixelDelta = otherFloat;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(2);
+	return null;
+}
+
+EXPORT(sqInt) primArc(void) {
+	float xp;
+	float angle;
+	float yp;
+	float x;
+	sqInt h;
+	float y;
+	double cx;
+	double cy;
+	double rx;
+	double ry;
+	double startAngle;
+	double thetaCos;
+	double thetaSin;
+	sqInt hops;
+	double d;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+
+	cx = interpreterProxy->stackFloatValue(10);
+	cy = interpreterProxy->stackFloatValue(9);
+	rx = interpreterProxy->stackFloatValue(8);
+	ry = interpreterProxy->stackFloatValue(7);
+	startAngle = interpreterProxy->stackFloatValue(6);
+	thetaCos = interpreterProxy->stackFloatValue(5);
+	thetaSin = interpreterProxy->stackFloatValue(4);
+	hops = interpreterProxy->stackIntegerValue(3);
+	d = interpreterProxy->stackFloatValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	angle = startAngle;
+	for (h = 1; h <= (hops + 1); h += 1) {
+		xp = (cos(angle)) * rx;
+		yp = (sin(angle)) * ry;
+		x = ((thetaCos * xp) - (thetaSin * yp)) + cx;
+		y = ((thetaSin * xp) + (thetaCos * yp)) + cy;
+		spanLeft = ((spanLeft < x) ? spanLeft : x);
+		spanTop = ((spanTop < y) ? spanTop : y);
+		spanRight = ((spanRight < x) ? x : spanRight);
+		spanBottom = ((spanBottom < y) ? y : spanBottom);
+		updateAlphasForXy(x, y);
+		if (!(fillA == 0.0)) {
+			updateEdgeCountAtXy(x, y);
+		}
+		angle += d;
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(11);
+	return null;
+}
+
+
+/*	targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
+	Blends stroke over background.
+	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255] */
+
+static sqInt blendFillOnlyAtredIsInsidegreenIsInsideblueIsInside(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside) {
+	uint32_t targetWord;
+	float alphaR;
+	uint32_t clippingAntiAliasBits;
+	float antiAliasRedAlpha;
+	uint32_t antiAliasGreenAlphaBits;
+	float unAlphaB;
+	float resultG;
+	float antiAliasGreenAlpha;
+	float alphaG;
+	uint32_t antiAliasGreenAlphaBitsShifted;
+	uint32_t resultGBits;
+	uint32_t antiAliasRedAlphaBits;
+	uint32_t resultBBits;
+	float resultAlphaR;
+	float resultB;
+	uint32_t antiAliasBlueAlphaBits;
+	float resultAlphaG;
+	uint32_t resultAlphaBits;
+	float unAlphaR;
+	float alphaB;
+	float clippingAntiAlias;
+	uint32_t morphIdWord;
+	float antiAliasBlueAlpha;
+	float unAlphaG;
+	uint32_t resultRBits;
+	float resultAlphaB;
+	uint32_t antiAliasAlphasWord;
+	float resultR;
+	float targetAlpha;
+
+	antiAliasAlphasWord = alphaMask[pixelIndex];
+	if (antiAliasAlphasWord == 0) {
+
+		/* Not in the stroke */
+
+		if (!(isRedInside || (isGreenInside || (isBlueInside)))) {
+
+			/* Not inside */
+
+			return 0;
+		}
+	}
+	antiAliasRedAlphaBits = antiAliasAlphasWord & 0x7F0000;
+	antiAliasGreenAlphaBits = antiAliasAlphasWord & 0x7F00;
+	antiAliasBlueAlphaBits = antiAliasAlphasWord & 0x7F;
+	if (isRedInside) {
+		antiAliasRedAlphaBits = 0x7F0000 - antiAliasRedAlphaBits;
+	}
+	if (isGreenInside) {
+		antiAliasGreenAlphaBits = 0x7F00 - antiAliasGreenAlphaBits;
+	}
+	if (isBlueInside) {
+		antiAliasBlueAlphaBits = 0x7F - antiAliasBlueAlphaBits;
+	}
+	antiAliasRedAlpha = antiAliasRedAlphaBits * (1.0 / ((127.0 * 256) * 256));
+	antiAliasGreenAlpha = antiAliasGreenAlphaBits * (1.0 / (127.0 * 256));
+	antiAliasBlueAlpha = antiAliasBlueAlphaBits * (1.0 / 127.0);
+	alphaR = antiAliasRedAlpha * fillA;
+	alphaG = antiAliasGreenAlpha * fillA;
+	alphaB = antiAliasBlueAlpha * fillA;
+	if (currentClipsSubmorphs) {
+
+		/* Don't clip us, but do clip submorphs */
+
+		morphIdWord = morphIds[pixelIndex];
+		clippingAntiAliasBits = morphIdWord & 0x7F;
+		
+					antiAliasGreenAlphaBitsShifted = antiAliasGreenAlphaBits >> 8;;
+		if (antiAliasGreenAlphaBitsShifted > clippingAntiAliasBits) {
+			clippingAntiAliasBits = antiAliasGreenAlphaBitsShifted;
+		}
+	} else {
+		if (clipCurrentMorph) {
+
+			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
+
+			morphIdWord = morphIds[pixelIndex];
+			clippingAntiAliasBits = morphIdWord & 0x7F;
+			clippingAntiAlias = clippingAntiAliasBits * (1.0 / 127.0);
+			alphaR = alphaR * clippingAntiAlias;
+			alphaG = alphaG * clippingAntiAlias;
+			alphaB = alphaB * clippingAntiAlias;
+		} else {
+
+			/* Don't do any additional clipping or preparation for further clipping */
+
+			clippingAntiAliasBits = 0;
+		}
+	}
+	if (!(((alphaR + alphaG) + alphaB) == 0.0)) {
+		targetWord = targetBits[pixelIndex];
+		resultAlphaBits = targetWord & 0xFF000000U;
+		resultRBits = targetWord & 0xFF0000;
+		resultGBits = targetWord & 0xFF00;
+		resultBBits = targetWord & 0xFF;
+
+		/* These if are not really needed. just ignore them if we use simd instructions. */
+
+		targetAlpha = resultAlphaBits * (1.0 / (((255.0 * 256) * 256) * 256));
+		if (!(alphaR == 0.0)) {
+			unAlphaR = 1.0 - alphaR;
+			resultAlphaR = alphaR + (unAlphaR * targetAlpha);
+			
+					resultR = ((alphaR * fillR) * 255.0) + ((unAlphaR * (resultRBits >> 16)) * targetAlpha);
+					resultRBits = (uint32_t)(resultR  / resultAlphaR + 0.5) << 16;;
+		}
+		if (!(alphaG == 0.0)) {
+			unAlphaG = 1.0 - alphaG;
+			resultAlphaG = alphaG + (unAlphaG * targetAlpha);
+			
+					resultG = ((alphaG * fillG) * 255.0) + ((unAlphaG * (resultGBits >> 8)) * targetAlpha);
+					resultGBits = (uint32_t)(resultG / resultAlphaG + 0.5) << 8;
+					resultAlphaBits = (uint32_t)(resultAlphaG * 255.0 + 0.5) << 24;;
+		}
+		if (!(alphaB == 0.0)) {
+			unAlphaB = 1.0 - alphaB;
+			resultAlphaB = alphaB + (unAlphaB * targetAlpha);
+			
+					resultB = ((alphaB * fillB) * 255.0) + ((unAlphaB * resultBBits) * targetAlpha);
+					resultBBits = (uint32_t)(resultB / resultAlphaB + 0.5);;
+		}
+		targetWord = ((resultAlphaBits | resultRBits) | resultGBits) | resultBBits;
+		targetBits[pixelIndex] = targetWord;
+		if (!(currentMorphId == 0)) {
+			morphIdWord = (currentMorphId << 8) + clippingAntiAliasBits;
+			morphIds[pixelIndex] = morphIdWord;
+		}
+	}
+	return null;
+}
+
+EXPORT(sqInt) primBlendFillOnly(void) {
+	sqInt isRedInside;
+	sqInt isBlueInside;
+	uint8_t edgesThisPixelB;
+	sqInt pixelIndex;
+	uint8_t edgesUpToThisPixelR;
+	uint32_t edgesThisPixelWord;
+	sqInt displayX;
+	sqInt isGreenInside;
+	uint8_t edgesUpToThisPixelG;
+	uint8_t edgesThisPixelR;
+	uint8_t edgesUpToThisPixelB;
+	uint8_t edgesThisPixelG;
+	sqInt displayY;
+	sqInt l;
+	sqInt t;
+	sqInt r;
+	sqInt b;
+	unsigned *aBitmap;
+	unsigned *aWordArray;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+
+	l = interpreterProxy->stackIntegerValue(7);
+	t = interpreterProxy->stackIntegerValue(6);
+	r = interpreterProxy->stackIntegerValue(5);
+	b = interpreterProxy->stackIntegerValue(4);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(3)));
+	aBitmap = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(3))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(2)));
+	aWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	targetBits = aBitmap;
+	morphIds = aWordArray;
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	for (displayY = t; displayY <= b; displayY += 1) {
+		edgesUpToThisPixelR = 0;
+		edgesUpToThisPixelG = 0;
+		edgesUpToThisPixelB = 0;
+		pixelIndex = ((displayY * targetWidth) + l) - 1;
+		for (displayX = l; displayX <= r; displayX += 1) {
+			pixelIndex += 1;
+			edgesThisPixelWord = edgeCounts[pixelIndex];
+			edgeCounts[pixelIndex] = 0;
+			
+					edgesThisPixelR = (uint32_t) (edgesThisPixelWord & 0xFF0000) >> 16;
+					edgesThisPixelG = (uint32_t) (edgesThisPixelWord & 0xFF00) >> 8;
+					edgesThisPixelB = (uint32_t) (edgesThisPixelWord & 0xFF);;
+			edgesUpToThisPixelR += edgesThisPixelR;
+			edgesUpToThisPixelG += edgesThisPixelG;
+			edgesUpToThisPixelB += edgesThisPixelB;
+			
+					isRedInside = edgesUpToThisPixelR;
+					isGreenInside = edgesUpToThisPixelG;
+					isBlueInside = edgesUpToThisPixelB;;
+			blendFillOnlyAtredIsInsidegreenIsInsideblueIsInside(pixelIndex, isRedInside, isGreenInside, isBlueInside);
+			alphaMask[pixelIndex] = 0;
+		}
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(8);
+	return null;
+}
+
+
+/*	targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
+	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
+	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255] */
+
+static sqInt blendStrokeAndFillAtredIsInsidegreenIsInsideblueIsInside(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside) {
+	uint32_t targetWord;
+	float alphaR;
+	uint32_t clippingAntiAliasBits;
+	float antiAliasRedAlpha;
+	uint32_t antiAliasGreenAlphaBits;
+	float unAlphaB;
+	float resultG;
+	float foreB;
+	float antiAliasGreenAlpha;
+	float alphaG;
+	uint32_t antiAliasGreenAlphaBitsShifted;
+	uint32_t resultGBits;
+	uint32_t antiAliasRedAlphaBits;
+	uint32_t resultBBits;
+	float resultAlphaR;
+	float resultB;
+	uint32_t antiAliasBlueAlphaBits;
+	float resultAlphaG;
+	uint32_t resultAlphaBits;
+	float unAlphaR;
+	float foreR;
+	float alphaB;
+	float clippingAntiAlias;
+	uint32_t morphIdWord;
+	float antiAliasBlueAlpha;
+	float unAlphaG;
+	float foreG;
+	uint32_t resultRBits;
+	float resultAlphaB;
+	uint32_t antiAliasAlphasWord;
+	float resultR;
+	float targetAlpha;
+
+	antiAliasAlphasWord = alphaMask[pixelIndex];
+	if (antiAliasAlphasWord == 0) {
+
+		/* Not in the stroke */
+
+		if (!(isRedInside || (isGreenInside || (isBlueInside)))) {
+
+			/* Not inside */
+
+			return 0;
+		}
+	}
+	antiAliasRedAlphaBits = antiAliasAlphasWord & 0x7F0000;
+	antiAliasGreenAlphaBits = antiAliasAlphasWord & 0x7F00;
+	antiAliasBlueAlphaBits = antiAliasAlphasWord & 0x7F;
+	antiAliasRedAlpha = antiAliasRedAlphaBits * (1.0 / ((127.0 * 256) * 256));
+	antiAliasGreenAlpha = antiAliasGreenAlphaBits * (1.0 / (127.0 * 256));
+	antiAliasBlueAlpha = antiAliasBlueAlphaBits * (1.0 / 127.0);
+	if (isRedInside) {
+
+		/* Do gradient between stroke and fill. Blend the result over background */
+
+		alphaR = (antiAliasRedAlpha * strokeA) + ((1 - antiAliasRedAlpha) * fillA);
+		foreR = ((antiAliasRedAlpha * strokeR) * 255.0) + (((1.0 - antiAliasRedAlpha) * fillR) * 255.0);
+	} else {
+
+		/* Blend stroke over background */
+
+		alphaR = antiAliasRedAlpha * strokeA;
+		foreR = strokeR * 255.0;
+	}
+	if (isGreenInside) {
+
+		/* Do gradient between stroke and fill. Blend the result over background */
+
+		alphaG = (antiAliasGreenAlpha * strokeA) + ((1 - antiAliasGreenAlpha) * fillA);
+		foreG = ((antiAliasGreenAlpha * strokeG) * 255.0) + (((1.0 - antiAliasGreenAlpha) * fillG) * 255.0);
+	} else {
+
+		/* Blend stroke over background */
+
+		alphaG = antiAliasGreenAlpha * strokeA;
+		foreG = strokeG * 255.0;
+	}
+	if (isBlueInside) {
+
+		/* Do gradient between stroke and fill. Blend the result over background */
+
+		alphaB = (antiAliasBlueAlpha * strokeA) + ((1 - antiAliasBlueAlpha) * fillA);
+		foreB = ((antiAliasBlueAlpha * strokeB) * 255.0) + (((1.0 - antiAliasBlueAlpha) * fillB) * 255.0);
+	} else {
+
+		/* Blend stroke over background */
+
+		alphaB = antiAliasBlueAlpha * strokeA;
+		foreB = strokeB * 255.0;
+	}
+	if (currentClipsSubmorphs) {
+
+		/* Don't clip us, but do clip submorphs */
+
+		if (isGreenInside) {
+			clippingAntiAliasBits = 0x7F;
+		} else {
+			morphIdWord = morphIds[pixelIndex];
+			clippingAntiAliasBits = morphIdWord & 0x7F;
+			
+							antiAliasGreenAlphaBitsShifted = antiAliasGreenAlphaBits >> 8;;
+			if (antiAliasGreenAlphaBitsShifted > clippingAntiAliasBits) {
+				clippingAntiAliasBits = antiAliasGreenAlphaBitsShifted;
+			}
+		}
+	} else {
+		if (clipCurrentMorph) {
+
+			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
+
+			morphIdWord = morphIds[pixelIndex];
+			clippingAntiAliasBits = morphIdWord & 0x7F;
+			clippingAntiAlias = clippingAntiAliasBits * (1.0 / 127.0);
+			alphaR = alphaR * clippingAntiAlias;
+			alphaG = alphaG * clippingAntiAlias;
+			alphaB = alphaB * clippingAntiAlias;
+		} else {
+
+			/* Don't do any additional clipping or preparation for further clipping */
+
+			clippingAntiAliasBits = 0;
+		}
+	}
+	if (!(((alphaR + alphaG) + alphaB) == 0.0)) {
+		targetWord = targetBits[pixelIndex];
+		resultAlphaBits = targetWord & 0xFF000000U;
+		resultRBits = targetWord & 0xFF0000;
+		resultGBits = targetWord & 0xFF00;
+		resultBBits = targetWord & 0xFF;
+
+		/* These if are not really needed. just ignore them if we use simd instructions. */
+
+		targetAlpha = resultAlphaBits * (1.0 / (((255.0 * 256) * 256) * 256));
+		if (!(alphaR == 0.0)) {
+			unAlphaR = 1.0 - alphaR;
+			resultAlphaR = alphaR + (unAlphaR * targetAlpha);
+			
+					resultR = (alphaR * foreR) + ((unAlphaR * (resultRBits >> 16)) * targetAlpha);
+					resultRBits = (uint32_t)(resultR  / resultAlphaR + 0.5) << 16;;
+		}
+		if (!(alphaG == 0.0)) {
+			unAlphaG = 1.0 - alphaG;
+			resultAlphaG = alphaG + (unAlphaG * targetAlpha);
+			
+					resultG = (alphaG * foreG) + ((unAlphaG * (resultGBits >> 8)) * targetAlpha);
+					resultGBits = (uint32_t)(resultG / resultAlphaG + 0.5) << 8;
+					resultAlphaBits = (uint32_t)(resultAlphaG * 255.0 + 0.5) << 24;;
+		}
+		if (!(alphaB == 0.0)) {
+			unAlphaB = 1.0 - alphaB;
+			resultAlphaB = alphaB + (unAlphaB * targetAlpha);
+			
+					resultB = (alphaB * foreB) + ((unAlphaB * resultBBits) * targetAlpha);
+					resultBBits = (uint32_t)(resultB / resultAlphaB + 0.5);;
+		}
+		targetWord = ((resultAlphaBits | resultRBits) | resultGBits) | resultBBits;
+		targetBits[pixelIndex] = targetWord;
+		if (!(currentMorphId == 0)) {
+			morphIdWord = (currentMorphId << 8) + clippingAntiAliasBits;
+			morphIds[pixelIndex] = morphIdWord;
+		}
+	}
+	return null;
+}
+
+EXPORT(sqInt) primBlendStrokeAndFill(void) {
+	sqInt isRedInside;
+	sqInt isBlueInside;
+	uint8_t edgesThisPixelB;
+	sqInt pixelIndex;
+	uint8_t edgesUpToThisPixelR;
+	uint32_t edgesThisPixelWord;
+	sqInt displayX;
+	sqInt isGreenInside;
+	uint8_t edgesUpToThisPixelG;
+	uint8_t edgesThisPixelR;
+	uint8_t edgesUpToThisPixelB;
+	uint8_t edgesThisPixelG;
+	sqInt displayY;
+	sqInt l;
+	sqInt t;
+	sqInt r;
+	sqInt b;
+	unsigned *aBitmap;
+	unsigned *aWordArray;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+
+	l = interpreterProxy->stackIntegerValue(7);
+	t = interpreterProxy->stackIntegerValue(6);
+	r = interpreterProxy->stackIntegerValue(5);
+	b = interpreterProxy->stackIntegerValue(4);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(3)));
+	aBitmap = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(3))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(2)));
+	aWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	targetBits = aBitmap;
+	morphIds = aWordArray;
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	for (displayY = t; displayY <= b; displayY += 1) {
+		edgesUpToThisPixelR = 0;
+		edgesUpToThisPixelG = 0;
+		edgesUpToThisPixelB = 0;
+		pixelIndex = ((displayY * targetWidth) + l) - 1;
+		for (displayX = l; displayX <= r; displayX += 1) {
+			pixelIndex += 1;
+			edgesThisPixelWord = edgeCounts[pixelIndex];
+			edgeCounts[pixelIndex] = 0;
+			
+					edgesThisPixelR = (uint32_t) (edgesThisPixelWord & 0xFF0000) >> 16;
+					edgesThisPixelG = (uint32_t) (edgesThisPixelWord & 0xFF00) >> 8;
+					edgesThisPixelB = (uint32_t) (edgesThisPixelWord & 0xFF);;
+			edgesUpToThisPixelR += edgesThisPixelR;
+			edgesUpToThisPixelG += edgesThisPixelG;
+
+			/* In C, integers already behave like booleans */
+
+			edgesUpToThisPixelB += edgesThisPixelB;
+			
+					isRedInside = edgesUpToThisPixelR;
+					isGreenInside = edgesUpToThisPixelG;
+					isBlueInside = edgesUpToThisPixelB;;
+			blendStrokeAndFillAtredIsInsidegreenIsInsideblueIsInside(pixelIndex, isRedInside, isGreenInside, isBlueInside);
+			alphaMask[pixelIndex] = 0;
+		}
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(8);
+	return null;
+}
+
+
+/*	targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
+	Blends stroke over background.
+	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255] */
+
+static sqInt blendStrokeOnlyAt(sqInt pixelIndex) {
+	uint32_t targetWord;
+	float alphaR;
+	uint32_t clippingAntiAliasBits;
+	float antiAliasRedAlpha;
+	uint32_t antiAliasGreenAlphaBits;
+	float unAlphaB;
+	float resultG;
+	float antiAliasGreenAlpha;
+	float alphaG;
+	uint32_t antiAliasGreenAlphaBitsShifted;
+	uint32_t resultGBits;
+	uint32_t antiAliasRedAlphaBits;
+	uint32_t resultBBits;
+	float resultAlphaR;
+	float resultB;
+	uint32_t antiAliasBlueAlphaBits;
+	float resultAlphaG;
+	uint32_t resultAlphaBits;
+	float unAlphaR;
+	float alphaB;
+	float clippingAntiAlias;
+	uint32_t morphIdWord;
+	float antiAliasBlueAlpha;
+	float unAlphaG;
+	uint32_t resultRBits;
+	float resultAlphaB;
+	uint32_t antiAliasAlphasWord;
+	float resultR;
+	float targetAlpha;
+
+	antiAliasAlphasWord = alphaMask[pixelIndex];
+	if (antiAliasAlphasWord == 0) {
+		return 0;
+	}
+	antiAliasRedAlphaBits = antiAliasAlphasWord & 0x7F0000;
+	antiAliasGreenAlphaBits = antiAliasAlphasWord & 0x7F00;
+	antiAliasBlueAlphaBits = antiAliasAlphasWord & 0x7F;
+	antiAliasRedAlpha = antiAliasRedAlphaBits * (1.0 / ((127.0 * 256) * 256));
+	antiAliasGreenAlpha = antiAliasGreenAlphaBits * (1.0 / (127.0 * 256));
+	antiAliasBlueAlpha = antiAliasBlueAlphaBits * (1.0 / 127.0);
+	alphaR = antiAliasRedAlpha * strokeA;
+	alphaG = antiAliasGreenAlpha * strokeA;
+	alphaB = antiAliasBlueAlpha * strokeA;
+	if (currentClipsSubmorphs) {
+
+		/* Don't clip us, but do clip submorphs */
+
+		morphIdWord = morphIds[pixelIndex];
+		clippingAntiAliasBits = morphIdWord & 0x7F;
+		
+					antiAliasGreenAlphaBitsShifted = antiAliasGreenAlphaBits >> 8;;
+		if (antiAliasGreenAlphaBitsShifted > clippingAntiAliasBits) {
+			clippingAntiAliasBits = antiAliasGreenAlphaBitsShifted;
+		}
+	} else {
+		if (clipCurrentMorph) {
+
+			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
+
+			morphIdWord = morphIds[pixelIndex];
+			clippingAntiAliasBits = morphIdWord & 0x7F;
+			clippingAntiAlias = clippingAntiAliasBits * (1.0 / 127.0);
+			alphaR = alphaR * clippingAntiAlias;
+			alphaG = alphaG * clippingAntiAlias;
+			alphaB = alphaB * clippingAntiAlias;
+		} else {
+
+			/* Don't do any additional clipping or preparation for further clipping */
+
+			clippingAntiAliasBits = 0;
+		}
+	}
+	if (!(((alphaR + alphaG) + alphaB) == 0.0)) {
+		targetWord = targetBits[pixelIndex];
+		resultAlphaBits = targetWord & 0xFF000000U;
+		resultRBits = targetWord & 0xFF0000;
+		resultGBits = targetWord & 0xFF00;
+		resultBBits = targetWord & 0xFF;
+
+		/* These if are not really needed. just ignore them if we use simd instructions. */
+
+		targetAlpha = resultAlphaBits * (1.0 / (((255.0 * 256) * 256) * 256));
+		if (!(alphaR == 0.0)) {
+			unAlphaR = 1.0 - alphaR;
+			resultAlphaR = alphaR + (unAlphaR * targetAlpha);
+			
+					resultR = ((alphaR * strokeR) * 255.0) + ((unAlphaR * (resultRBits >> 16)) * targetAlpha);
+					resultRBits = (uint32_t)(resultR  / resultAlphaR + 0.5) << 16;;
+		}
+		if (!(alphaG == 0.0)) {
+			unAlphaG = 1.0 - alphaG;
+			resultAlphaG = alphaG + (unAlphaG * targetAlpha);
+			
+					resultG = ((alphaG * strokeG) * 255.0) + ((unAlphaG * (resultGBits >> 8)) * targetAlpha);
+					resultGBits = (uint32_t)(resultG / resultAlphaG + 0.5) << 8;
+					resultAlphaBits = (uint32_t)(resultAlphaG * 255.0 + 0.5) << 24;;
+		}
+		if (!(alphaB == 0.0)) {
+			unAlphaB = 1.0 - alphaB;
+			resultAlphaB = alphaB + (unAlphaB * targetAlpha);
+			
+					resultB = ((alphaB * strokeB) * 255.0) + ((unAlphaB * resultBBits) * targetAlpha);
+					resultBBits = (uint32_t)(resultB / resultAlphaB + 0.5);;
+		}
+		targetWord = ((resultAlphaBits | resultRBits) | resultGBits) | resultBBits;
+		targetBits[pixelIndex] = targetWord;
+		if (!(currentMorphId == 0)) {
+			morphIdWord = (currentMorphId << 8) + clippingAntiAliasBits;
+			morphIds[pixelIndex] = morphIdWord;
+		}
+	}
+	return null;
+}
+
+EXPORT(sqInt) primBlendStrokeOnly(void) {
+	sqInt pixelIndex;
+	sqInt displayY;
+	sqInt displayX;
+	sqInt l;
+	sqInt t;
+	sqInt r;
+	sqInt b;
+	unsigned *aBitmap;
+	unsigned *aWordArray;
+	unsigned *anotherWordArray;
+
+	l = interpreterProxy->stackIntegerValue(6);
+	t = interpreterProxy->stackIntegerValue(5);
+	r = interpreterProxy->stackIntegerValue(4);
+	b = interpreterProxy->stackIntegerValue(3);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(2)));
+	aBitmap = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	aWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	targetBits = aBitmap;
+	morphIds = aWordArray;
+	alphaMask = anotherWordArray;
+	for (displayY = t; displayY <= b; displayY += 1) {
+		pixelIndex = ((displayY * targetWidth) + l) - 1;
+		for (displayX = l; displayX <= r; displayX += 1) {
+			pixelIndex += 1;
+			blendStrokeOnlyAt(pixelIndex);
+			alphaMask[pixelIndex] = 0;
+		}
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(7);
+	return null;
+}
+
+EXPORT(sqInt) primClipCurrentMorph(void) {
+	sqInt pixelIndex;
+	sqInt displayY;
+	sqInt displayX;
+	sqInt aBoolean;
+	unsigned *aWordArray;
+
+	aBoolean = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(1));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	aWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	morphIds = aWordArray;
+	if (clipCurrentMorph && (!aBoolean)) {
+		for (displayY = clipTop; displayY <= clipBottom; displayY += 1) {
+			pixelIndex = (displayY * targetWidth) + clipLeft;
+			for (displayX = clipLeft; displayX <= clipRight; displayX += 1) {
+				pixelIndex += 1;
+				morphIds[pixelIndex] = ((morphIds[pixelIndex]) & 0xFFFFFF00U);
+			}
+		}
+	}
+	clipCurrentMorph = aBoolean;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(2);
+	return null;
+}
+
+EXPORT(sqInt) primClipLeftclipTopclipRightclipBottom(void) {
+	sqInt l;
+	sqInt t;
+	sqInt r;
+	sqInt b;
+
+	l = interpreterProxy->stackIntegerValue(3);
+	t = interpreterProxy->stackIntegerValue(2);
+	r = interpreterProxy->stackIntegerValue(1);
+	b = interpreterProxy->stackIntegerValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	clipLeft = l;
+	clipTop = t;
+	clipRight = r;
+	clipBottom = b;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(4);
+	return null;
+}
+
+EXPORT(sqInt) primCubicBezier(void) {
+	float yMaxEnd;
+	float oneLessT;
+	float increment;
+	float xMaxEnd;
+	float t;
+	float yMinEnd;
+	float f1;
+	float x;
+	sqInt h;
+	float f3;
+	float xMinEnd;
+	float f2;
+	float y;
+	float f23;
+	float f4;
+	double xFrom;
+	double yFrom;
+	double xTo;
+	double yTo;
+	double xControl1;
+	double yControl1;
+	double xControl2;
+	double yControl2;
+	sqInt hops;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+
+	xFrom = interpreterProxy->stackFloatValue(10);
+	yFrom = interpreterProxy->stackFloatValue(9);
+	xTo = interpreterProxy->stackFloatValue(8);
+	yTo = interpreterProxy->stackFloatValue(7);
+	xControl1 = interpreterProxy->stackFloatValue(6);
+	yControl1 = interpreterProxy->stackFloatValue(5);
+	xControl2 = interpreterProxy->stackFloatValue(4);
+	yControl2 = interpreterProxy->stackFloatValue(3);
+	hops = interpreterProxy->stackIntegerValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+
+	/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
+
+	alphaMask = anotherWordArray;
+	xMinEnd = ((xFrom < xTo) ? xFrom : xTo);
+	xMaxEnd = ((xFrom < xTo) ? xTo : xFrom);
+	yMinEnd = ((yFrom < yTo) ? yFrom : yTo);
+	yMaxEnd = ((yFrom < yTo) ? yTo : yFrom);
+	spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd * 0.25) + ((((xControl1 < xControl2) ? xControl1 : xControl2)) * 0.75))) ? xMinEnd : ((xMinEnd * 0.25) + ((((xControl1 < xControl2) ? xControl1 : xControl2)) * 0.75))))) ? spanLeft : (((xMinEnd < ((xMinEnd * 0.25) + ((((xControl1 < xControl2) ? xControl1 : xControl2)) * 0.75))) ? xMinEnd : ((xMinEnd * 0.25) + ((((xControl1 < xControl2) ? xControl1 : xControl2)) * 0.75)))));
+	spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd * 0.25) + ((((xControl1 < xControl2) ? xControl2 : xControl1)) * 0.75))) ? ((xMaxEnd * 0.25) + ((((xControl1 < xControl2) ? xControl2 : xControl1)) * 0.75)) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd * 0.25) + ((((xControl1 < xControl2) ? xControl2 : xControl1)) * 0.75))) ? ((xMaxEnd * 0.25) + ((((xControl1 < xControl2) ? xControl2 : xControl1)) * 0.75)) : xMaxEnd)) : spanRight);
+	spanTop = ((spanTop < (((yMinEnd < ((yMinEnd * 0.25) + ((((yControl1 < yControl2) ? yControl1 : yControl2)) * 0.75))) ? yMinEnd : ((yMinEnd * 0.25) + ((((yControl1 < yControl2) ? yControl1 : yControl2)) * 0.75))))) ? spanTop : (((yMinEnd < ((yMinEnd * 0.25) + ((((yControl1 < yControl2) ? yControl1 : yControl2)) * 0.75))) ? yMinEnd : ((yMinEnd * 0.25) + ((((yControl1 < yControl2) ? yControl1 : yControl2)) * 0.75)))));
+	spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd * 0.25) + ((((yControl1 < yControl2) ? yControl2 : yControl1)) * 0.75))) ? ((yMaxEnd * 0.25) + ((((yControl1 < yControl2) ? yControl2 : yControl1)) * 0.75)) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd * 0.25) + ((((yControl1 < yControl2) ? yControl2 : yControl1)) * 0.75))) ? ((yMaxEnd * 0.25) + ((((yControl1 < yControl2) ? yControl2 : yControl1)) * 0.75)) : yMaxEnd)) : spanBottom);
+	t = 0.0;
+	increment = 1.0 / hops;
+	for (h = 1; h <= hops; h += 1) {
+		oneLessT = 1.0 - t;
+		f1 = (oneLessT * oneLessT) * oneLessT;
+		f23 = (3.0 * oneLessT) * t;
+		f2 = f23 * oneLessT;
+		f3 = f23 * t;
+		f4 = (t * t) * t;
+		x = (((f1 * xFrom) + (f2 * xControl1)) + (f3 * xControl2)) + (f4 * xTo);
+		y = (((f1 * yFrom) + (f2 * yControl1)) + (f3 * yControl2)) + (f4 * yTo);
+		updateAlphasForXy(x, y);
+		if (!(fillA == 0.0)) {
+			updateEdgeCountAtXy(x, y);
+		}
+		t += increment;
+	}
+	updateAlphasForXy(xTo, yTo);
+	if (!(fillA == 0.0)) {
+		updateEdgeCountAtXy(xTo, yTo);
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(11);
+	return null;
+}
+
+
+/*	Bound it someway to 31 or 32 bits (SmallInteger in 32 bits, or uint in 32 bits, etc...) */
+
+EXPORT(sqInt) primCurrentMorphIdcurrentClipsSubmorphs(void) {
+	sqInt aNumber;
+	sqInt aBoolean;
+
+	aNumber = interpreterProxy->stackIntegerValue(1);
+	aBoolean = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	currentMorphId = aNumber;
+	if (currentMorphId == 0) {
+		clipCurrentMorph = 0;
+	}
+	currentClipsSubmorphs = aBoolean;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(2);
+	return null;
+}
+
+EXPORT(sqInt) primDisplayString(void) {
+	float yMaxEnd;
+	float ttMoveToX;
+	float nextGlyphY;
+	sqInt numBeziers;
+	float oneLessT;
+	float endX;
+	float ttEndY;
+	float increment;
+	float advanceWidth;
+	float ttControlX;
+	float xMaxEnd;
+	float startY;
+	float t;
+	sqInt hops;
+	float dx;
+	sqInt numContours;
+	float yMinEnd;
+	float f1;
+	float contourStartY;
+	float x;
+	sqInt h;
+	float f3;
+	float controlY;
+	uint8_t iso8859s15;
+	double answer;
+	float nextGlyphX;
+	sqInt charIndex;
+	float ttMoveToY;
+	float xMinEnd;
+	float ttEndX;
+	float endY;
+	sqInt idx2;
+	float ttControlY;
+	float startX;
+	float contourStartX;
+	float dy;
+	sqInt idx;
+	float controlX;
+	float f2;
+	sqInt i;
+	float y;
+	char *aString;
+	sqInt startIndex;
+	sqInt stopIndex;
+	double destX;
+	double destY;
+	float *contourData;
+	int *contourDataIndexes;
+	sqInt aBoolean;
+	sqInt theHopsPerPixel;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+	sqInt _return_value;
+
+	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(10)));
+	aString = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(10))));
+	startIndex = interpreterProxy->stackIntegerValue(9);
+	stopIndex = interpreterProxy->stackIntegerValue(8);
+	destX = interpreterProxy->stackFloatValue(7);
+	destY = interpreterProxy->stackFloatValue(6);
+	contourData = ((float *) (interpreterProxy->arrayValueOf(interpreterProxy->stackValue(5))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(4)));
+	contourDataIndexes = ((int *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(4))));
+	aBoolean = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(3));
+	theHopsPerPixel = interpreterProxy->stackIntegerValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	nextGlyphX = destX;
+	nextGlyphY = destY;
+	for (charIndex = (startIndex - 1); charIndex <= (stopIndex - 1); charIndex += 1) {
+		iso8859s15 = aString[charIndex];;
+		if (aBoolean) {
+			if (iso8859s15 == 95) {
+				iso8859s15 = 28;
+			}
+			if (iso8859s15 == 94) {
+				iso8859s15 = 30;
+			}
+		}
+		i = contourDataIndexes[iso8859s15];
+		i -= 1;
+		advanceWidth = contourData[i];
+		i += 5;
+		numContours = ((sqInt)(contourData[i]));
+		i += 1;
+		for (idx = 1; idx <= numContours; idx += 1) {
+			numBeziers = ((sqInt)(contourData[i]));
+			i += 1;
+			ttMoveToX = (contourData[i]) + nextGlyphX;
+			i += 1;
+			ttMoveToY = (contourData[i]) + nextGlyphY;
+			i += 1;
+			startX = ((ttMoveToX * textTxA11) + (ttMoveToY * textTxA12)) + textTxA13;
+			startY = ((ttMoveToX * textTxA21) + (ttMoveToY * textTxA22)) + textTxA23;
+			contourStartX = startX;
+			contourStartY = startY;
+			/* begin newTrajectoryFragment */
+			prevYTruncated = 0x7FFFFFFFU;
+			if (interpreterProxy->failed()) {
+				goto l1;
+			}
+		l1:	/* end newTrajectoryFragment */;
+			for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
+				ttEndX = contourData[i];
+				i += 1;
+				ttEndY = contourData[i];
+				i += 1;
+				ttControlX = contourData[i];
+				i += 1;
+				ttControlY = contourData[i];
+				i += 1;
+				endX = ((ttEndX * textTxA11) + (ttEndY * textTxA12)) + startX;
+				endY = ((ttEndX * textTxA21) + (ttEndY * textTxA22)) + startY;
+				controlX = ((ttControlX * textTxA11) + (ttControlY * textTxA12)) + startX;
+				controlY = ((ttControlX * textTxA21) + (ttControlY * textTxA22)) + startY;
+				
+					dx = fabs(controlX-startX) + fabs(endX-controlX);
+					dy = fabs(controlY-startY) + fabs(endY-controlY);;
+
+				/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
+
+				hops = (((sqInt)((((dx < dy) ? dy : dx)) * theHopsPerPixel))) + 1;
+				xMinEnd = ((startX < endX) ? startX : endX);
+				xMaxEnd = ((startX < endX) ? endX : startX);
+				yMinEnd = ((startY < endY) ? startY : endY);
+				yMaxEnd = ((startY < endY) ? endY : startY);
+				spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
+				spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
+				spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));
+
+				/* Compute Quadratic Bezier Curve, */
+
+				spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
+				t = 0.0;
+				increment = 1.0 / hops;
+				for (h = 1; h <= hops; h += 1) {
+					oneLessT = 1.0 - t;
+					f1 = oneLessT * oneLessT;
+					f2 = (2.0 * oneLessT) * t;
+					f3 = t * t;
+					x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
+					y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
+					updateAlphasForXy(x, y);
+					updateEdgeCountAtXy(x, y);
+					t += increment;
+				}
+				startX = endX;
+				startY = endY;
+			}
+			updateAlphasForXy(endX, endY);
+			updateEdgeCountAtXy(endX, endY);
+			updateEdgeCountAtXy(contourStartX, contourStartY);
+		}
+		nextGlyphX += advanceWidth;
+	}
+	answer = nextGlyphX;
+	_return_value = interpreterProxy->floatObjectOf(answer);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(12, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primDisplayUtf32(void) {
+	float yMaxEnd;
+	float ttMoveToX;
+	float nextGlyphY;
+	sqInt utf32;
+	sqInt numBeziers;
+	float oneLessT;
+	float endX;
+	float ttEndY;
+	sqInt utf8Byte1;
+	float increment;
+	float advanceWidth;
+	sqInt utf8Byte3;
+	float ttControlX;
+	float xMaxEnd;
+	float startY;
+	float t;
+	sqInt hops;
+	float dx;
+	sqInt numContours;
+	float yMinEnd;
+	float f1;
+	float contourStartY;
+	float x;
+	sqInt h;
+	float f3;
+	float controlY;
+	sqInt uft8Byte2;
+	double answer;
+	float nextGlyphX;
+	float ttMoveToY;
+	float xMinEnd;
+	float ttEndX;
+	float endY;
+	sqInt idx2;
+	sqInt utf8Byte4;
+	float ttControlY;
+	float startX;
+	sqInt utf32Index;
+	float contourStartX;
+	float dy;
+	sqInt idx;
+	float controlX;
+	float f2;
+	sqInt i;
+	float y;
+	unsigned *aWordArray;
+	sqInt startIndex;
+	sqInt stopIndex;
+	double destX;
+	double destY;
+	float *contourData;
+	int *contourDataIndexes;
+	sqInt aBoolean;
+	sqInt theHopsPerPixel;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+	sqInt _return_value;
+
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(10)));
+	aWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(10))));
+	startIndex = interpreterProxy->stackIntegerValue(9);
+	stopIndex = interpreterProxy->stackIntegerValue(8);
+	destX = interpreterProxy->stackFloatValue(7);
+	destY = interpreterProxy->stackFloatValue(6);
+	contourData = ((float *) (interpreterProxy->arrayValueOf(interpreterProxy->stackValue(5))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(4)));
+	contourDataIndexes = ((int *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(4))));
+	aBoolean = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(3));
+	theHopsPerPixel = interpreterProxy->stackIntegerValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	nextGlyphX = destX;
+	nextGlyphY = destY;
+	for (utf32Index = (startIndex - 1); utf32Index <= (stopIndex - 1); utf32Index += 1) {
+		utf32 = aWordArray[utf32Index];
+		if (aBoolean) {
+			if (utf32 == 95) {
+				utf32 = 8592;
+			}
+			if (utf32 == 94) {
+				utf32 = 8593;
+			}
+		}
+		if (utf32 <= 0x7F) {
+			utf8Byte1 = utf32;
+			i = contourDataIndexes[utf8Byte1];
+		} else {
+			if (utf32 <= 0x7FF) {
+				utf8Byte1 = (((usqInt) utf32 >> 6)) | 192;
+				uft8Byte2 = (utf32 & 0x3F) | 128;
+				i = contourDataIndexes[utf8Byte1];
+				i = contourDataIndexes[uft8Byte2 - i];
+			} else {
+				if (utf32 <= 0xFFFF) {
+					utf8Byte1 = (((usqInt) utf32 >> 12)) | 224;
+					uft8Byte2 = ((((usqInt) utf32 >> 6)) & 0x3F) | 128;
+					utf8Byte3 = (utf32 & 0x3F) | 128;
+					i = contourDataIndexes[utf8Byte1];
+					i = contourDataIndexes[uft8Byte2 - i];
+					i = contourDataIndexes[utf8Byte3 - i];
+				} else {
+					utf8Byte1 = (((usqInt) utf32 >> 18)) | 240;
+					uft8Byte2 = ((((usqInt) utf32 >> 12)) & 0x3F) | 128;
+					utf8Byte3 = ((((usqInt) utf32 >> 6)) & 0x3F) | 128;
+					utf8Byte4 = (utf32 & 0x3F) | 128;
+					i = contourDataIndexes[utf8Byte1];
+					i = contourDataIndexes[uft8Byte2 - i];
+					i = contourDataIndexes[utf8Byte3 - i];
+					i = contourDataIndexes[utf8Byte4 - i];
+				}
+			}
+		}
+		i -= 1;
+		advanceWidth = contourData[i];
+		i += 5;
+		numContours = ((sqInt)(contourData[i]));
+		i += 1;
+		for (idx = 1; idx <= numContours; idx += 1) {
+			numBeziers = ((sqInt)(contourData[i]));
+			i += 1;
+			ttMoveToX = (contourData[i]) + nextGlyphX;
+			i += 1;
+			ttMoveToY = (contourData[i]) + nextGlyphY;
+			i += 1;
+			startX = ((ttMoveToX * textTxA11) + (ttMoveToY * textTxA12)) + textTxA13;
+			startY = ((ttMoveToX * textTxA21) + (ttMoveToY * textTxA22)) + textTxA23;
+			contourStartX = startX;
+			contourStartY = startY;
+			/* begin newTrajectoryFragment */
+			prevYTruncated = 0x7FFFFFFFU;
+			if (interpreterProxy->failed()) {
+				goto l1;
+			}
+		l1:	/* end newTrajectoryFragment */;
+			for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
+				ttEndX = contourData[i];
+				i += 1;
+				ttEndY = contourData[i];
+				i += 1;
+				ttControlX = contourData[i];
+				i += 1;
+				ttControlY = contourData[i];
+				i += 1;
+				endX = ((ttEndX * textTxA11) + (ttEndY * textTxA12)) + startX;
+				endY = ((ttEndX * textTxA21) + (ttEndY * textTxA22)) + startY;
+				controlX = ((ttControlX * textTxA11) + (ttControlY * textTxA12)) + startX;
+				controlY = ((ttControlX * textTxA21) + (ttControlY * textTxA22)) + startY;
+				
+					dx = fabs(controlX-startX) + fabs(endX-controlX);
+					dy = fabs(controlY-startY) + fabs(endY-controlY);;
+
+				/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
+
+				hops = (((sqInt)((((dx < dy) ? dy : dx)) * theHopsPerPixel))) + 1;
+				xMinEnd = ((startX < endX) ? startX : endX);
+				xMaxEnd = ((startX < endX) ? endX : startX);
+				yMinEnd = ((startY < endY) ? startY : endY);
+				yMaxEnd = ((startY < endY) ? endY : startY);
+				spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
+				spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
+				spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));
+
+				/* Compute Quadratic Bezier Curve, */
+
+				spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
+				t = 0.0;
+				increment = 1.0 / hops;
+				for (h = 1; h <= hops; h += 1) {
+					oneLessT = 1.0 - t;
+					f1 = oneLessT * oneLessT;
+					f2 = (2.0 * oneLessT) * t;
+					f3 = t * t;
+					x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
+					y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
+					updateAlphasForXy(x, y);
+					updateEdgeCountAtXy(x, y);
+					t += increment;
+				}
+				startX = endX;
+				startY = endY;
+			}
+			updateAlphasForXy(endX, endY);
+			updateEdgeCountAtXy(endX, endY);
+			updateEdgeCountAtXy(contourStartX, contourStartY);
+		}
+		nextGlyphX += advanceWidth;
+	}
+	answer = nextGlyphX;
+	_return_value = interpreterProxy->floatObjectOf(answer);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(12, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primDisplayUtf8(void) {
+	float yMaxEnd;
+	sqInt baseIndex;
+	float ttMoveToX;
+	float nextGlyphY;
+	sqInt numBeziers;
+	float oneLessT;
+	float endX;
+	float ttEndY;
+	float increment;
+	float advanceWidth;
+	float ttControlX;
+	float xMaxEnd;
+	float startY;
+	float t;
+	sqInt hops;
+	float dx;
+	sqInt numContours;
+	float yMinEnd;
+	float f1;
+	float contourStartY;
+	float x;
+	sqInt h;
+	float f3;
+	float controlY;
+	sqInt byteIndex;
+	double answer;
+	float nextGlyphX;
+	float ttMoveToY;
+	uint8_t byte;
+	float xMinEnd;
+	float ttEndX;
+	float endY;
+	sqInt idx2;
+	float ttControlY;
+	float startX;
+	float contourStartX;
+	float dy;
+	sqInt idx;
+	float controlX;
+	float f2;
+	sqInt i;
+	float y;
+	char *aByteArray;
+	sqInt byteStartIndex;
+	sqInt byteStopIndex;
+	double destX;
+	double destY;
+	float *contourData;
+	int *contourDataIndexes;
+	sqInt aBoolean;
+	sqInt theHopsPerPixel;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+	sqInt _return_value;
+
+	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(10)));
+	aByteArray = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(10))));
+	byteStartIndex = interpreterProxy->stackIntegerValue(9);
+	byteStopIndex = interpreterProxy->stackIntegerValue(8);
+	destX = interpreterProxy->stackFloatValue(7);
+	destY = interpreterProxy->stackFloatValue(6);
+	contourData = ((float *) (interpreterProxy->arrayValueOf(interpreterProxy->stackValue(5))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(4)));
+	contourDataIndexes = ((int *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(4))));
+	aBoolean = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(3));
+	theHopsPerPixel = interpreterProxy->stackIntegerValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	nextGlyphX = destX;
+	nextGlyphY = destY;
+	baseIndex = 0;
+	for (byteIndex = (byteStartIndex - 1); byteIndex <= (byteStopIndex - 1); byteIndex += 1) {
+		byte = aByteArray[byteIndex];
+		i = contourDataIndexes[baseIndex + byte];
+		if (aBoolean) {
+			if (byte == 95) {
+				i = contourDataIndexes[226];
+				i = contourDataIndexes[134 - i];
+				i = contourDataIndexes[144 - i];
+			}
+			if (byte == 94) {
+				i = contourDataIndexes[226];
+				i = contourDataIndexes[134 - i];
+				i = contourDataIndexes[145 - i];
+			}
+		}
+		if (i < 0) {
+			baseIndex = 0 - i;
+		} else {
+			i -= 1;
+			advanceWidth = contourData[i];
+			i += 5;
+			numContours = ((sqInt)(contourData[i]));
+			i += 1;
+			for (idx = 1; idx <= numContours; idx += 1) {
+				numBeziers = ((sqInt)(contourData[i]));
+				i += 1;
+				ttMoveToX = (contourData[i]) + nextGlyphX;
+				i += 1;
+				ttMoveToY = (contourData[i]) + nextGlyphY;
+				i += 1;
+				startX = ((ttMoveToX * textTxA11) + (ttMoveToY * textTxA12)) + textTxA13;
+				startY = ((ttMoveToX * textTxA21) + (ttMoveToY * textTxA22)) + textTxA23;
+				contourStartX = startX;
+				contourStartY = startY;
+				/* begin newTrajectoryFragment */
+				prevYTruncated = 0x7FFFFFFFU;
+				if (interpreterProxy->failed()) {
+					goto l1;
+				}
+			l1:	/* end newTrajectoryFragment */;
+				for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
+					ttEndX = contourData[i];
+					i += 1;
+					ttEndY = contourData[i];
+					i += 1;
+					ttControlX = contourData[i];
+					i += 1;
+					ttControlY = contourData[i];
+					i += 1;
+					endX = ((ttEndX * textTxA11) + (ttEndY * textTxA12)) + startX;
+					endY = ((ttEndX * textTxA21) + (ttEndY * textTxA22)) + startY;
+					controlX = ((ttControlX * textTxA11) + (ttControlY * textTxA12)) + startX;
+					controlY = ((ttControlX * textTxA21) + (ttControlY * textTxA22)) + startY;
+					
+							dx = fabs(controlX-startX) + fabs(endX-controlX);
+							dy = fabs(controlY-startY) + fabs(endY-controlY);;
+
+					/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
+
+					hops = (((sqInt)((((dx < dy) ? dy : dx)) * theHopsPerPixel))) + 1;
+					xMinEnd = ((startX < endX) ? startX : endX);
+					xMaxEnd = ((startX < endX) ? endX : startX);
+					yMinEnd = ((startY < endY) ? startY : endY);
+					yMaxEnd = ((startY < endY) ? endY : startY);
+					spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
+					spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
+					spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));
+
+					/* Compute Quadratic Bezier Curve, */
+
+					spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
+					t = 0.0;
+					increment = 1.0 / hops;
+					for (h = 1; h <= hops; h += 1) {
+						oneLessT = 1.0 - t;
+						f1 = oneLessT * oneLessT;
+						f2 = (2.0 * oneLessT) * t;
+						f3 = t * t;
+						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
+						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
+						updateAlphasForXy(x, y);
+						updateEdgeCountAtXy(x, y);
+						t += increment;
+					}
+					startX = endX;
+					startY = endY;
+				}
+				updateAlphasForXy(endX, endY);
+				updateEdgeCountAtXy(endX, endY);
+				updateEdgeCountAtXy(contourStartX, contourStartY);
+			}
+			nextGlyphX += advanceWidth;
+			baseIndex = 0;
+		}
+	}
+	answer = nextGlyphX;
+	_return_value = interpreterProxy->floatObjectOf(answer);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(12, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primFillRGBA(void) {
+	double r;
+	double g;
+	double b;
+	double a;
+
+	r = interpreterProxy->stackFloatValue(3);
+	g = interpreterProxy->stackFloatValue(2);
+	b = interpreterProxy->stackFloatValue(1);
+	a = interpreterProxy->stackFloatValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	fillR = r;
+	fillG = g;
+	fillB = b;
+	fillA = a;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(4);
+	return null;
+}
+
+
+/*	Note: This is hardcoded so it can be run from Squeak.
+	The module name is used for validating a module *after*
+	it is loaded to check if it does really contain the module
+	we're thinking it contains. This is important! */
+
+EXPORT(const char*) getModuleName(void) {
+	return moduleName;
+}
+
+static sqInt halt(void) {
+	;
+	return null;
+}
+
+EXPORT(sqInt) primInitializePath(void) {
+
+	/* drawable right. Will later be refined. */
+
+	spanLeft = targetWidth;
+
+	/* drawable bottom. Will later be refined. */
+
+	spanTop = targetHeight;
+
+	/* drawable left. Will later be refined. */
+
+	spanRight = 0;
+	spanBottom = 0;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	return null;
+}
+
+EXPORT(sqInt) primLine(void) {
+	float x;
+	sqInt h;
+	float y;
+	double xFrom;
+	double yFrom;
+	double xTo;
+	double yTo;
+	sqInt hops;
+	double incrementX;
+	double incrementY;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+
+	xFrom = interpreterProxy->stackFloatValue(8);
+	yFrom = interpreterProxy->stackFloatValue(7);
+	xTo = interpreterProxy->stackFloatValue(6);
+	yTo = interpreterProxy->stackFloatValue(5);
+	hops = interpreterProxy->stackIntegerValue(4);
+	incrementX = interpreterProxy->stackFloatValue(3);
+	incrementY = interpreterProxy->stackFloatValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	spanLeft = ((spanLeft < (((xFrom < xTo) ? xFrom : xTo))) ? spanLeft : (((xFrom < xTo) ? xFrom : xTo)));
+	spanRight = ((spanRight < (((xFrom < xTo) ? xTo : xFrom))) ? (((xFrom < xTo) ? xTo : xFrom)) : spanRight);
+	spanTop = ((spanTop < (((yFrom < yTo) ? yFrom : yTo))) ? spanTop : (((yFrom < yTo) ? yFrom : yTo)));
+	spanBottom = ((spanBottom < (((yFrom < yTo) ? yTo : yFrom))) ? (((yFrom < yTo) ? yTo : yFrom)) : spanBottom);
+	x = xFrom;
+	y = yFrom;
+	for (h = 1; h <= hops; h += 1) {
+		updateAlphasForXy(x, y);
+		if (!(fillA == 0.0)) {
+			updateEdgeCountAtXy(x, y);
+		}
+		x += incrementX;
+		y += incrementY;
+	}
+	updateAlphasForXy(xTo, yTo);
+	if (!(fillA == 0.0)) {
+		updateEdgeCountAtXy(xTo, yTo);
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(9);
+	return null;
+}
+
+EXPORT(sqInt) primNewTrajectoryFragment(void) {
+	prevYTruncated = 0x7FFFFFFFU;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	return null;
+}
+
+EXPORT(sqInt) primQuadraticBezier(void) {
+	float yMaxEnd;
+	float oneLessT;
+	float increment;
+	float xMaxEnd;
+	float t;
+	float yMinEnd;
+	float f1;
+	float x;
+	sqInt h;
+	float f3;
+	float xMinEnd;
+	float f2;
+	float y;
+	double xFrom;
+	double yFrom;
+	double xTo;
+	double yTo;
+	double xControl;
+	double yControl;
+	sqInt hops;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+
+	xFrom = interpreterProxy->stackFloatValue(8);
+	yFrom = interpreterProxy->stackFloatValue(7);
+	xTo = interpreterProxy->stackFloatValue(6);
+	yTo = interpreterProxy->stackFloatValue(5);
+	xControl = interpreterProxy->stackFloatValue(4);
+	yControl = interpreterProxy->stackFloatValue(3);
+	hops = interpreterProxy->stackIntegerValue(2);
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(0)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	edgeCounts = otherWordArray;
+
+	/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
+
+	alphaMask = anotherWordArray;
+	xMinEnd = ((xFrom < xTo) ? xFrom : xTo);
+	xMaxEnd = ((xFrom < xTo) ? xTo : xFrom);
+	yMinEnd = ((yFrom < yTo) ? yFrom : yTo);
+	yMaxEnd = ((yFrom < yTo) ? yTo : yFrom);
+	spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + xControl) / 2.0)) ? xMinEnd : ((xMinEnd + xControl) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + xControl) / 2.0)) ? xMinEnd : ((xMinEnd + xControl) / 2.0))));
+	spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + xControl) / 2.0)) ? ((xMaxEnd + xControl) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + xControl) / 2.0)) ? ((xMaxEnd + xControl) / 2.0) : xMaxEnd)) : spanRight);
+	spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + yControl) / 2.0)) ? yMinEnd : ((yMinEnd + yControl) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + yControl) / 2.0)) ? yMinEnd : ((yMinEnd + yControl) / 2.0))));
+	spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + yControl) / 2.0)) ? ((yMaxEnd + yControl) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + yControl) / 2.0)) ? ((yMaxEnd + yControl) / 2.0) : yMaxEnd)) : spanBottom);
+	t = 0.0;
+	increment = 1.0 / hops;
+	for (h = 1; h <= hops; h += 1) {
+		oneLessT = 1.0 - t;
+		f1 = oneLessT * oneLessT;
+		f2 = (2.0 * oneLessT) * t;
+		f3 = t * t;
+		x = ((f1 * xFrom) + (f2 * xControl)) + (f3 * xTo);
+		y = ((f1 * yFrom) + (f2 * yControl)) + (f3 * yTo);
+		updateAlphasForXy(x, y);
+		if (!(fillA == 0.0)) {
+			updateEdgeCountAtXy(x, y);
+		}
+		t += increment;
+	}
+	updateAlphasForXy(xTo, yTo);
+	if (!(fillA == 0.0)) {
+		updateEdgeCountAtXy(xTo, yTo);
+	}
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(9);
+	return null;
+}
+
+
+/*	Note: This is coded so that is can be run from Squeak. */
+
+EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter) {
+	sqInt ok;
+
+	interpreterProxy = anInterpreter;
+	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
+	if (ok == 0) {
+		return 0;
+	}
+	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
+	return ok;
+}
+
+EXPORT(sqInt) primSpanBottom(void) {
+	sqInt _return_value;
+
+	_return_value = interpreterProxy->integerObjectOf((((sqInt)(spanBottom + auxStrokeWidthDilatedHalf))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(1, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primSpanLeft(void) {
+	sqInt _return_value;
+
+	_return_value = interpreterProxy->integerObjectOf((((sqInt)(((spanLeft - auxStrokeWidthDilatedHalf) - subPixelDelta) + 1))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(1, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primSpanRight(void) {
+	sqInt _return_value;
+
+	_return_value = interpreterProxy->integerObjectOf(((((sqInt)((spanRight + auxStrokeWidthDilatedHalf) + subPixelDelta))) + 1));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(1, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primSpanTop(void) {
+	sqInt _return_value;
+
+	_return_value = interpreterProxy->integerObjectOf((((sqInt)((spanTop - auxStrokeWidthDilatedHalf) + 1))));
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->popthenPush(1, _return_value);
+	return null;
+}
+
+EXPORT(sqInt) primStrokeRGBA(void) {
+	double r;
+	double g;
+	double b;
+	double a;
+
+	r = interpreterProxy->stackFloatValue(3);
+	g = interpreterProxy->stackFloatValue(2);
+	b = interpreterProxy->stackFloatValue(1);
+	a = interpreterProxy->stackFloatValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	strokeR = r;
+	strokeG = g;
+	strokeB = b;
+	strokeA = a;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(4);
+	return null;
+}
+
+EXPORT(sqInt) primStrokeWidth(void) {
+	float swErodedHalf;
+	double aNumber;
+
+	aNumber = interpreterProxy->stackFloatValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	strokeWidth = aNumber;
+	auxStrokeWidthDilatedHalf = (strokeWidth + antiAliasingWidth) * 0.5;
+	auxStrokeWidthDilatedHalfSquared = auxStrokeWidthDilatedHalf * auxStrokeWidthDilatedHalf;
+	swErodedHalf = (strokeWidth - antiAliasingWidth) * 0.5;
+	auxStrokeWidthErodedHalfSquared = swErodedHalf * fabs(swErodedHalf);;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(1);
+	return null;
+}
+
+
+/*	All arrays could be pinned instead of passing them every time! */
+
+EXPORT(sqInt) primSetTarget(void) {
+	unsigned *aBitmap;
+	unsigned *aWordArray;
+	unsigned *otherWordArray;
+	unsigned *anotherWordArray;
+	sqInt aNumber;
+	sqInt otherNumber;
+
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(5)));
+	aBitmap = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(5))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(4)));
+	aWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(4))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(3)));
+	otherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(3))));
+	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(2)));
+	anotherWordArray = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
+	aNumber = interpreterProxy->stackIntegerValue(1);
+	otherNumber = interpreterProxy->stackIntegerValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	targetBits = aBitmap;
+	morphIds = aWordArray;
+	edgeCounts = otherWordArray;
+	alphaMask = anotherWordArray;
+	targetWidth = aNumber;
+	targetHeight = otherNumber;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(6);
+	return null;
+}
+
+EXPORT(sqInt) primTextTxSet(void) {
+	double a11;
+	double a12;
+	double a13;
+	double a21;
+	double a22;
+	double a23;
+
+	a11 = interpreterProxy->stackFloatValue(5);
+	a12 = interpreterProxy->stackFloatValue(4);
+	a13 = interpreterProxy->stackFloatValue(3);
+	a21 = interpreterProxy->stackFloatValue(2);
+	a22 = interpreterProxy->stackFloatValue(1);
+	a23 = interpreterProxy->stackFloatValue(0);
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	textTxA11 = a11;
+	textTxA12 = a12;
+	textTxA13 = a13;
+	textTxA21 = a21;
+	textTxA22 = a22;
+	textTxA23 = a23;
+	if (interpreterProxy->failed()) {
+		return null;
+	}
+	interpreterProxy->pop(6);
+	return null;
+}
+
+
+/*	slight optimization possible when we know width = 0... perhaps implement:
+		-we know palpha is never 127
+		- we know distanceToEdge is always > erodedHalfWidth.
+	In smalltalk, performance icrease 1.5%. Perhaps in c/asm it is more than that...
+	Mas importante:
+		Cuando width es medio grande, entonces dibujar la bolita rellena de entrada es importante... en los casos en que no necesito calcular la distancia */
+
+static sqInt updateAlphasForXy(float x, float y) {
+	uint32_t redAlpha;
+	uint32_t candidateAlpha;
+	sqInt pixelIndex;
+	sqInt b;
+	sqInt r;
+	sqInt t;
+	float distanceToAxisSquared;
+	sqInt displayX;
+	float dx;
+	float dxSquared;
+	uint32_t greenAlpha;
+	uint32_t alphaWord;
+	uint32_t blueAlpha;
+	float dxp;
+	sqInt doUpdate;
+	sqInt l;
+	float dySquared;
+	sqInt displayY;
+	float dy;
+
+
+	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
+
+	t = ((sqInt)((y - auxStrokeWidthDilatedHalf) + 1));
+	if (t < clipTop) {
+		t = clipTop;
+	}
+	b = ((sqInt)(y + auxStrokeWidthDilatedHalf));
+	if (b > clipBottom) {
+		b = clipBottom;
+	}
+
+	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
+
+	l = ((sqInt)(((x - auxStrokeWidthDilatedHalf) - subPixelDelta) + 1));
+	if (l < clipLeft) {
+		l = clipLeft;
+	}
+	r = ((sqInt)((x + auxStrokeWidthDilatedHalf) + subPixelDelta));
+	if (r > clipRight) {
+		r = clipRight;
+	}
+	for (displayY = t; displayY <= b; displayY += 1) {
+		pixelIndex = ((displayY * targetWidth) + l) - 1;
+		for (displayX = l; displayX <= r; displayX += 1) {
+			pixelIndex += 1;
+			alphaWord = alphaMask[pixelIndex];
+			if (!(alphaWord == 8355711)) {
+				redAlpha = alphaWord & 0x7F0000;
+				greenAlpha = alphaWord & 0x7F00;
+				blueAlpha = alphaWord & 0x7F;
+				doUpdate = 0;
+				dy = displayY - y;
+				dySquared = dy * dy;
+
+				/* Red */
+
+				dx = displayX - x;
+				dxp = dx - subPixelDelta;
+				dxSquared = dxp * dxp;
+				distanceToAxisSquared = dxSquared + dySquared;
+				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
+					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
+						candidateAlpha = 0x7F0000;
+					} else {
+						
+										candidateAlpha = (uint32_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
+										candidateAlpha = candidateAlpha << 16;;
+					}
+					if (candidateAlpha > redAlpha) {
+						doUpdate = 1;
+						redAlpha = candidateAlpha;
+					}
+				}
+				dxSquared = dx * dx;
+				distanceToAxisSquared = dxSquared + dySquared;
+				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
+					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
+						candidateAlpha = 0x7F00;
+					} else {
+						
+										candidateAlpha = (uint32_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
+										candidateAlpha = candidateAlpha << 8;;
+					}
+					if (candidateAlpha > greenAlpha) {
+						doUpdate = 1;
+						greenAlpha = candidateAlpha;
+					}
+				}
+				dxp = dx + subPixelDelta;
+				dxSquared = dxp * dxp;
+				distanceToAxisSquared = dxSquared + dySquared;
+				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
+					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
+						candidateAlpha = 0x7F;
+					} else {
+						
+										candidateAlpha = (uint32_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);;
+					}
+					if (candidateAlpha > blueAlpha) {
+						doUpdate = 1;
+						blueAlpha = candidateAlpha;
+					}
+				}
+				if (doUpdate) {
+					alphaWord = (redAlpha | greenAlpha) | blueAlpha;
+					alphaMask[pixelIndex] = alphaWord;
+				}
+			}
+		}
+	}
+	return null;
+}
+
+
+/*	Compute edges intersecting with this horizontal line, for fills. */
+
+static sqInt updateEdgeCountAtXy(float x, float y) {
+	sqInt greenOffset;
+	uint32_t greenIncrement;
+	uint32_t blueCount;
+	sqInt pixelY;
+	sqInt bluePixelIndex;
+	sqInt redPixelIndex;
+	sqInt greenPixelIndex;
+	uint32_t countWord;
+	sqInt rest;
+	sqInt blueOffset;
+	uint32_t greenCount;
+	uint32_t blueIncrement;
+	sqInt redOffset;
+	sqInt pixelIndexBase;
+	uint32_t redIncrement;
+	sqInt thisYTruncated;
+	uint32_t redCount;
+
+
+	/* truncated, both in C and Smalltalk */
+
+	thisYTruncated = ((sqInt)y);
+	if (thisYTruncated == prevYTruncated) {
+		return 0;
+	}
+	if (!(((thisYTruncated >= (clipTop - 1)) && (thisYTruncated <= clipBottom)))) {
+		return 0;
+	}
+	if (prevYTruncated == 0x7FFFFFFFU) {
+		prevYTruncated = thisYTruncated;
+		return 0;
+	}
+	if (thisYTruncated > prevYTruncated) {
+		pixelY = thisYTruncated;
+		redIncrement = 65536;
+		greenIncrement = 256;
+		blueIncrement = 1;
+	} else {
+		pixelY = prevYTruncated;
+		redIncrement = 0xFF0000;
+		greenIncrement = 0xFF00;
+		blueIncrement = 0xFF;
+	}
+
+	/* All edge count at the left of the clipRect are added there (at the left of the clipRect).
+	The effect is the same, and we need to clean up less stuff afterwards.
+	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses. */
+
+	prevYTruncated = thisYTruncated;
+	pixelIndexBase = pixelY * targetWidth;
+
+	/* take the next red subpixel center to the right of x */
+
+	redOffset = (((((sqInt)((x + subPixelDelta) + 1))) < clipLeft) ? clipLeft : (((sqInt)((x + subPixelDelta) + 1))));
+
+	/* take the next green  subpixel center to the right of x */
+
+	greenOffset = (((((sqInt)(x + 1))) < clipLeft) ? clipLeft : (((sqInt)(x + 1))));
+
+	/* take the next blue subpixel center to the right of x */
+
+	blueOffset = (((((sqInt)((x - subPixelDelta) + 1))) < clipLeft) ? clipLeft : (((sqInt)((x - subPixelDelta) + 1))));
+	redPixelIndex = pixelIndexBase + redOffset;
+	greenPixelIndex = pixelIndexBase + greenOffset;
+
+	/* Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another */
+
+	bluePixelIndex = pixelIndexBase + blueOffset;
+	if (redPixelIndex == bluePixelIndex) {
+
+		/* First case: RGB in the same word */
+
+		if (redOffset <= clipRight) {
+			countWord = edgeCounts[redPixelIndex];
+			redCount = (countWord + redIncrement) & 0xFF0000;
+			greenCount = (countWord + greenIncrement) & 0xFF00;
+			blueCount = (countWord + blueIncrement) & 0xFF;
+			countWord = (redCount | greenCount) | blueCount;
+			edgeCounts[redPixelIndex] = countWord;
+		}
+	} else {
+		if (redPixelIndex == greenPixelIndex) {
+
+			/* Second case: RG in one word, B in previous */
+
+			if (redOffset <= clipRight) {
+				countWord = edgeCounts[redPixelIndex];
+				redCount = (countWord + redIncrement) & 0xFF0000;
+				greenCount = (countWord + greenIncrement) & 0xFF00;
+				rest = countWord & 0xFF;
+				countWord = (redCount | greenCount) | rest;
+				edgeCounts[redPixelIndex] = countWord;
+			}
+			if (blueOffset <= clipRight) {
+				countWord = edgeCounts[bluePixelIndex];
+				rest = countWord & 0xFFFF00;
+				blueCount = (countWord + blueIncrement) & 0xFF;
+				countWord = rest | blueCount;
+				edgeCounts[bluePixelIndex] = countWord;
+			}
+		} else {
+
+			/* Third case: R in one word, GB in the previous */
+
+			if (redOffset <= clipRight) {
+				countWord = edgeCounts[redPixelIndex];
+				redCount = (countWord + redIncrement) & 0xFF0000;
+				rest = countWord & 0xFFFF;
+				countWord = redCount | rest;
+				edgeCounts[redPixelIndex] = countWord;
+			}
+			if (blueOffset <= clipRight) {
+				countWord = edgeCounts[bluePixelIndex];
+				rest = countWord & 0xFF0000;
+				greenCount = (countWord + greenIncrement) & 0xFF00;
+				blueCount = (countWord + blueIncrement) & 0xFF;
+				countWord = (rest | greenCount) | blueCount;
+				edgeCounts[bluePixelIndex] = countWord;
+			}
+		}
+	}
+	return null;
+}
+
+
+#ifdef SQUEAK_BUILTIN_PLUGIN
+
+
+void* VectorEnginePlugin_exports[][3] = {
+	{"VectorEnginePlugin", "primSetTarget", (void*)primSetTarget},
+	{"VectorEnginePlugin", "primDisplayUtf8", (void*)primDisplayUtf8},
+	{"VectorEnginePlugin", "primSpanLeft", (void*)primSpanLeft},
+	{"VectorEnginePlugin", "primLine", (void*)primLine},
+	{"VectorEnginePlugin", "primDisplayUtf32", (void*)primDisplayUtf32},
+	{"VectorEnginePlugin", "primArc", (void*)primArc},
+	{"VectorEnginePlugin", "primSpanBottom", (void*)primSpanBottom},
+	{"VectorEnginePlugin", "primClipLeftclipTopclipRightclipBottom", (void*)primClipLeftclipTopclipRightclipBottom},
+	{"VectorEnginePlugin", "primClipCurrentMorph", (void*)primClipCurrentMorph},
+	{"VectorEnginePlugin", "primCubicBezier", (void*)primCubicBezier},
+	{"VectorEnginePlugin", "primInitializePath", (void*)primInitializePath},
+	{"VectorEnginePlugin", "primStrokeRGBA", (void*)primStrokeRGBA},
+	{"VectorEnginePlugin", "primQuadraticBezier", (void*)primQuadraticBezier},
+	{"VectorEnginePlugin", "primSpanRight", (void*)primSpanRight},
+	{"VectorEnginePlugin", "primAntiAliasingWidthsubPixelDelta", (void*)primAntiAliasingWidthsubPixelDelta},
+	{"VectorEnginePlugin", "primStrokeWidth", (void*)primStrokeWidth},
+	{"VectorEnginePlugin", "primNewTrajectoryFragment", (void*)primNewTrajectoryFragment},
+	{"VectorEnginePlugin", "primBlendStrokeOnly", (void*)primBlendStrokeOnly},
+	{"VectorEnginePlugin", "primTextTxSet", (void*)primTextTxSet},
+	{"VectorEnginePlugin", "primSpanTop", (void*)primSpanTop},
+	{"VectorEnginePlugin", "primFillRGBA", (void*)primFillRGBA},
+	{"VectorEnginePlugin", "getModuleName", (void*)getModuleName},
+	{"VectorEnginePlugin", "setInterpreter", (void*)setInterpreter},
+	{"VectorEnginePlugin", "primBlendFillOnly", (void*)primBlendFillOnly},
+	{"VectorEnginePlugin", "primBlendStrokeAndFill", (void*)primBlendStrokeAndFill},
+	{"VectorEnginePlugin", "primDisplayString", (void*)primDisplayString},
+	{"VectorEnginePlugin", "primCurrentMorphIdcurrentClipsSubmorphs", (void*)primCurrentMorphIdcurrentClipsSubmorphs},
+	{NULL, NULL, NULL}
+};
+
+
+#endif /* ifdef SQ_BUILTIN_PLUGIN */
+
