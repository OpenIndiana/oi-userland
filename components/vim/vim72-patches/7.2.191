To: vim-dev@vim.org
Subject: Patch 7.2.191
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.191
Problem:    Mzscheme interface doesn't work on Ubuntu.
Solution:   Change autoconf rules.  Define missing macro.  Some changes to
	    avoid gcc warnings.  Remove per-buffer namespace. (Sergey Khorev)
Files:	    runtime/doc/if_mzsch.txt, src/Makefile, src/Make_ming.mak,
	    src/Make_mvc.mak, src/auto/configure, src/configure.in,
	    src/config.mk.in, src/eval.c, src/if_mzsch.c, src/if_mzsch.h,
	    src/main.c, src/proto/if_mzsch.pro


*** ../vim-7.2.190/runtime/doc/if_mzsch.txt	2008-08-09 19:36:48.000000000 +0200
--- runtime/doc/if_mzsch.txt	2009-05-26 18:49:53.000000000 +0200
***************
*** 1,4 ****
! *if_mzsch.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
  
  
  		  VIM REFERENCE MANUAL    by Sergey Khorev
--- 1,4 ----
! *if_mzsch.txt*  For Vim version 7.2.  Last change: 2009 May 26
  
  
  		  VIM REFERENCE MANUAL    by Sergey Khorev
***************
*** 42,51 ****
  
  							*:mzfile* *:mzf*
  :[range]mzf[ile] {file}	Execute the MzScheme script in {file}.  {not in Vi}
- 			All statements are executed in the namespace of the
- 			buffer that was current during :mzfile start.
- 			If you want to access other namespaces, use
- 			'parameterize'.
  
  All of these commands do essentially the same thing - they execute a piece of
  MzScheme code, with the "current range" set to the given line
--- 42,47 ----
***************
*** 54,61 ****
  In the case of :mzscheme, the code to execute is in the command-line.
  In the case of :mzfile, the code to execute is the contents of the given file.
  
- Each buffer has its own MzScheme namespace. Global namespace is bound to
- the "global-namespace" value from the 'vimext' module.
  MzScheme interface defines exception exn:vim, derived from exn.
  It is raised for various Vim errors.
  
--- 50,55 ----
***************
*** 79,118 ****
  e.g.: >
  	:mzscheme (require (prefix vim- vimext))
  <
! All the examples below assume this naming scheme.  Note that you need to do
! this again for every buffer.
  
- The auto-instantiation can be achieved with autocommands, e.g. you can put
- something like this in your .vimrc (EOFs should not have indentation): >
-     function s:MzRequire()
- 	if has("mzscheme")
- 	    :mz << EOF
- 	    (require (prefix vim- vimext))
- 	    (let ((buf (vim-get-buff-by-name (vim-eval "expand(\"<afile>\")"))))
- 	      (when (and buf (not (eq? buf (vim-curr-buff))))
- 		(parameterize ((current-namespace (vim-get-buff-namespace buf)))
- 		  (namespace-attach-module vim-global-namespace 'vimext)
- 		  (namespace-require '(prefix vim vimext)))))
-     EOF
- 	endif
-     endfunction
- 
-     function s:MzStartup()
- 	if has("mzscheme")
- 	    au BufNew,BufNewFile,BufAdd,BufReadPre * :call s:MzRequire()
- 	    :mz << EOF
- 	    (current-library-collection-paths
- 		(cons
- 		    (build-path (find-system-path 'addon-dir) (version) "collects")
- 		    (current-library-collection-paths)))
-     EOF
- 	endif
-     endfunction
- 
-     call s:MzStartup()
- <
- 
- The global namespace just instantiated this module with the prefix "vimext:".
  							*mzscheme-sandbox*
  When executed in the |sandbox|, access to some filesystem and Vim interface
  procedures is restricted.
--- 73,80 ----
  e.g.: >
  	:mzscheme (require (prefix vim- vimext))
  <
! All the examples below assume this naming scheme. 
  
  							*mzscheme-sandbox*
  When executed in the |sandbox|, access to some filesystem and Vim interface
  procedures is restricted.
***************
*** 121,135 ****
  2. Examples						*mzscheme-examples*
  >
  	:mzscheme (display "Hello")
  	:mzscheme (vim-set-buff-line 10 "This is line #10")
  <
  Inline script usage: >
  	function! <SID>SetFirstLine()
  	    :mz << EOF
  	    (display "!!!")
  	    (vim-set-buff-line 1 "This is line #1")
  	    (vim-beep)
! 	    EOF
  	endfunction
  
  	nmap <F9> :call <SID>SetFirstLine() <CR>
--- 83,102 ----
  2. Examples						*mzscheme-examples*
  >
  	:mzscheme (display "Hello")
+ 	:mz (display (string-append "Using MzScheme version " (version)))
+ 	:mzscheme (require (prefix vim- vimext)) ; for MzScheme < 4.x
+ 	:mzscheme (require (prefix-in vim- 'vimext)) ; MzScheme 4.x
  	:mzscheme (vim-set-buff-line 10 "This is line #10")
  <
  Inline script usage: >
  	function! <SID>SetFirstLine()
  	    :mz << EOF
  	    (display "!!!")
+ 	    (require (prefix vim- vimext))
+ 	    ; for newer versions (require (prefix-in vim- 'vimext))
  	    (vim-set-buff-line 1 "This is line #1")
  	    (vim-beep)
! 	EOF
  	endfunction
  
  	nmap <F9> :call <SID>SetFirstLine() <CR>
***************
*** 137,153 ****
  File execution: >
  	:mzfile supascript.scm
  <
! Accessing the current buffer namespace from an MzScheme program running in
! another buffer within |:mzfile|-executed script : >
! 	; Move to the window below
! 	(vim-command "wincmd j")
! 	; execute in the context of buffer, to which window belongs
! 	; assume that buffer has 'textstring' defined
! 	(parameterize ((current-namespace
! 			(vim-get-buff-namespace (vim-curr-buff))))
! 	 (eval '(vim-set-buff-line 1 textstring)))
! <
  
  ==============================================================================
  3. Threads						*mzscheme-threads*
  
--- 104,136 ----
  File execution: >
  	:mzfile supascript.scm
  <
! Vim exception handling: >
! 	:mz << EOF
! 	(require (prefix vim- vimext))
! 	; for newer versions (require (prefix-in vim- 'vimext))
! 	(with-handlers
! 	  ([exn:vim? (lambda (e) (display (exn-message e)))])
! 	  (vim-eval "nonsense-string"))
! 	EOF
! <
! Auto-instantiation of vimext module (can be placed in your |vimrc|): >
!     function! MzRequire()
! 	:redir => l:mzversion
! 	:mz (version)
! 	:redir END
! 	if strpart(l:mzversion, 1, 1) < "4"
! 	    " MzScheme versions < 4.x:
! 	    :mz (require (prefix vim- vimext))
! 	else
! 	    " newer versions:
! 	    :mz (require (prefix-in vim- 'vimext))
! 	endif
!     endfunction
  
+     if has("mzscheme")
+ 	silent call MzRequire()
+     endif
+ <
  ==============================================================================
  3. Threads						*mzscheme-threads*
  
***************
*** 168,178 ****
  Common
  ------
      (command {command-string})	    Perform the vim ":Ex" style command.
!     (eval {expr-string})	    Evaluate the vim expression to a string.
! 				    A |List| is turned into a string by
! 				    joining the items and inserting line
! 				    breaks.
! 				    NOTE clashes with MzScheme eval
      (range-start)		    Start/End of the range passed with
      (range-end)			    the Scheme command.
      (beep)			    beep
--- 151,161 ----
  Common
  ------
      (command {command-string})	    Perform the vim ":Ex" style command.
!     (eval {expr-string})	    Evaluate the vim expression into
! 				    respective MzScheme object: |Lists| are
! 				    represented as Scheme lists,
! 				    |Dictionaries| as hash tables.
! 				    NOTE the name clashes with MzScheme eval
      (range-start)		    Start/End of the range passed with
      (range-end)			    the Scheme command.
      (beep)			    beep
***************
*** 186,192 ****
  				    be set. The symbol 'global can be passed
  				    as {buffer-or-window}. Then |:setglobal|
  				    will be used.
-     global-namespace		    The MzScheme main namespace.
  
  Buffers							 *mzscheme-buffer*
  -------
--- 169,174 ----
***************
*** 228,234 ****
  					if there is no such buffer.
      (get-buff-by-num {buffernum})   Get a buffer by its number (return #f if
  				    there is no buffer with this number).
-     (get-buff-namespace [buffer])   Get buffer namespace.
  
  Windows							    *mzscheme-window*
  ------
--- 210,215 ----
***************
*** 250,256 ****
      (set-cursor (line . col) [window])  Set cursor position.
  
  ==============================================================================
! 5. Dynamic loading					*mzscheme-dynamic*
  
  On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
  output then includes |+mzscheme/dyn|.
--- 231,237 ----
      (set-cursor (line . col) [window])  Set cursor position.
  
  ==============================================================================
! 5. Dynamic loading				    *mzscheme-dynamic* *E812*
  
  On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
  output then includes |+mzscheme/dyn|.
*** ../vim-7.2.190/src/Makefile	2009-05-26 18:12:19.000000000 +0200
--- src/Makefile	2009-05-26 22:54:48.000000000 +0200
***************
*** 536,542 ****
  # Use this with GCC to check for mistakes, unused arguments, etc.
  #CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
  #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
! #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code
  
  # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
  # allocated memory (and makes every malloc()/free() very slow).
--- 536,542 ----
  # Use this with GCC to check for mistakes, unused arguments, etc.
  #CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
  #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
! #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
  
  # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
  # allocated memory (and makes every malloc()/free() very slow).
***************
*** 2200,2205 ****
--- 2200,2206 ----
  	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c
  	-rm -f conftest* *~ auto/link.sed
  	-rm -rf $(APPDIR)
+ 	-rm -rf mzscheme_base.c
  	if test -d $(PODIR); then \
  		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
  	fi
***************
*** 2433,2440 ****
  objects/if_xcmdsrv.o: if_xcmdsrv.c
  	$(CCC) -o $@ if_xcmdsrv.c
  
! objects/if_mzsch.o: if_mzsch.c
  	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
  
  objects/if_perl.o: auto/if_perl.c
  	$(CCC) -o $@ auto/if_perl.c
--- 2434,2444 ----
  objects/if_xcmdsrv.o: if_xcmdsrv.c
  	$(CCC) -o $@ if_xcmdsrv.c
  
! objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
  	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
+  
+ mzscheme_base.c:
+ 	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
  
  objects/if_perl.o: auto/if_perl.c
  	$(CCC) -o $@ auto/if_perl.c
*** ../vim-7.2.190/src/auto/configure	2009-05-21 23:25:38.000000000 +0200
--- src/auto/configure	2009-05-26 19:12:29.000000000 +0200
***************
*** 701,706 ****
--- 701,708 ----
  shrpenv
  vi_cv_perllib
  vi_cv_path_perl
+ MZSCHEME_MZC
+ MZSCHEME_EXTRA
  MZSCHEME_CFLAGS
  MZSCHEME_LIBS
  MZSCHEME_PRO
***************
*** 4641,4648 ****
  $as_echo "\"$PLTHOME\"" >&6; }
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	{ $as_echo "$as_me:$LINENO: result: \"not set\"" >&5
! $as_echo "\"not set\"" >&6; }
  		# Extract the first word of "mzscheme", so it can be a program name with args.
  set dummy mzscheme; ac_word=$2
  { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
--- 4643,4650 ----
  $as_echo "\"$PLTHOME\"" >&6; }
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	{ $as_echo "$as_me:$LINENO: result: not set" >&5
! $as_echo "not set" >&6; }
  		# Extract the first word of "mzscheme", so it can be a program name with args.
  set dummy mzscheme; ac_word=$2
  { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
***************
*** 4697,4712 ****
  if test "${vi_cv_path_mzscheme_pfx+set}" = set; then
    $as_echo_n "(cached) " >&6
  else
!    vi_cv_path_mzscheme_pfx=`
! 	    ${vi_cv_path_mzscheme} -evm \
! 	    "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))"`
  fi
  { $as_echo "$as_me:$LINENO: result: $vi_cv_path_mzscheme_pfx" >&5
  $as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
! 	    	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
  	fi
      fi
    fi
--- 4699,4714 ----
  if test "${vi_cv_path_mzscheme_pfx+set}" = set; then
    $as_echo_n "(cached) " >&6
  else
!   	    	    echo "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
! 	    	     vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
! 		sed -e 's+/$++'`
  fi
  { $as_echo "$as_me:$LINENO: result: $vi_cv_path_mzscheme_pfx" >&5
  $as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
! 	    rm -f mzdirs.scm
  	fi
      fi
    fi
***************
*** 4716,4736 ****
      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
  $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       { $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
! $as_echo "\"yes\"" >&6; }
      else
!       { $as_echo "$as_me:$LINENO: result: \"no\"" >&5
! $as_echo "\"no\"" >&6; }
!       { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include" >&5
! $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include... " >&6; }
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	{ $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
! $as_echo "\"yes\"" >&6; }
! 	SCHEME_INC=/plt
        else
! 	{ $as_echo "$as_me:$LINENO: result: \"no\"" >&5
! $as_echo "\"no\"" >&6; }
! 	vi_cv_path_mzscheme_pfx=
        fi
      fi
    fi
--- 4718,4749 ----
      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
  $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
!       { $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
      else
!       { $as_echo "$as_me:$LINENO: result: no" >&5
! $as_echo "no" >&6; }
!       { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt" >&5
! $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt... " >&6; }
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	{ $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
! 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
        else
! 	{ $as_echo "$as_me:$LINENO: result: no" >&5
! $as_echo "no" >&6; }
! 	{ $as_echo "$as_me:$LINENO: checking if scheme.h can be found in /usr/include/plt/" >&5
! $as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
! 	if test -f /usr/include/plt/scheme.h; then
! 	  { $as_echo "$as_me:$LINENO: result: yes" >&5
! $as_echo "yes" >&6; }
! 	  SCHEME_INC=/usr/include/plt
! 	else
! 	  { $as_echo "$as_me:$LINENO: result: no" >&5
! $as_echo "no" >&6; }
! 	  vi_cv_path_mzscheme_pfx=
! 	fi
        fi
      fi
    fi
***************
*** 4738,4758 ****
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!       MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
        if test "$GCC" = yes; then
! 			MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
--- 4751,4784 ----
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
+     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!             if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
! 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
!       else
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
!       fi
        if test "$GCC" = yes; then
! 			MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
!             MZSCHEME_EXTRA="mzscheme_base.c"
!       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
!       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
!     fi
!     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
***************
*** 4767,4772 ****
--- 4793,4800 ----
  
  
  
+ 
+ 
  fi
  
  
*** ../vim-7.2.190/src/configure.in	2009-05-21 23:25:38.000000000 +0200
--- src/configure.in	2009-05-26 18:57:35.000000000 +0200
***************
*** 414,420 ****
  	AC_MSG_RESULT("$PLTHOME")
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	AC_MSG_RESULT("not set")
  	dnl -- try to find MzScheme executable
  	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
  
--- 414,420 ----
  	AC_MSG_RESULT("$PLTHOME")
  	vi_cv_path_mzscheme_pfx="$PLTHOME"
      else
! 	AC_MSG_RESULT(not set)
  	dnl -- try to find MzScheme executable
  	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
  
***************
*** 430,443 ****
  	if test "X$vi_cv_path_mzscheme" != "X"; then
  	    dnl -- find where MzScheme thinks it was installed
  	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
! 	    [ vi_cv_path_mzscheme_pfx=`
! 	    ${vi_cv_path_mzscheme} -evm \
! 	    "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))"` ])
! 	    dnl Remove a trailing slash.
! 	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
  	fi
      fi
    fi
--- 430,445 ----
  	if test "X$vi_cv_path_mzscheme" != "X"; then
  	    dnl -- find where MzScheme thinks it was installed
  	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
! 	    dnl different versions of MzScheme differ in command line processing
! 	    dnl use universal approach
! 	    echo "(display (simplify-path		\
  	       (build-path (call-with-values	\
  		(lambda () (split-path (find-system-path (quote exec-file)))) \
! 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
! 	    dnl Remove a trailing slash
! 	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
! 		sed -e 's+/$++'` ])
! 	    rm -f mzdirs.scm
  	fi
      fi
    fi
***************
*** 446,461 ****
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       AC_MSG_RESULT("yes")
      else
!       AC_MSG_RESULT("no")
!       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include)
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	AC_MSG_RESULT("yes")
! 	SCHEME_INC=/plt
        else
! 	AC_MSG_RESULT("no")
! 	vi_cv_path_mzscheme_pfx=
        fi
      fi
    fi
--- 448,471 ----
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
      if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
!       SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
!       AC_MSG_RESULT(yes)
      else
!       AC_MSG_RESULT(no)
!       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
        if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
! 	AC_MSG_RESULT(yes)
! 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
        else
! 	AC_MSG_RESULT(no)
! 	AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
! 	if test -f /usr/include/plt/scheme.h; then
! 	  AC_MSG_RESULT(yes)
! 	  SCHEME_INC=/usr/include/plt
! 	else
! 	  AC_MSG_RESULT(no)
! 	  vi_cv_path_mzscheme_pfx=
! 	fi
        fi
      fi
    fi
***************
*** 463,485 ****
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!       MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
        if test "$GCC" = yes; then
  	dnl Make Vim remember the path to the library.  For when it's not in
  	dnl $LD_LIBRARY_PATH.
! 	MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
--- 473,510 ----
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
      if test "x$MACOSX" = "xyes"; then
        MZSCHEME_LIBS="-framework PLT_MzScheme"
+     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
!       dnl Using shared objects
!       if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
! 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
!       else
!         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
!       fi
        if test "$GCC" = yes; then
  	dnl Make Vim remember the path to the library.  For when it's not in
  	dnl $LD_LIBRARY_PATH.
! 	MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
        elif test "`(uname) 2>/dev/null`" = SunOS &&
  			       uname -r | grep '^5' >/dev/null; then
! 	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
        fi
      fi
      if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
        SCHEME_COLLECTS=lib/plt/
      fi
!     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
!       dnl need to generate bytecode for MzScheme base
!       MZSCHEME_EXTRA="mzscheme_base.c"
!       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
!       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
!     fi
!     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
        -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
      MZSCHEME_SRC="if_mzsch.c"
      MZSCHEME_OBJ="objects/if_mzsch.o"
***************
*** 491,496 ****
--- 516,523 ----
    AC_SUBST(MZSCHEME_PRO)
    AC_SUBST(MZSCHEME_LIBS)
    AC_SUBST(MZSCHEME_CFLAGS)
+   AC_SUBST(MZSCHEME_EXTRA)
+   AC_SUBST(MZSCHEME_MZC)
  fi
  
  
*** ../vim-7.2.190/src/config.mk.in	2008-06-25 00:49:03.000000000 +0200
--- src/config.mk.in	2009-05-26 18:57:49.000000000 +0200
***************
*** 41,46 ****
--- 41,48 ----
  MZSCHEME_OBJ	= @MZSCHEME_OBJ@
  MZSCHEME_CFLAGS	= @MZSCHEME_CFLAGS@
  MZSCHEME_PRO	= @MZSCHEME_PRO@
+ MZSCHEME_EXTRA  = @MZSCHEME_EXTRA@
+ MZSCHEME_MZC	= @MZSCHEME_MZC@
  
  PERL		= @vi_cv_path_perl@
  PERLLIB		= @vi_cv_perllib@
*** ../vim-7.2.190/src/eval.c	2009-05-24 13:40:17.000000000 +0200
--- src/eval.c	2009-05-26 18:58:20.000000000 +0200
***************
*** 5866,5872 ****
      return item1 == NULL && item2 == NULL;
  }
  
! #if defined(FEAT_PYTHON) || defined(PROTO)
  /*
   * Return the dictitem that an entry in a hashtable points to.
   */
--- 5866,5872 ----
      return item1 == NULL && item2 == NULL;
  }
  
! #if defined(FEAT_PYTHON) || defined(FEAT_MZSCHEME) || defined(PROTO)
  /*
   * Return the dictitem that an entry in a hashtable points to.
   */
*** ../vim-7.2.190/src/if_mzsch.c	2009-05-17 16:23:20.000000000 +0200
--- src/if_mzsch.c	2009-05-26 19:24:18.000000000 +0200
***************
*** 4,9 ****
--- 4,11 ----
   * Original work by Brent Fulgham <bfulgham@debian.org>
   * (Based on lots of help from Matthew Flatt)
   *
+  * TODO Convert byte-strings to char strings?
+  *
   * This consists of six parts:
   * 1. MzScheme interpreter main program
   * 2. Routines that handle the external interface between MzScheme and
***************
*** 18,24 ****
   *    garbage collector will do it self
   * 2. Requires at least NORMAL features. I can't imagine why one may want
   *    to build with SMALL or TINY features but with MzScheme interface.
!  * 3. I don't use K&R-style functions. Anyway, MzScheme headers are ANSI.
   */
  
  #include "vim.h"
--- 20,26 ----
   *    garbage collector will do it self
   * 2. Requires at least NORMAL features. I can't imagine why one may want
   *    to build with SMALL or TINY features but with MzScheme interface.
!  * 3. I don't use K&R-style functions. Anyways, MzScheme headers are ANSI.
   */
  
  #include "vim.h"
***************
*** 29,42 ****
   * depend". */
  #if defined(FEAT_MZSCHEME) || defined(PROTO)
  
  /* Base data structures */
  #define SCHEME_VIMBUFFERP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)
  #define SCHEME_VIMWINDOWP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)
  
  typedef struct
  {
!     Scheme_Type	    tag;
!     Scheme_Env	    *env;
      buf_T	    *buf;
  } vim_mz_buffer;
  
--- 31,45 ----
   * depend". */
  #if defined(FEAT_MZSCHEME) || defined(PROTO)
  
+ #include <assert.h>
+ 
  /* Base data structures */
  #define SCHEME_VIMBUFFERP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)
  #define SCHEME_VIMWINDOWP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)
  
  typedef struct
  {
!     Scheme_Object   so;
      buf_T	    *buf;
  } vim_mz_buffer;
  
***************
*** 44,50 ****
  
  typedef struct
  {
!     Scheme_Type	    tag;
      win_T	    *win;
  } vim_mz_window;
  
--- 47,53 ----
  
  typedef struct
  {
!     Scheme_Object   so;
      win_T	    *win;
  } vim_mz_window;
  
***************
*** 67,85 ****
      Scheme_Object   *port;
  } Port_Info;
  
- /* info for closed prim */
- /*
-  * data have different means:
-  * for do_eval it is char*
-  * for do_apply is Apply_Onfo*
-  * for do_load is Port_Info*
-  */
- typedef struct
- {
-     void	*data;
-     Scheme_Env	*env;
- } Cmd_Info;
- 
  /* info for do_apply */
  typedef struct
  {
--- 70,75 ----
***************
*** 122,128 ****
  static Scheme_Object *insert_buffer_line_list(void *, int, Scheme_Object **);
  static Scheme_Object *get_range_start(void *, int, Scheme_Object **);
  static Scheme_Object *get_range_end(void *, int, Scheme_Object **);
- static Scheme_Object *get_buffer_namespace(void *, int, Scheme_Object **);
  static vim_mz_buffer *get_vim_curr_buffer(void);
  
  /*  Window-related commands */
--- 112,117 ----
***************
*** 163,170 ****
  static int do_mzscheme_command(exarg_T *, void *, Scheme_Closed_Prim *what);
  static void startup_mzscheme(void);
  static char *string_to_line(Scheme_Object *obj);
- static int mzscheme_io_init(void);
- static void mzscheme_interface_init(vim_mz_buffer *self);
  static void do_output(char *mesg, long len);
  static void do_printf(char *format, ...);
  static void do_flush(void);
--- 152,157 ----
***************
*** 174,192 ****
  static Scheme_Object *do_eval(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_load(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_apply(void *, int noargc, Scheme_Object **noargv);
! static void register_vim_exn(Scheme_Env *env);
  static vim_mz_buffer *get_buffer_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
  static vim_mz_window *get_window_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
- static void add_vim_exn(Scheme_Env *env);
  static int line_in_range(linenr_T, buf_T *);
  static void check_line_range(linenr_T, buf_T *);
  static void mz_fix_cursor(int lo, int hi, int extra);
  
! static int eval_in_namespace(void *, Scheme_Closed_Prim *, Scheme_Env *,
! 		Scheme_Object **ret);
! static void make_modules(Scheme_Env *);
  
  #ifdef DYNAMIC_MZSCHEME
  
--- 161,212 ----
  static Scheme_Object *do_eval(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_load(void *, int noargc, Scheme_Object **noargv);
  static Scheme_Object *do_apply(void *, int noargc, Scheme_Object **noargv);
! static void register_vim_exn(void);
  static vim_mz_buffer *get_buffer_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
  static vim_mz_window *get_window_arg(const char *fname, int argnum,
  	int argc, Scheme_Object **argv);
  static int line_in_range(linenr_T, buf_T *);
  static void check_line_range(linenr_T, buf_T *);
  static void mz_fix_cursor(int lo, int hi, int extra);
  
! static int eval_with_exn_handling(void *, Scheme_Closed_Prim *,
! 	    Scheme_Object **ret);
! static void make_modules(void);
! static void init_exn_catching_apply(void);
! static int mzscheme_env_main(Scheme_Env *env, int argc, char **argv);
! static int mzscheme_init(void);
! #ifdef FEAT_EVAL
! static Scheme_Object *vim_to_mzscheme(typval_T *vim_value, int depth,
! 	Scheme_Hash_Table *visited);
! #endif
! 
! #ifdef MZ_PRECISE_GC
! static int buffer_size_proc(void *obj)
! {
!     return gcBYTES_TO_WORDS(sizeof(vim_mz_buffer));
! }
! static int buffer_mark_proc(void *obj)
! {
!     return buffer_size_proc(obj);
! }
! static int buffer_fixup_proc(void *obj)
! {
!     return buffer_size_proc(obj);
! }
! static int window_size_proc(void *obj)
! {
!     return gcBYTES_TO_WORDS(sizeof(vim_mz_window));
! }
! static int window_mark_proc(void *obj)
! {
!     return window_size_proc(obj);
! }
! static int window_fixup_proc(void *obj)
! {
!     return window_size_proc(obj);
! }
! #endif
  
  #ifdef DYNAMIC_MZSCHEME
  
***************
*** 260,267 ****
      (Scheme_Closed_Prim *prim, void *data, const char *name, mzshort mina,
       mzshort maxa);
  static Scheme_Object *(*dll_scheme_make_integer_value)(long i);
- static Scheme_Object *(*dll_scheme_make_namespace)(int argc,
- 	Scheme_Object *argv[]);
  static Scheme_Object *(*dll_scheme_make_pair)(Scheme_Object *car,
  	Scheme_Object *cdr);
  static Scheme_Object *(*dll_scheme_make_prim_w_arity)(Scheme_Prim *prim,
--- 280,285 ----
***************
*** 311,316 ****
--- 329,345 ----
  static Scheme_Object *(*dll_scheme_char_string_to_path)
      (Scheme_Object *s);
  # endif
+ static Scheme_Hash_Table *(*dll_scheme_make_hash_table)(int type);
+ static void (*dll_scheme_hash_set)(Scheme_Hash_Table *table,
+ 	Scheme_Object *key, Scheme_Object *value);
+ static Scheme_Object *(*dll_scheme_hash_get)(Scheme_Hash_Table *table,
+ 	Scheme_Object *key);
+ static Scheme_Object *(*dll_scheme_make_double)(double d);
+ # ifdef INCLUDE_MZSCHEME_BASE
+ static Scheme_Object *(*dll_scheme_make_sized_byte_string)(char *chars,
+ 	long len, int copy);
+ static Scheme_Object *(*dll_scheme_namespace_require)(Scheme_Object *req);
+ # endif
  
  /* arrays are imported directly */
  # define scheme_eof dll_scheme_eof
***************
*** 368,374 ****
  # define scheme_lookup_global dll_scheme_lookup_global
  # define scheme_make_closed_prim_w_arity dll_scheme_make_closed_prim_w_arity
  # define scheme_make_integer_value dll_scheme_make_integer_value
- # define scheme_make_namespace dll_scheme_make_namespace
  # define scheme_make_pair dll_scheme_make_pair
  # define scheme_make_prim_w_arity dll_scheme_make_prim_w_arity
  # if MZSCHEME_VERSION_MAJOR < 299
--- 397,402 ----
***************
*** 403,408 ****
--- 431,444 ----
  #  define scheme_char_string_to_path \
      dll_scheme_char_string_to_path
  # endif
+ # define scheme_make_hash_table dll_scheme_make_hash_table
+ # define scheme_hash_set dll_scheme_hash_set
+ # define scheme_hash_get dll_scheme_hash_get
+ # define scheme_make_double dll_scheme_make_double
+ # ifdef INCLUDE_MZSCHEME_BASE
+ #  define scheme_make_sized_byte_string dll_scheme_make_sized_byte_string
+ #  define scheme_namespace_require dll_scheme_namespace_require
+ # endif
  
  typedef struct
  {
***************
*** 468,474 ****
      {"scheme_make_closed_prim_w_arity",
  	(void **)&dll_scheme_make_closed_prim_w_arity},
      {"scheme_make_integer_value", (void **)&dll_scheme_make_integer_value},
-     {"scheme_make_namespace", (void **)&dll_scheme_make_namespace},
      {"scheme_make_pair", (void **)&dll_scheme_make_pair},
      {"scheme_make_prim_w_arity", (void **)&dll_scheme_make_prim_w_arity},
  # if MZSCHEME_VERSION_MAJOR < 299
--- 504,509 ----
***************
*** 502,510 ****
      {"scheme_current_config", (void **)&dll_scheme_current_config},
      {"scheme_char_string_to_byte_string",
  	(void **)&dll_scheme_char_string_to_byte_string},
!     {"scheme_char_string_to_path",
! 	(void **)&dll_scheme_char_string_to_path},
  # endif
      {NULL, NULL}};
  
  static HINSTANCE hMzGC = 0;
--- 537,552 ----
      {"scheme_current_config", (void **)&dll_scheme_current_config},
      {"scheme_char_string_to_byte_string",
  	(void **)&dll_scheme_char_string_to_byte_string},
!     {"scheme_char_string_to_path", (void **)&dll_scheme_char_string_to_path},
  # endif
+     {"scheme_make_hash_table", (void **)&dll_scheme_make_hash_table},
+     {"scheme_hash_set", (void **)&dll_scheme_hash_set},
+     {"scheme_hash_get", (void **)&dll_scheme_hash_get},
+     {"scheme_make_double", (void **)&dll_scheme_make_double},
+ # ifdef INCLUDE_MZSCHEME_BASE
+     {"scheme_make_sized_byte_string", (void **)&dll_scheme_make_sized_byte_string},
+     {"scheme_namespace_require", (void **)&dll_scheme_namespace_require},
+ #endif
      {NULL, NULL}};
  
  static HINSTANCE hMzGC = 0;
***************
*** 592,597 ****
--- 634,644 ----
  }
  #endif /* DYNAMIC_MZSCHEME */
  
+ /* need to put it here for dynamic stuff to work */
+ #ifdef INCLUDE_MZSCHEME_BASE
+ # include "mzscheme_base.c"
+ #endif
+ 
  /*
   *========================================================================
   *  1. MzScheme interpreter startup
***************
*** 601,621 ****
  static Scheme_Type mz_buffer_type;
  static Scheme_Type mz_window_type;
  
! static int initialized = 0;
  
  /* global environment */
  static Scheme_Env    *environment = NULL;
  /* output/error handlers */
  static Scheme_Object *curout = NULL;
  static Scheme_Object *curerr = NULL;
! /* vim:exn exception */
  static Scheme_Object *exn_catching_apply = NULL;
  static Scheme_Object *exn_p = NULL;
  static Scheme_Object *exn_message = NULL;
  static Scheme_Object *vim_exn = NULL; /* Vim Error exception */
!  /* values for exn:vim - constructor, predicate, accessors etc */
! static Scheme_Object *vim_exn_names = NULL;
! static Scheme_Object *vim_exn_values = NULL;
  
  static long range_start;
  static long range_end;
--- 648,669 ----
  static Scheme_Type mz_buffer_type;
  static Scheme_Type mz_window_type;
  
! static int initialized = FALSE;
  
  /* global environment */
  static Scheme_Env    *environment = NULL;
  /* output/error handlers */
  static Scheme_Object *curout = NULL;
  static Scheme_Object *curerr = NULL;
! /* exn:vim exception */
  static Scheme_Object *exn_catching_apply = NULL;
  static Scheme_Object *exn_p = NULL;
  static Scheme_Object *exn_message = NULL;
  static Scheme_Object *vim_exn = NULL; /* Vim Error exception */
! 
! #if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
! static void *stack_base = NULL;
! #endif
  
  static long range_start;
  static long range_end;
***************
*** 668,677 ****
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
      static gint
! timer_proc(gpointer data UNUSED)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
      static void
! timer_proc(XtPointer timed_out UNUSED, XtIntervalId *interval_id UNUSED)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
--- 716,725 ----
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
      static gint
! timer_proc(gpointer data)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
      static void
! timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
***************
*** 751,762 ****
  #endif
  }
  
      static void
  startup_mzscheme(void)
  {
!     Scheme_Object *proc_make_security_guard;
! 
!     scheme_set_stack_base(NULL, 1);
  
      MZ_REGISTER_STATIC(environment);
      MZ_REGISTER_STATIC(curout);
--- 799,862 ----
  #endif
  }
  
+     void
+ mzscheme_main(void)
+ {
+ #if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR >= 400
+     /* use trampoline for precise GC in MzScheme >= 4.x */
+     scheme_main_setup(TRUE, mzscheme_env_main, 0, NULL);
+ #else
+     mzscheme_env_main(NULL, 0, NULL);
+ #endif
+ }
+ 
+     static int
+ mzscheme_env_main(Scheme_Env *env, int argc, char **argv)
+ {
+     /* neither argument nor return values are used */
+ #ifdef MZ_PRECISE_GC
+ # if MZSCHEME_VERSION_MAJOR < 400
+     /*
+      * Starting from version 4.x, embedding applications must use
+      * scheme_main_setup/scheme_main_stack_setup trampolines
+      * rather than setting stack base directly with scheme_set_stack_base
+      */
+     Scheme_Object   *dummy = NULL;
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, dummy);
+ 
+     stack_base = &__gc_var_stack__;
+ # else
+     /* environment has been created by us by Scheme */
+     environment = env;
+ # endif
+     /*
+      * In 4.x, all activities must be performed inside trampoline
+      * so we are forced to initialise GC immediately
+      * This can be postponed in 3.x but I see no point in implementing
+      * a feature which will work in older versions only.
+      * One would better use conservative GC if he needs dynamic MzScheme
+      */
+     mzscheme_init();
+ #else
+     int dummy = 0;
+     stack_base = (void *)&dummy;
+ #endif
+     main_loop(FALSE, FALSE);
+ #if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR < 400
+     /* releasing dummy */
+     MZ_GC_REG();
+     MZ_GC_UNREG();
+ #endif
+     return 0;
+ }
+ 
      static void
  startup_mzscheme(void)
  {
! #if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
!     scheme_set_stack_base(stack_base, 1);
! #endif
  
      MZ_REGISTER_STATIC(environment);
      MZ_REGISTER_STATIC(curout);
***************
*** 765,774 ****
      MZ_REGISTER_STATIC(exn_p);
      MZ_REGISTER_STATIC(exn_message);
      MZ_REGISTER_STATIC(vim_exn);
-     MZ_REGISTER_STATIC(vim_exn_names);
-     MZ_REGISTER_STATIC(vim_exn_values);
  
      environment = scheme_basic_env();
  
      /* redirect output */
      scheme_console_output = do_output;
--- 865,899 ----
      MZ_REGISTER_STATIC(exn_p);
      MZ_REGISTER_STATIC(exn_message);
      MZ_REGISTER_STATIC(vim_exn);
  
+ #if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+     /* in newer versions of precise GC the initial env has been created */
      environment = scheme_basic_env();
+ #endif
+     MZ_GC_CHECK();
+ 
+ #ifdef INCLUDE_MZSCHEME_BASE
+     {
+ 	/*
+ 	 * versions 4.x do not provide Scheme bindings by defaults
+ 	 * we need to add them explicitly
+ 	 */
+ 	Scheme_Object *scheme_base_symbol = NULL;
+ 	MZ_GC_DECL_REG(1);
+ 	MZ_GC_VAR_IN_REG(0, scheme_base_symbol);
+ 	MZ_GC_REG();
+ 	/* invoke function from generated and included base.c */
+ 	declare_modules(environment);
+ 	scheme_base_symbol = scheme_intern_symbol("scheme/base");
+ 	MZ_GC_CHECK();
+ 	scheme_namespace_require(scheme_base_symbol);
+ 	MZ_GC_CHECK();
+ 	MZ_GC_UNREG();
+     }
+ #endif
+     register_vim_exn();
+     /* use new environment to initialise exception handling */
+     init_exn_catching_apply();
  
      /* redirect output */
      scheme_console_output = do_output;
***************
*** 776,823 ****
  
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
-     scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
- 	    scheme_make_pair(
  # if MZSCHEME_VERSION_MAJOR >= 299
! 		scheme_char_string_to_path(
! 		    scheme_byte_string_to_char_string(
! 			scheme_make_byte_string(MZSCHEME_COLLECTS))),
  # else
! 		scheme_make_string(MZSCHEME_COLLECTS),
  # endif
- 		scheme_null));
  #endif
  #ifdef HAVE_SANDBOX
!     /* setup sandbox guards */
!     proc_make_security_guard = scheme_lookup_global(
! 	    scheme_intern_symbol("make-security-guard"),
! 	    environment);
!     if (proc_make_security_guard != NULL)
!     {
! 	Scheme_Object *args[3];
! 	Scheme_Object *guard;
! 	args[0] = scheme_get_param(scheme_config, MZCONFIG_SECURITY_GUARD);
! 	args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
! 		"sandbox-file-guard", 3, 3);
! 	args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
! 		"sandbox-network-guard", 4, 4);
! 	guard = scheme_apply(proc_make_security_guard, 3, args);
! 	scheme_set_param(scheme_config, MZCONFIG_SECURITY_GUARD, guard);
      }
  #endif
      /* Create buffer and window types for use in Scheme code */
      mz_buffer_type = scheme_make_type("<vim-buffer>");
      mz_window_type = scheme_make_type("<vim-window>");
  
!     register_vim_exn(environment);
!     make_modules(environment);
  
      /*
       * setup callback to receive notifications
       * whether thread scheduling is (or not) required
       */
      scheme_notify_multithread = notify_multithread;
-     initialized = 1;
  }
  
  /*
--- 901,1031 ----
  
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
  # if MZSCHEME_VERSION_MAJOR >= 299
!     {
! 	Scheme_Object	*coll_byte_string = NULL;
! 	Scheme_Object	*coll_char_string = NULL;
! 	Scheme_Object	*coll_path = NULL;
! 	Scheme_Object	*coll_pair = NULL;
! 	Scheme_Config	*config = NULL;
! 
! 	MZ_GC_DECL_REG(5);
! 	MZ_GC_VAR_IN_REG(0, coll_byte_string);
! 	MZ_GC_VAR_IN_REG(1, coll_char_string);
! 	MZ_GC_VAR_IN_REG(2, coll_path);
! 	MZ_GC_VAR_IN_REG(3, coll_pair);
! 	MZ_GC_VAR_IN_REG(4, config);
! 	MZ_GC_REG();
! 	coll_byte_string = scheme_make_byte_string(MZSCHEME_COLLECTS);
! 	MZ_GC_CHECK();
! 	coll_char_string = scheme_byte_string_to_char_string(coll_byte_string);
! 	MZ_GC_CHECK();
! 	coll_path = scheme_char_string_to_path(coll_char_string);
! 	MZ_GC_CHECK();
! 	coll_pair = scheme_make_pair(coll_path, scheme_null);
! 	MZ_GC_CHECK();
! 	config = scheme_config;
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
! 	MZ_GC_CHECK();
! 	MZ_GC_UNREG();
!     }
  # else
!     {
! 	Scheme_Object	*coll_string = NULL;
! 	Scheme_Object	*coll_pair = NULL;
! 	Scheme_Config	*config = NULL;
! 
! 	MZ_GC_DECL_REG(3);
! 	MZ_GC_VAR_IN_REG(0, coll_string);
! 	MZ_GC_VAR_IN_REG(1, coll_pair);
! 	MZ_GC_VAR_IN_REG(2, config);
! 	MZ_GC_REG();
! 	coll_string = scheme_make_string(MZSCHEME_COLLECTS);
! 	MZ_GC_CHECK();
! 	coll_pair = scheme_make_pair(coll_string, scheme_null);
! 	MZ_GC_CHECK();
! 	config = scheme_config;
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
! 	MZ_GC_CHECK();
! 	MZ_GC_UNREG();
!     }
  # endif
  #endif
  #ifdef HAVE_SANDBOX
!     {
! 	Scheme_Object	*make_security_guard = NULL;
! 	MZ_GC_DECL_REG(1);
! 	MZ_GC_VAR_IN_REG(0, make_security_guard);
! 	MZ_GC_REG();
! 
! #if MZSCHEME_VERSION_MAJOR < 400
! 	{
! 	    Scheme_Object	*make_security_guard_symbol = NULL;
! 	    MZ_GC_DECL_REG(1);
! 	    MZ_GC_VAR_IN_REG(0, make_security_guard_symbol);
! 	    MZ_GC_REG();
! 	    make_security_guard_symbol = scheme_intern_symbol("make-security-guard");
! 	    MZ_GC_CHECK();
! 	    make_security_guard = scheme_lookup_global(
! 		    make_security_guard_symbol, environment);
! 	    MZ_GC_UNREG();
! 	}
! #else
! 	make_security_guard = scheme_builtin_value("make-security-guard");
! 	MZ_GC_CHECK();
! #endif
! 
! 	/* setup sandbox guards */
! 	if (make_security_guard != NULL)
! 	{
! 	    Scheme_Object   *args[3] = {NULL, NULL, NULL};
! 	    Scheme_Object   *guard = NULL;
! 	    Scheme_Config   *config = NULL;
! 	    MZ_GC_DECL_REG(5);
! 	    MZ_GC_ARRAY_VAR_IN_REG(0, args, 3);
! 	    MZ_GC_VAR_IN_REG(3, guard);
! 	    MZ_GC_VAR_IN_REG(4, config);
! 	    MZ_GC_REG();
! 	    config = scheme_config;
! 	    MZ_GC_CHECK();
! 	    args[0] = scheme_get_param(config, MZCONFIG_SECURITY_GUARD);
! 	    MZ_GC_CHECK();
! 	    args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
! 		    "sandbox-file-guard", 3, 3);
! 	    args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
! 		    "sandbox-network-guard", 4, 4);
! 	    guard = scheme_apply(make_security_guard, 3, args);
! 	    MZ_GC_CHECK();
! 	    scheme_set_param(config, MZCONFIG_SECURITY_GUARD, guard);
! 	    MZ_GC_CHECK();
! 	    MZ_GC_UNREG();
! 	}
! 	MZ_GC_UNREG();
      }
  #endif
      /* Create buffer and window types for use in Scheme code */
      mz_buffer_type = scheme_make_type("<vim-buffer>");
+     MZ_GC_CHECK();
      mz_window_type = scheme_make_type("<vim-window>");
+     MZ_GC_CHECK();
+ #ifdef MZ_PRECISE_GC
+     GC_register_traversers(mz_buffer_type,
+ 	    buffer_size_proc, buffer_mark_proc, buffer_fixup_proc,
+ 	    TRUE, TRUE);
+     GC_register_traversers(mz_window_type,
+ 	    window_size_proc, window_mark_proc, window_fixup_proc,
+ 	    TRUE, TRUE);
+ #endif
  
!     make_modules();
  
      /*
       * setup callback to receive notifications
       * whether thread scheduling is (or not) required
       */
      scheme_notify_multithread = notify_multithread;
  }
  
  /*
***************
*** 827,897 ****
      static int
  mzscheme_init(void)
  {
-     int do_require = FALSE;
- 
      if (!initialized)
      {
- 	do_require = TRUE;
  #ifdef DYNAMIC_MZSCHEME
  	if (!mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("???: Sorry, this command is disabled, the MzScheme library could not be loaded."));
  	    return -1;
  	}
  #endif
  	startup_mzscheme();
! 
! 	if (mzscheme_io_init())
! 	    return -1;
! 
!     }
!     /* recreate ports each call effectivelly clearing these ones */
!     curout = scheme_make_string_output_port();
!     curerr = scheme_make_string_output_port();
!     scheme_set_param(scheme_config, MZCONFIG_OUTPUT_PORT, curout);
!     scheme_set_param(scheme_config, MZCONFIG_ERROR_PORT, curerr);
! 
!     if (do_require)
!     {
! 	/* auto-instantiate in basic env */
! 	eval_in_namespace("(require (prefix vimext: vimext))", do_eval,
! 		environment, NULL);
      }
- 
-     return 0;
- }
- 
- /*
-  * This routine fills the namespace with various important routines that can
-  * be used within MzScheme.
-  */
-     static void
- mzscheme_interface_init(vim_mz_buffer *mzbuff)
- {
-     Scheme_Object   *attach;
- 
-     mzbuff->env = (Scheme_Env *)scheme_make_namespace(0, NULL);
- 
-     /*
-      * attach instantiated modules from global namespace
-      * so they can be easily instantiated in the buffer namespace
-      */
-     attach = scheme_lookup_global(
- 	    scheme_intern_symbol("namespace-attach-module"),
- 	    environment);
- 
-     if (attach != NULL)
      {
! 	Scheme_Object   *ret;
! 	Scheme_Object	*args[2];
! 
! 	args[0] = (Scheme_Object *)environment;
! 	args[1] = scheme_intern_symbol("vimext");
! 
! 	ret = (Scheme_Object *)mzvim_apply(attach, 2, args);
      }
  
!     add_vim_exn(mzbuff->env);
  }
  
  /*
--- 1035,1072 ----
      static int
  mzscheme_init(void)
  {
      if (!initialized)
      {
  #ifdef DYNAMIC_MZSCHEME
  	if (!mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("E812: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
  	    return -1;
  	}
  #endif
  	startup_mzscheme();
! 	initialized = TRUE;
      }
      {
! 	Scheme_Config	*config = NULL;
! 	MZ_GC_DECL_REG(1);
! 	MZ_GC_VAR_IN_REG(0, config);
! 	MZ_GC_REG();
! 	config = scheme_config;
! 	MZ_GC_CHECK();
! 	/* recreate ports each call effectivelly clearing these ones */
! 	curout = scheme_make_string_output_port();
! 	MZ_GC_CHECK();
! 	curerr = scheme_make_string_output_port();
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_OUTPUT_PORT, curout);
! 	MZ_GC_CHECK();
! 	scheme_set_param(config, MZCONFIG_ERROR_PORT, curerr);
! 	MZ_GC_CHECK();
! 	MZ_GC_UNREG();
      }
  
!     return 0;
  }
  
  /*
***************
*** 901,928 ****
   */
  
  /*
!  * Evaluate command in namespace with exception handling
   */
      static int
! eval_in_namespace(void *data, Scheme_Closed_Prim *what, Scheme_Env *env,
! 		Scheme_Object **ret)
  {
!     Scheme_Object   *value;
!     Scheme_Object   *exn;
!     Cmd_Info	    info;   /* closure info */
! 
!     info.data = data;
!     info.env = env;
! 
!     scheme_set_param(scheme_config, MZCONFIG_ENV,
! 	    (Scheme_Object *) env);
!     /*
!      * ensure all evaluations will be in current buffer namespace,
!      * the second argument to scheme_eval_string isn't enough!
!      */
!     value = _apply_thunk_catch_exceptions(
! 	    scheme_make_closed_prim_w_arity(what, &info, "mzvim", 0, 0),
! 	    &exn);
  
      if (!value)
      {
--- 1076,1100 ----
   */
  
  /*
!  * Evaluate command with exception handling
   */
      static int
! eval_with_exn_handling(void *data, Scheme_Closed_Prim *what, Scheme_Object **ret)
  {
!     Scheme_Object   *value = NULL;
!     Scheme_Object   *exn = NULL;
!     Scheme_Object   *prim = NULL;
! 
!     MZ_GC_DECL_REG(3);
!     MZ_GC_VAR_IN_REG(0, value);
!     MZ_GC_VAR_IN_REG(1, exn);
!     MZ_GC_VAR_IN_REG(2, prim);
!     MZ_GC_REG();
! 
!     prim = scheme_make_closed_prim_w_arity(what, data, "mzvim", 0, 0);
!     MZ_GC_CHECK();
!     value = _apply_thunk_catch_exceptions(prim, &exn);
!     MZ_GC_CHECK();
  
      if (!value)
      {
***************
*** 930,938 ****
  	/* Got an exn? */
  	if (value)
  	{
! 	    scheme_display(value, curerr);  /*  Send to stderr-vim */
  	    do_flush();
  	}
  	/* `raise' was called on some arbitrary value */
  	return FAIL;
      }
--- 1102,1112 ----
  	/* Got an exn? */
  	if (value)
  	{
! 	    scheme_display(value, curerr);   /*  Send to stderr-vim */
! 	    MZ_GC_CHECK();
  	    do_flush();
  	}
+ 	MZ_GC_UNREG();
  	/* `raise' was called on some arbitrary value */
  	return FAIL;
      }
***************
*** 941,949 ****
--- 1115,1127 ----
  	*ret = value;
      /* Print any result, as long as it's not a void */
      else if (!SCHEME_VOIDP(value))
+     {
  	scheme_display(value, curout);  /* Send to stdout-vim */
+ 	MZ_GC_CHECK();
+     }
  
      do_flush();
+     MZ_GC_UNREG();
      return OK;
  }
  
***************
*** 957,963 ****
      range_start = eap->line1;
      range_end = eap->line2;
  
!     return eval_in_namespace(data, what, get_vim_curr_buffer()->env, NULL);
  }
  
  /*
--- 1135,1141 ----
      range_start = eap->line1;
      range_end = eap->line2;
  
!     return eval_with_exn_handling(data, what, NULL);
  }
  
  /*
***************
*** 974,979 ****
--- 1152,1158 ----
  	bp->buf = INVALID_BUFFER_VALUE;
  	buf->b_mzscheme_ref = NULL;
  	scheme_gc_ptr_ok(bp);
+ 	MZ_GC_CHECK();
      }
  }
  
***************
*** 990,995 ****
--- 1169,1175 ----
  	wp->win = INVALID_WINDOW_VALUE;
  	win->w_mzscheme_ref = NULL;
  	scheme_gc_ptr_ok(wp);
+ 	MZ_GC_CHECK();
      }
  }
  
***************
*** 1014,1031 ****
      }
  }
  
- /* eval MzScheme string */
-     void *
- mzvim_eval_string(char_u *str)
- {
-     Scheme_Object *ret = NULL;
-     if (mzscheme_init())
- 	return FAIL;
- 
-     eval_in_namespace(str, do_eval, get_vim_curr_buffer()->env, &ret);
-     return ret;
- }
- 
  /*
   * apply MzScheme procedure with arguments,
   * handling errors
--- 1194,1199 ----
***************
*** 1033,1075 ****
      Scheme_Object *
  mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)
  {
-     Apply_Info	data;
-     Scheme_Object *ret = NULL;
- 
      if (mzscheme_init())
  	return FAIL;
  
!     data.proc = proc;
!     data.argc = argc;
!     data.argv = argv;
! 
!     eval_in_namespace(&data, do_apply, get_vim_curr_buffer()->env, &ret);
!     return ret;
  }
  
      static Scheme_Object *
  do_load(void *data, int noargc, Scheme_Object **noargv)
  {
!     Cmd_Info	    *info = (Cmd_Info *)data;
!     Scheme_Object   *result = scheme_void;
!     Scheme_Object   *expr;
!     char_u	    *file = scheme_malloc_fail_ok(
! 					  scheme_malloc_atomic, MAXPATHL + 1);
!     Port_Info	    *pinfo = (Port_Info *)(info->data);
  
      /* make Vim expansion */
!     expand_env((char_u *)pinfo->name, file, MAXPATHL);
!     /* scheme_load looks strange working with namespaces and error handling*/
      pinfo->port = scheme_open_input_file(file, "mzfile");
!     scheme_count_lines(pinfo->port); /* to get accurate read error location*/
  
      /* Like REPL but print only last result */
      while (!SCHEME_EOFP(expr = scheme_read(pinfo->port)))
! 	result = scheme_eval(expr, info->env);
  
      /* errors will be caught in do_mzscheme_comamnd and ex_mzfile */
      scheme_close_input_port(pinfo->port);
      pinfo->port = NULL;
      return result;
  }
  
--- 1201,1265 ----
      Scheme_Object *
  mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)
  {
      if (mzscheme_init())
  	return FAIL;
+     else
+     {
+ 	Apply_Info	data = {NULL, 0, NULL};
+ 	Scheme_Object	*ret = NULL;
  
! 	MZ_GC_DECL_REG(5);
! 	MZ_GC_VAR_IN_REG(0, ret);
! 	MZ_GC_VAR_IN_REG(1, data.proc);
! 	MZ_GC_ARRAY_VAR_IN_REG(2, data.argv, argc);
! 	MZ_GC_REG();
! 
! 	data.proc = proc;
! 	data.argc = argc;
! 	data.argv = argv;
! 
! 	eval_with_exn_handling(&data, do_apply, &ret);
! 	MZ_GC_UNREG();
! 	return ret;
!     }
  }
  
      static Scheme_Object *
  do_load(void *data, int noargc, Scheme_Object **noargv)
  {
!     Scheme_Object   *expr = NULL;
!     Scheme_Object   *result = NULL;
!     char	    *file = NULL;
!     Port_Info	    *pinfo = (Port_Info *)data;
! 
!     MZ_GC_DECL_REG(3);
!     MZ_GC_VAR_IN_REG(0, expr);
!     MZ_GC_VAR_IN_REG(1, result);
!     MZ_GC_VAR_IN_REG(2, file);
!     MZ_GC_REG();
! 
!     file = (char *)scheme_malloc_fail_ok(scheme_malloc_atomic, MAXPATHL + 1);
!     MZ_GC_CHECK();
  
      /* make Vim expansion */
!     expand_env((char_u *)pinfo->name, (char_u *)file, MAXPATHL);
      pinfo->port = scheme_open_input_file(file, "mzfile");
!     MZ_GC_CHECK();
!     scheme_count_lines(pinfo->port);  /* to get accurate read error location*/
!     MZ_GC_CHECK();
  
      /* Like REPL but print only last result */
      while (!SCHEME_EOFP(expr = scheme_read(pinfo->port)))
!     {
! 	result = scheme_eval(expr, environment);
! 	MZ_GC_CHECK();
!     }
  
      /* errors will be caught in do_mzscheme_comamnd and ex_mzfile */
      scheme_close_input_port(pinfo->port);
+     MZ_GC_CHECK();
      pinfo->port = NULL;
+     MZ_GC_UNREG();
      return result;
  }
  
***************
*** 1077,1089 ****
      void
  ex_mzfile(exarg_T *eap)
  {
!     Port_Info	pinfo;
  
      pinfo.name = (char *)eap->arg;
-     pinfo.port = NULL;
      if (do_mzscheme_command(eap, &pinfo, do_load) != OK
  	    && pinfo.port != NULL)	/* looks like port was not closed */
  	scheme_close_input_port(pinfo.port);
  }
  
  
--- 1267,1286 ----
      void
  ex_mzfile(exarg_T *eap)
  {
!     Port_Info	pinfo = {NULL, NULL};
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, pinfo.port);
!     MZ_GC_REG();
  
      pinfo.name = (char *)eap->arg;
      if (do_mzscheme_command(eap, &pinfo, do_load) != OK
  	    && pinfo.port != NULL)	/* looks like port was not closed */
+     {
  	scheme_close_input_port(pinfo.port);
+ 	MZ_GC_CHECK();
+     }
+     MZ_GC_UNREG();
  }
  
  
***************
*** 1103,1116 ****
  		"(with-handlers ([void (lambda (exn) (cons #f exn))]) "
  		"(cons #t (thunk))))";
  
! 	/* make sure we have a namespace with the standard syntax: */
! 	Scheme_Env *env = (Scheme_Env *)scheme_make_namespace(0, NULL);
! 	add_vim_exn(env);
! 
! 	exn_catching_apply = scheme_eval_string(e, env);
! 	exn_p = scheme_lookup_global(scheme_intern_symbol("exn?"), env);
! 	exn_message = scheme_lookup_global(
! 		scheme_intern_symbol("exn-message"), env);
      }
  }
  
--- 1300,1311 ----
  		"(with-handlers ([void (lambda (exn) (cons #f exn))]) "
  		"(cons #t (thunk))))";
  
! 	exn_catching_apply = scheme_eval_string(e, environment);
! 	MZ_GC_CHECK();
! 	exn_p = scheme_builtin_value("exn?");
! 	MZ_GC_CHECK();
! 	exn_message = scheme_builtin_value("exn-message");
! 	MZ_GC_CHECK();
      }
  }
  
***************
*** 1124,1131 ****
  {
      Scheme_Object *v;
  
-     init_exn_catching_apply();
- 
      v = _scheme_apply(exn_catching_apply, 1, &f);
      /* v is a pair: (cons #t value) or (cons #f exn) */
  
--- 1319,1324 ----
***************
*** 1141,1148 ****
      static Scheme_Object *
  extract_exn_message(Scheme_Object *v)
  {
-     init_exn_catching_apply();
- 
      if (SCHEME_TRUEP(_scheme_apply(exn_p, 1, &v)))
  	return _scheme_apply(exn_message, 1, &v);
      else
--- 1334,1339 ----
***************
*** 1152,1167 ****
      static Scheme_Object *
  do_eval(void *s, int noargc, Scheme_Object **noargv)
  {
!     Cmd_Info	*info = (Cmd_Info *)s;
! 
!     return scheme_eval_string_all((char *)(info->data), info->env, TRUE);
  }
  
      static Scheme_Object *
  do_apply(void *a, int noargc, Scheme_Object **noargv)
  {
!     Apply_Info	*info = (Apply_Info *)(((Cmd_Info *)a)->data);
! 
      return scheme_apply(info->proc, info->argc, info->argv);
  }
  
--- 1343,1355 ----
      static Scheme_Object *
  do_eval(void *s, int noargc, Scheme_Object **noargv)
  {
!     return scheme_eval_string_all((char *)s, environment, TRUE);
  }
  
      static Scheme_Object *
  do_apply(void *a, int noargc, Scheme_Object **noargv)
  {
!     Apply_Info	*info = (Apply_Info *)a;
      return scheme_apply(info->proc, info->argc, info->argv);
  }
  
***************
*** 1219,1224 ****
--- 1407,1413 ----
      long length;
  
      buff = scheme_get_sized_string_output(curerr, &length);
+     MZ_GC_CHECK();
      if (length)
      {
  	do_err_output(buff, length);
***************
*** 1226,1242 ****
      }
  
      buff = scheme_get_sized_string_output(curout, &length);
      if (length)
  	do_output(buff, length);
  }
  
-     static int
- mzscheme_io_init(void)
- {
-     /* Nothing needed so far... */
-     return 0;
- }
- 
  /*
   *========================================================================
   *  4. Implementation of the Vim Features for MzScheme
--- 1415,1425 ----
      }
  
      buff = scheme_get_sized_string_output(curout, &length);
+     MZ_GC_CHECK();
      if (length)
  	do_output(buff, length);
  }
  
  /*
   *========================================================================
   *  4. Implementation of the Vim Features for MzScheme
***************
*** 1263,1284 ****
  vim_eval(void *data, int argc, Scheme_Object **argv)
  {
  #ifdef FEAT_EVAL
!     Vim_Prim	    *prim = (Vim_Prim *)data;
!     char	    *expr;
!     char	    *str;
!     Scheme_Object   *result;
  
!     expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
  
!     str = (char *)eval_to_string((char_u *)expr, NULL, TRUE);
  
!     if (str == NULL)
  	raise_vim_exn(_("invalid expression"));
  
!     result = scheme_make_string(str);
! 
!     vim_free(str);
  
      return result;
  #else
      raise_vim_exn(_("expressions disabled at compile time"));
--- 1446,1475 ----
  vim_eval(void *data, int argc, Scheme_Object **argv)
  {
  #ifdef FEAT_EVAL
!     Vim_Prim		*prim = (Vim_Prim *)data;
!     char		*expr;
!     Scheme_Object	*result;
!     /* hash table to store visited values to avoid infinite loops */
!     Scheme_Hash_Table	*visited = NULL;
!     typval_T		*vim_result;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, visited);
!     MZ_GC_REG();
  
!     visited = scheme_make_hash_table(SCHEME_hash_ptr);
!     MZ_GC_CHECK();
  
!     expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
!     vim_result = eval_expr((char_u *)expr, NULL);
  
!     if (vim_result == NULL)
  	raise_vim_exn(_("invalid expression"));
  
!     result = vim_to_mzscheme(vim_result, 1, visited);
!     free_tv(vim_result);
  
+     MZ_GC_UNREG();
      return result;
  #else
      raise_vim_exn(_("expressions disabled at compile time"));
***************
*** 1318,1324 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      char_u	    *name;
      long	    value;
!     char_u	    *strval;
      int		    rc;
      Scheme_Object   *rval;
      int		    opt_flags = 0;
--- 1509,1515 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      char_u	    *name;
      long	    value;
!     char	    *strval;
      int		    rc;
      Scheme_Object   *rval;
      int		    opt_flags = 0;
***************
*** 1333,1338 ****
--- 1524,1530 ----
  	{
  	    MZ_REGISTER_STATIC(M_global);
  	    M_global = scheme_intern_symbol("global");
+ 	    MZ_GC_CHECK();
  	}
  
  	if (argv[1] == M_global)
***************
*** 1354,1360 ****
  	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
      }
  
!     rc = get_option_value(name, &value, &strval, opt_flags);
      curbuf = save_curb;
      curwin = save_curw;
  
--- 1546,1552 ----
  	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
      }
  
!     rc = get_option_value(name, &value, (char_u **)&strval, opt_flags);
      curbuf = save_curb;
      curwin = save_curw;
  
***************
*** 1364,1369 ****
--- 1556,1562 ----
  	return scheme_make_integer_value(value);
      case 0:
  	rval = scheme_make_string(strval);
+ 	MZ_GC_CHECK();
  	vim_free(strval);
  	return rval;
      case -1:
***************
*** 1393,1398 ****
--- 1586,1592 ----
  	{
  	    MZ_REGISTER_STATIC(M_global);
  	    M_global = scheme_intern_symbol("global");
+ 	    MZ_GC_CHECK();
  	}
  
  	if (argv[1] == M_global)
***************
*** 1463,1469 ****
--- 1657,1666 ----
  
      for (w = firstwin; w != NULL; w = w->w_next)
  	if (w->w_buffer == buf->buf)
+ 	{
  	    list = scheme_make_pair(window_new(w), list);
+ 	    MZ_GC_CHECK();
+ 	}
  
      return list;
  }
***************
*** 1471,1477 ****
      static Scheme_Object *
  window_new(win_T *win)
  {
!     vim_mz_window *self;
  
      /* We need to handle deletion of windows underneath us.
       * If we add a "w_mzscheme_ref" field to the win_T structure,
--- 1668,1678 ----
      static Scheme_Object *
  window_new(win_T *win)
  {
!     vim_mz_window *self = NULL;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, self);
!     MZ_GC_REG();
  
      /* We need to handle deletion of windows underneath us.
       * If we add a "w_mzscheme_ref" field to the win_T structure,
***************
*** 1485,1497 ****
  	return win->w_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_window));
- 
      vim_memset(self, 0, sizeof(vim_mz_window));
      scheme_dont_gc_ptr(self);	/* because win isn't visible to GC */
      win->w_mzscheme_ref = self;
      self->win = win;
!     self->tag = mz_window_type;
  
      return (Scheme_Object *)(self);
  }
  
--- 1686,1699 ----
  	return win->w_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_window));
      vim_memset(self, 0, sizeof(vim_mz_window));
      scheme_dont_gc_ptr(self);	/* because win isn't visible to GC */
+     MZ_GC_CHECK();
      win->w_mzscheme_ref = self;
      self->win = win;
!     self->so.type = mz_window_type;
  
+     MZ_GC_UNREG();
      return (Scheme_Object *)(self);
  }
  
***************
*** 1660,1666 ****
  /*
   *===========================================================================
   *  6. Vim Buffer-related Manipulation Functions
-  *     Note that each buffer should have its own private namespace.
   *===========================================================================
   */
  
--- 1862,1867 ----
***************
*** 1669,1682 ****
  mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     char	    *fname;
      int		    num = 0;
      Scheme_Object   *onum;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
!     fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
      /* TODO make open existing file */
      num = buflist_add(fname, BLN_LISTED | BLN_CURBUF);
  
--- 1870,1883 ----
  mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     char_u	    *fname;
      int		    num = 0;
      Scheme_Object   *onum;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
!     fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
      /* TODO make open existing file */
      num = buflist_add(fname, BLN_LISTED | BLN_CURBUF);
  
***************
*** 1712,1718 ****
      buf_T	*buf;
      char_u	*fname;
  
!     fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
  
      for (buf = firstbuf; buf; buf = buf->b_next)
  	if (buf->b_ffname == NULL || buf->b_sfname == NULL)
--- 1913,1919 ----
      buf_T	*buf;
      char_u	*fname;
  
!     fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
  
      for (buf = firstbuf; buf; buf = buf->b_next)
  	if (buf->b_ffname == NULL || buf->b_sfname == NULL)
***************
*** 1783,1789 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf = get_buffer_arg(prim->name, 0, argc, argv);
  
!     return scheme_make_string(buf->buf->b_ffname);
  }
  
  /* (curr-buff) */
--- 1984,1990 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf = get_buffer_arg(prim->name, 0, argc, argv);
  
!     return scheme_make_string((char *)buf->buf->b_ffname);
  }
  
  /* (curr-buff) */
***************
*** 1796,1802 ****
      static Scheme_Object *
  buffer_new(buf_T *buf)
  {
!     vim_mz_buffer *self;
  
      /* We need to handle deletion of buffers underneath us.
       * If we add a "b_mzscheme_ref" field to the buf_T structure,
--- 1997,2007 ----
      static Scheme_Object *
  buffer_new(buf_T *buf)
  {
!     vim_mz_buffer *self = NULL;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, self);
!     MZ_GC_REG();
  
      /* We need to handle deletion of buffers underneath us.
       * If we add a "b_mzscheme_ref" field to the buf_T structure,
***************
*** 1806,1820 ****
  	return buf->b_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_buffer));
- 
      vim_memset(self, 0, sizeof(vim_mz_buffer));
!     scheme_dont_gc_ptr(self);	/* because buf isn't visible to GC */
      buf->b_mzscheme_ref = self;
      self->buf = buf;
!     self->tag = mz_buffer_type;
! 
!     mzscheme_interface_init(self);	/* Set up namespace */
  
      return (Scheme_Object *)(self);
  }
  
--- 2011,2024 ----
  	return buf->b_mzscheme_ref;
  
      self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_buffer));
      vim_memset(self, 0, sizeof(vim_mz_buffer));
!     scheme_dont_gc_ptr(self); /* because buf isn't visible to GC */
!     MZ_GC_CHECK();
      buf->b_mzscheme_ref = self;
      self->buf = buf;
!     self->so.type = mz_buffer_type;
  
+     MZ_GC_UNREG();
      return (Scheme_Object *)(self);
  }
  
***************
*** 1845,1858 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    linenr;
!     char	    *line;
  
      buf = get_buffer_arg(prim->name, 1, argc, argv);
      linenr = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
      line = ml_get_buf(buf->buf, (linenr_T)linenr, FALSE);
  
      raise_if_error();
!     return scheme_make_string(line);
  }
  
  
--- 2049,2062 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    linenr;
!     char_u	    *line;
  
      buf = get_buffer_arg(prim->name, 1, argc, argv);
      linenr = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
      line = ml_get_buf(buf->buf, (linenr_T)linenr, FALSE);
  
      raise_if_error();
!     return scheme_make_string((char *)line);
  }
  
  
***************
*** 1869,1875 ****
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    i, hi, lo, n;
!     Scheme_Object   *list;
  
      buf = get_buffer_arg(prim->name, 2, argc, argv);
      list = scheme_null;
--- 2073,2083 ----
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
      int		    i, hi, lo, n;
!     Scheme_Object   *list = NULL;
! 
!     MZ_GC_DECL_REG(1);
!     MZ_GC_VAR_IN_REG(0, list);
!     MZ_GC_REG();
  
      buf = get_buffer_arg(prim->name, 2, argc, argv);
      list = scheme_null;
***************
*** 1897,1904 ****
  
  	/* Set the list item */
  	list = scheme_make_pair(str, list);
      }
! 
      return list;
  }
  
--- 2105,2113 ----
  
  	/* Set the list item */
  	list = scheme_make_pair(str, list);
+ 	MZ_GC_CHECK();
      }
!     MZ_GC_UNREG();
      return list;
  }
  
***************
*** 1925,1935 ****
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
!     Scheme_Object   *line;
      char	    *save;
-     buf_T	    *savebuf;
      int		    n;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
--- 2134,2147 ----
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
      vim_mz_buffer   *buf;
!     Scheme_Object   *line = NULL;
      char	    *save;
      int		    n;
  
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, line);
+     MZ_GC_REG();
+ 
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
***************
*** 1943,1949 ****
  
      if (SCHEME_FALSEP(line))
      {
! 	savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)n, 1L) == FAIL)
--- 2155,2162 ----
  
      if (SCHEME_FALSEP(line))
      {
! 	buf_T	    *savebuf = curbuf;
! 
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)n, 1L) == FAIL)
***************
*** 1962,1994 ****
  
  	curbuf = savebuf;
  
  	raise_if_error();
  	return scheme_void;
      }
  
!     /* Otherwise it's a line */
!     save = string_to_line(line);
!     savebuf = curbuf;
  
!     curbuf = buf->buf;
  
-     if (u_savesub((linenr_T)n) == FAIL)
-     {
- 	curbuf = savebuf;
- 	raise_vim_exn(_("cannot save undo information"));
-     }
-     else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
-     {
  	curbuf = savebuf;
- 	raise_vim_exn(_("cannot replace line"));
-     }
-     else
- 	changed_bytes((linenr_T)n, 0);
  
!     curbuf = savebuf;
  
!     raise_if_error();
!     return scheme_void;
  }
  
  /*
--- 2175,2230 ----
  
  	curbuf = savebuf;
  
+ 	MZ_GC_UNREG();
  	raise_if_error();
  	return scheme_void;
      }
+     else
+     {
+ 	/* Otherwise it's a line */
+ 	buf_T	    *savebuf = curbuf;
  
! 	save = string_to_line(line);
  
! 	curbuf = buf->buf;
! 
! 	if (u_savesub((linenr_T)n) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    vim_free(save);
! 	    raise_vim_exn(_("cannot save undo information"));
! 	}
! 	else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    vim_free(save);
! 	    raise_vim_exn(_("cannot replace line"));
! 	}
! 	else
! 	{
! 	    vim_free(save);
! 	    changed_bytes((linenr_T)n, 0);
! 	}
  
  	curbuf = savebuf;
  
! 	/* Check that the cursor is not beyond the end of the line now. */
! 	if (buf->buf == curwin->w_buffer)
! 	    check_cursor_col();
  
! 	MZ_GC_UNREG();
! 	raise_if_error();
! 	return scheme_void;
!     }
! }
! 
!     static void
! free_array(char **array)
! {
!     char **curr = array;
!     while (*curr != NULL)
! 	vim_free(*curr++);
!     vim_free(array);
  }
  
  /*
***************
*** 2013,2027 ****
       *	  3. Anything else - this is an error.
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf;
!     Scheme_Object   *line_list;
!     Scheme_Object   *line;
!     Scheme_Object   *rest;
!     char	    **array;
!     buf_T	    *savebuf;
      int		    i, old_len, new_len, hi, lo;
      long	    extra;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
--- 2249,2263 ----
       *	  3. Anything else - this is an error.
       */
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf = NULL;
!     Scheme_Object   *line_list = NULL;
      int		    i, old_len, new_len, hi, lo;
      long	    extra;
  
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, line_list);
+     MZ_GC_REG();
+ 
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
***************
*** 2047,2053 ****
  
      if (SCHEME_FALSEP(line_list) || SCHEME_NULLP(line_list))
      {
! 	savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)lo, (long)old_len) == FAIL)
--- 2283,2289 ----
  
      if (SCHEME_FALSEP(line_list) || SCHEME_NULLP(line_list))
      {
! 	buf_T	*savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_savedel((linenr_T)lo, (long)old_len) == FAIL)
***************
*** 2070,2167 ****
  
  	curbuf = savebuf;
  
  	raise_if_error();
  	return scheme_void;
      }
  
!     /* List */
!     new_len = scheme_proper_list_length(line_list);
!     if (new_len < 0)	/* improper or cyclic list */
! 	scheme_wrong_type(prim->name, "proper list",
! 		2, argc, argv);
  
!     /* Using MzScheme allocator, so we don't need to free this and
!      * can safely keep pointers to GC collected strings
!      */
!     array = (char **)scheme_malloc_fail_ok(scheme_malloc,
! 		(unsigned)(new_len * sizeof(char *)));
  
!     rest = line_list;
!     for (i = 0; i < new_len; ++i)
!     {
! 	line = SCHEME_CAR(rest);
! 	rest = SCHEME_CDR(rest);
! 	if (!SCHEME_STRINGP(line))
! 	    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
! 	array[i] = string_to_line(line);
!     }
  
!     savebuf = curbuf;
!     curbuf = buf->buf;
  
!     if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
!     {
! 	curbuf = savebuf;
! 	raise_vim_exn(_("cannot save undo information"));
!     }
  
!     /*
!      * If the size of the range is reducing (ie, new_len < old_len) we
!      * need to delete some old_len. We do this at the start, by
!      * repeatedly deleting line "lo".
!      */
!     for (i = 0; i < old_len - new_len; ++i)
!     {
! 	if (ml_delete((linenr_T)lo, FALSE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    raise_vim_exn(_("cannot delete line"));
! 	}
! 	extra--;
!     }
  
!     /*
!      * For as long as possible, replace the existing old_len with the
!      * new old_len. This is a more efficient operation, as it requires
!      * less memory allocation and freeing.
!      */
!     for (i = 0; i < old_len && i < new_len; i++)
! 	if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    raise_vim_exn(_("cannot replace line"));
! 	}
  
!     /*
!      * Now we may need to insert the remaining new_len.  We don't need to
!      * free the string passed back because MzScheme has control of that
!      * memory.
!      */
!     while (i < new_len)
!     {
! 	if (ml_append((linenr_T)(lo + i - 1),
! 		(char_u *)array[i], 0, FALSE) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    raise_vim_exn(_("cannot insert line"));
  	}
- 	++i;
- 	++extra;
-     }
  
!     /*
!      * Adjust marks. Invalidate any which lie in the
!      * changed range, and move any in the remainder of the buffer.
!      */
!     mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
!     changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
  
!     if (buf->buf == curwin->w_buffer)
! 	mz_fix_cursor(lo, hi, extra);
!     curbuf = savebuf;
  
!     raise_if_error();
!     return scheme_void;
  }
  
  /*
--- 2306,2426 ----
  
  	curbuf = savebuf;
  
+ 	MZ_GC_UNREG();
  	raise_if_error();
  	return scheme_void;
      }
+     else
+     {
+ 	buf_T	*savebuf = curbuf;
  
! 	/* List */
! 	new_len = scheme_proper_list_length(line_list);
! 	MZ_GC_CHECK();
! 	if (new_len < 0)	/* improper or cyclic list */
! 	    scheme_wrong_type(prim->name, "proper list",
! 		    2, argc, argv);
! 	else
! 	{
! 	    char		**array = NULL;
! 	    Scheme_Object   *line = NULL;
! 	    Scheme_Object   *rest = NULL;
! 
! 	    MZ_GC_DECL_REG(2);
! 	    MZ_GC_VAR_IN_REG(0, line);
! 	    MZ_GC_VAR_IN_REG(1, rest);
! 	    MZ_GC_REG();
  
! 	    array = (char **)alloc(new_len * sizeof(char *));
! 	    vim_memset(array, 0, new_len * sizeof(char *));
  
! 	    rest = line_list;
! 	    for (i = 0; i < new_len; ++i)
! 	    {
! 		line = SCHEME_CAR(rest);
! 		rest = SCHEME_CDR(rest);
! 		if (!SCHEME_STRINGP(line))
! 		{
! 		    free_array(array);
! 		    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
! 		}
! 		array[i] = string_to_line(line);
! 	    }
  
! 	    curbuf = buf->buf;
  
! 	    if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
! 	    {
! 		curbuf = savebuf;
! 		free_array(array);
! 		raise_vim_exn(_("cannot save undo information"));
! 	    }
  
! 	    /*
! 	     * If the size of the range is reducing (ie, new_len < old_len) we
! 	     * need to delete some old_len. We do this at the start, by
! 	     * repeatedly deleting line "lo".
! 	     */
! 	    for (i = 0; i < old_len - new_len; ++i)
! 	    {
! 		if (ml_delete((linenr_T)lo, FALSE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot delete line"));
! 		}
! 		extra--;
! 	    }
  
! 	    /*
! 	     * For as long as possible, replace the existing old_len with the
! 	     * new old_len. This is a more efficient operation, as it requires
! 	     * less memory allocation and freeing.
! 	     */
! 	    for (i = 0; i < old_len && i < new_len; i++)
! 		if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot replace line"));
! 		}
  
! 	    /*
! 	     * Now we may need to insert the remaining new_len.  We don't need to
! 	     * free the string passed back because MzScheme has control of that
! 	     * memory.
! 	     */
! 	    while (i < new_len)
! 	    {
! 		if (ml_append((linenr_T)(lo + i - 1),
! 			    (char_u *)array[i], 0, FALSE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot insert line"));
! 		}
! 		++i;
! 		++extra;
! 	    }
! 	    MZ_GC_UNREG();
! 	    free_array(array);
  	}
  
! 	/*
! 	 * Adjust marks. Invalidate any which lie in the
! 	 * changed range, and move any in the remainder of the buffer.
! 	 */
! 	mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
! 	changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
  
! 	if (buf->buf == curwin->w_buffer)
! 	    mz_fix_cursor(lo, hi, extra);
! 	curbuf = savebuf;
  
! 	MZ_GC_UNREG();
! 	raise_if_error();
! 	return scheme_void;
!     }
  }
  
  /*
***************
*** 2179,2193 ****
  insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf;
!     Scheme_Object   *list;
!     Scheme_Object   *line;
!     Scheme_Object   *rest;
!     char	    **array;
!     char	    *str;
!     buf_T	    *savebuf;
      int		    i, n, size;
  
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
--- 2438,2452 ----
  insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)
  {
      Vim_Prim	    *prim = (Vim_Prim *)data;
!     vim_mz_buffer   *buf = NULL;
!     Scheme_Object   *list = NULL;
!     char	    *str = NULL;
      int		    i, n, size;
  
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, list);
+     MZ_GC_REG();
+ 
  #ifdef HAVE_SANDBOX
      sandbox_check();
  #endif
***************
*** 2206,2294 ****
  	check_line_range(n, buf->buf);
      if (SCHEME_STRINGP(list))
      {
! 	str = string_to_line(list);
  
! 	savebuf = curbuf;
  	curbuf = buf->buf;
  
  	if (u_save((linenr_T)n, (linenr_T)(n+1)) == FAIL)
  	{
  	    curbuf = savebuf;
  	    raise_vim_exn(_("cannot save undo information"));
  	}
  	else if (ml_append((linenr_T)n, (char_u *)str, 0, FALSE) == FAIL)
  	{
  	    curbuf = savebuf;
  	    raise_vim_exn(_("cannot insert line"));
  	}
  	else
  	    appended_lines_mark((linenr_T)n, 1L);
  
  	curbuf = savebuf;
  	update_screen(VALID);
  
  	raise_if_error();
  	return scheme_void;
      }
  
      /* List */
      size = scheme_proper_list_length(list);
      if (size < 0)	/* improper or cyclic list */
  	scheme_wrong_type(prim->name, "proper list",
  		2, argc, argv);
! 
!     /* Using MzScheme allocator, so we don't need to free this and
!      * can safely keep pointers to GC collected strings
!      */
!     array = (char **)scheme_malloc_fail_ok(
! 	    scheme_malloc, (unsigned)(size * sizeof(char *)));
! 
!     rest = list;
!     for (i = 0; i < size; ++i)
      {
! 	line = SCHEME_CAR(rest);
! 	rest = SCHEME_CDR(rest);
! 	array[i] = string_to_line(line);
!     }
  
!     savebuf = curbuf;
!     curbuf = buf->buf;
  
!     if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
!     {
! 	curbuf = savebuf;
! 	raise_vim_exn(_("cannot save undo information"));
!     }
!     else
!     {
  	for (i = 0; i < size; ++i)
! 	    if (ml_append((linenr_T)(n + i), (char_u *)array[i],
! 			0, FALSE) == FAIL)
! 	    {
! 		curbuf = savebuf;
! 		raise_vim_exn(_("cannot insert line"));
! 	    }
  
! 	if (i > 0)
! 	    appended_lines_mark((linenr_T)n, (long)i);
!     }
  
!     curbuf = savebuf;
!     update_screen(VALID);
  
      raise_if_error();
      return scheme_void;
  }
  
- /* (get-buff-namespace [buffer]) */
-     static Scheme_Object *
- get_buffer_namespace(void *data, int argc, Scheme_Object **argv)
- {
-     Vim_Prim	*prim = (Vim_Prim *)data;
- 
-     return (Scheme_Object *)get_buffer_arg(prim->name, 0, argc, argv)->env;
- }
- 
  /*
   * Predicates
   */
--- 2465,2563 ----
  	check_line_range(n, buf->buf);
      if (SCHEME_STRINGP(list))
      {
! 	buf_T	    *savebuf = curbuf;
  
! 	str = string_to_line(list);
  	curbuf = buf->buf;
  
  	if (u_save((linenr_T)n, (linenr_T)(n+1)) == FAIL)
  	{
  	    curbuf = savebuf;
+ 	    vim_free(str);
  	    raise_vim_exn(_("cannot save undo information"));
  	}
  	else if (ml_append((linenr_T)n, (char_u *)str, 0, FALSE) == FAIL)
  	{
  	    curbuf = savebuf;
+ 	    vim_free(str);
  	    raise_vim_exn(_("cannot insert line"));
  	}
  	else
+ 	{
+ 	    vim_free(str);
  	    appended_lines_mark((linenr_T)n, 1L);
+ 	}
  
  	curbuf = savebuf;
  	update_screen(VALID);
  
+ 	MZ_GC_UNREG();
  	raise_if_error();
  	return scheme_void;
      }
  
      /* List */
      size = scheme_proper_list_length(list);
+     MZ_GC_CHECK();
      if (size < 0)	/* improper or cyclic list */
  	scheme_wrong_type(prim->name, "proper list",
  		2, argc, argv);
!     else
      {
! 	Scheme_Object   *line = NULL;
! 	Scheme_Object   *rest = NULL;
! 	char		**array;
! 	buf_T		*savebuf = curbuf;
! 
! 	MZ_GC_DECL_REG(2);
! 	MZ_GC_VAR_IN_REG(0, line);
! 	MZ_GC_VAR_IN_REG(1, rest);
! 	MZ_GC_REG();
  
! 	array = (char **)alloc(size * sizeof(char *));
! 	vim_memset(array, 0, size * sizeof(char *));
  
! 	rest = list;
  	for (i = 0; i < size; ++i)
! 	{
! 	    line = SCHEME_CAR(rest);
! 	    rest = SCHEME_CDR(rest);
! 	    array[i] = string_to_line(line);
! 	}
  
! 	curbuf = buf->buf;
  
! 	if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
! 	{
! 	    curbuf = savebuf;
! 	    free_array(array);
! 	    raise_vim_exn(_("cannot save undo information"));
! 	}
! 	else
! 	{
! 	    for (i = 0; i < size; ++i)
! 		if (ml_append((linenr_T)(n + i), (char_u *)array[i],
! 			    0, FALSE) == FAIL)
! 		{
! 		    curbuf = savebuf;
! 		    free_array(array);
! 		    raise_vim_exn(_("cannot insert line"));
! 		}
! 
! 	    if (i > 0)
! 		appended_lines_mark((linenr_T)n, (long)i);
! 	}
! 	free_array(array);
! 	MZ_GC_UNREG();
! 	curbuf = savebuf;
! 	update_screen(VALID);
!     }
  
+     MZ_GC_UNREG();
      raise_if_error();
      return scheme_void;
  }
  
  /*
   * Predicates
   */
***************
*** 2343,2383 ****
  /*
   * Convert an MzScheme string into a Vim line.
   *
!  * The result is in allocated memory. All internal nulls are replaced by
!  * newline characters. It is an error for the string to contain newline
!  * characters.
   *
   */
      static char *
  string_to_line(Scheme_Object *obj)
  {
!     char	*str;
      long	len;
      int		i;
  
!     str = scheme_display_to_string(obj, &len);
  
      /* Error checking: String must not contain newlines, as we
       * are replacing a single line, and we must replace it with
       * a single line.
       */
!     if (memchr(str, '\n', len))
  	scheme_signal_error(_("string cannot contain newlines"));
  
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
       */
      for (i = 0; i < len; ++i)
      {
! 	if (str[i] == '\0')
! 	    str[i] = '\n';
      }
  
!     str[i] = '\0';
  
!     return str;
  }
  
  /*
   * Check to see whether a Vim error has been reported, or a keyboard
   * interrupt (from vim --> got_int) has been detected.
--- 2612,2784 ----
  /*
   * Convert an MzScheme string into a Vim line.
   *
!  * All internal nulls are replaced by newline characters.
!  * It is an error for the string to contain newline characters.
   *
+  * Returns pointer to Vim allocated memory
   */
      static char *
  string_to_line(Scheme_Object *obj)
  {
!     char	*scheme_str = NULL;
!     char	*vim_str = NULL;
      long	len;
      int		i;
  
!     scheme_str = scheme_display_to_string(obj, &len);
  
      /* Error checking: String must not contain newlines, as we
       * are replacing a single line, and we must replace it with
       * a single line.
       */
!     if (memchr(scheme_str, '\n', len))
  	scheme_signal_error(_("string cannot contain newlines"));
  
+     vim_str = (char *)alloc(len + 1);
+ 
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
       */
      for (i = 0; i < len; ++i)
      {
! 	if (scheme_str[i] == '\0')
! 	    vim_str[i] = '\n';
! 	else
! 	    vim_str[i] = scheme_str[i];
      }
  
!     vim_str[i] = '\0';
  
!     MZ_GC_CHECK();
!     return vim_str;
  }
  
+ #ifdef FEAT_EVAL
+ /*
+  * Convert Vim value into MzScheme, adopted from if_python.c
+  */
+     static Scheme_Object *
+ vim_to_mzscheme(typval_T *vim_value, int depth, Scheme_Hash_Table *visited)
+ {
+     Scheme_Object   *result = NULL;
+     int		    new_value = TRUE;
+ 
+     MZ_GC_DECL_REG(1);
+     MZ_GC_VAR_IN_REG(0, result);
+     MZ_GC_REG();
+ 
+     /* Avoid infinite recursion */
+     if (depth > 100)
+     {
+ 	MZ_GC_UNREG();
+ 	return scheme_void;
+     }
+ 
+     /* Check if we run into a recursive loop.  The item must be in visited
+      * then and we can use it again.
+      */
+     result = scheme_hash_get(visited, (Scheme_Object *)vim_value);
+     MZ_GC_CHECK();
+     if (result != NULL) /* found, do nothing */
+ 	new_value = FALSE;
+     else if (vim_value->v_type == VAR_STRING)
+     {
+ 	result = scheme_make_string((char *)vim_value->vval.v_string);
+ 	MZ_GC_CHECK();
+     }
+     else if (vim_value->v_type == VAR_NUMBER)
+     {
+ 	result = scheme_make_integer((long)vim_value->vval.v_number);
+ 	MZ_GC_CHECK();
+     }
+ # ifdef FEAT_FLOAT
+     else if (vim_value->v_type == VAR_FLOAT)
+     {
+ 	result = scheme_make_double((double)vim_value->vval.v_float);
+ 	MZ_GC_CHECK();
+     }
+ # endif
+     else if (vim_value->v_type == VAR_LIST)
+     {
+ 	list_T		*list = vim_value->vval.v_list;
+ 	listitem_T	*curr;
+ 
+ 	if (list == NULL || list->lv_first == NULL)
+ 	    result = scheme_null;
+ 	else
+ 	{
+ 	    Scheme_Object   *obj = NULL;
+ 
+ 	    MZ_GC_DECL_REG(1);
+ 	    MZ_GC_VAR_IN_REG(0, obj);
+ 	    MZ_GC_REG();
+ 
+ 	    curr = list->lv_last;
+ 	    obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+ 	    result = scheme_make_pair(obj, scheme_null);
+ 	    MZ_GC_CHECK();
+ 
+ 	    while (curr != list->lv_first)
+ 	    {
+ 		curr = curr->li_prev;
+ 		obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+ 		result = scheme_make_pair(obj, result);
+ 		MZ_GC_CHECK();
+ 	    }
+ 	}
+ 	MZ_GC_UNREG();
+     }
+     else if (vim_value->v_type == VAR_DICT)
+     {
+ 	Scheme_Object	  *key = NULL;
+ 	Scheme_Object	  *obj = NULL;
+ 
+ 	MZ_GC_DECL_REG(2);
+ 	MZ_GC_VAR_IN_REG(0, key);
+ 	MZ_GC_VAR_IN_REG(1, obj);
+ 	MZ_GC_REG();
+ 
+ 	result = (Scheme_Object *)scheme_make_hash_table(SCHEME_hash_ptr);
+ 	MZ_GC_CHECK();
+ 	if (vim_value->vval.v_dict != NULL)
+ 	{
+ 	    hashtab_T	*ht = &vim_value->vval.v_dict->dv_hashtab;
+ 	    long_u	todo = ht->ht_used;
+ 	    hashitem_T	*hi;
+ 	    dictitem_T	*di;
+ 
+ 	    for (hi = ht->ht_array; todo > 0; ++hi)
+ 	    {
+ 		if (!HASHITEM_EMPTY(hi))
+ 		{
+ 		    --todo;
+ 
+ 		    di = dict_lookup(hi);
+ 		    obj = vim_to_mzscheme(&di->di_tv, depth + 1, visited);
+ 		    key = scheme_make_string((char *)hi->hi_key);
+ 		    MZ_GC_CHECK();
+ 		    scheme_hash_set((Scheme_Hash_Table *)result, key, obj);
+ 		    MZ_GC_CHECK();
+ 		}
+ 	    }
+ 	}
+ 	MZ_GC_UNREG();
+     }
+     else
+     {
+ 	result = scheme_void;
+ 	new_value = FALSE;
+     }
+     if (new_value)
+     {
+ 	scheme_hash_set(visited, (Scheme_Object *)vim_value, result);
+ 	MZ_GC_CHECK();
+     }
+     MZ_GC_UNREG();
+     return result;
+ }
+ #endif
+ 
  /*
   * Check to see whether a Vim error has been reported, or a keyboard
   * interrupt (from vim --> got_int) has been detected.
***************
*** 2392,2441 ****
   * register Scheme exn:vim
   */
      static void
! register_vim_exn(Scheme_Env *env)
  {
!     Scheme_Object   *exn_name = scheme_intern_symbol("exn:vim");
  
      if (vim_exn == NULL)
  	vim_exn = scheme_make_struct_type(exn_name,
! 		scheme_builtin_value("struct:exn"), NULL, 0, 0, NULL, NULL
  #if MZSCHEME_VERSION_MAJOR >= 299
  		, NULL
  #endif
  		);
  
-     if (vim_exn_values == NULL)
-     {
- 	int	nc = 0;
  
! 	Scheme_Object   **exn_names = scheme_make_struct_names(
! 		exn_name, scheme_null, 0, &nc);
! 	Scheme_Object   **exn_values = scheme_make_struct_values(
! 		vim_exn, exn_names, nc, 0);
! 
! 	vim_exn_names = scheme_make_vector(nc, scheme_false);
! 	vim_exn_values = scheme_make_vector(nc, scheme_false);
! 	/* remember names and values */
! 	mch_memmove(SCHEME_VEC_ELS(vim_exn_names), exn_names,
! 		nc * sizeof(Scheme_Object *));
! 	mch_memmove(SCHEME_VEC_ELS(vim_exn_values), exn_values,
! 		nc * sizeof(Scheme_Object *));
      }
! 
!     add_vim_exn(env);
! }
! 
! /*
!  * Add stuff of exn:vim to env
!  */
!     static void
! add_vim_exn(Scheme_Env *env)
! {
!     int i;
! 
!     for (i = 0; i < SCHEME_VEC_SIZE(vim_exn_values); i++)
! 	scheme_add_global_symbol(SCHEME_VEC_ELS(vim_exn_names)[i],
! 		SCHEME_VEC_ELS(vim_exn_values)[i], env);
  }
  
  /*
--- 2793,2851 ----
   * register Scheme exn:vim
   */
      static void
! register_vim_exn(void)
  {
!     int	nc = 0;
!     int i;
!     Scheme_Object   *struct_exn = NULL;
!     Scheme_Object   *exn_name = NULL;
! 
!     MZ_GC_DECL_REG(2);
!     MZ_GC_VAR_IN_REG(0, struct_exn);
!     MZ_GC_VAR_IN_REG(1, exn_name);
!     MZ_GC_REG();
! 
!     exn_name = scheme_intern_symbol("exn:vim");
!     MZ_GC_CHECK();
!     struct_exn = scheme_builtin_value("struct:exn");
!     MZ_GC_CHECK();
  
      if (vim_exn == NULL)
  	vim_exn = scheme_make_struct_type(exn_name,
! 		struct_exn, NULL, 0, 0, NULL, NULL
  #if MZSCHEME_VERSION_MAJOR >= 299
  		, NULL
  #endif
  		);
  
  
!     {
! 	Scheme_Object   **tmp = NULL;
! 	Scheme_Object   *exn_names[5] = {NULL, NULL, NULL, NULL, NULL};
! 	Scheme_Object   *exn_values[5] = {NULL, NULL, NULL, NULL, NULL};
! 	MZ_GC_DECL_REG(6);
! 	MZ_GC_ARRAY_VAR_IN_REG(0, exn_names, 5);
! 	MZ_GC_ARRAY_VAR_IN_REG(3, exn_values, 5);
! 	MZ_GC_REG();
! 
! 	tmp = scheme_make_struct_names(exn_name, scheme_null, 0, &nc);
! 	assert(nc <= 5);
! 	mch_memmove(exn_names, tmp, nc * sizeof(Scheme_Object *));
! 	MZ_GC_CHECK();
! 
! 	tmp = scheme_make_struct_values(vim_exn, exn_names, nc, 0);
! 	mch_memmove(exn_values, tmp, nc * sizeof(Scheme_Object *));
! 	MZ_GC_CHECK();
! 
! 	for (i = 0; i < nc; i++)
! 	{
! 	    scheme_add_global_symbol(exn_names[i],
! 		    exn_values[i], environment);
! 	    MZ_GC_CHECK();
! 	}
! 	MZ_GC_UNREG();
      }
!     MZ_GC_UNREG();
  }
  
  /*
***************
*** 2444,2469 ****
      void
  raise_vim_exn(const char *add_info)
  {
!     Scheme_Object   *argv[2];
!     char_u	    *fmt = _("Vim error: ~a");
  
      if (add_info != NULL)
      {
! 	Scheme_Object   *info = scheme_make_string(add_info);
! 	argv[0] = scheme_byte_string_to_char_string(scheme_make_string(
! 		scheme_format(fmt, strlen(fmt), 1, &info, NULL)));
  	SCHEME_SET_IMMUTABLE(argv[0]);
      }
      else
  	argv[0] = scheme_make_string(_("Vim error"));
  
  #if MZSCHEME_VERSION_MAJOR < 360
      argv[1] = scheme_current_continuation_marks();
  #else
      argv[1] = scheme_current_continuation_marks(NULL);
  #endif
  
!     scheme_raise(scheme_make_struct_instance(vim_exn, 2, argv));
  }
  
      void
--- 2854,2907 ----
      void
  raise_vim_exn(const char *add_info)
  {
!     char	    *fmt = _("Vim error: ~a");
!     Scheme_Object   *argv[2] = {NULL, NULL};
!     Scheme_Object   *exn = NULL;
! 
!     MZ_GC_DECL_REG(4);
!     MZ_GC_ARRAY_VAR_IN_REG(0, argv, 2);
!     MZ_GC_VAR_IN_REG(3, exn);
!     MZ_GC_REG();
  
      if (add_info != NULL)
      {
! 	char		*c_string = NULL;
! 	Scheme_Object	*byte_string = NULL;
! 	Scheme_Object   *info = NULL;
! 
! 	MZ_GC_DECL_REG(3);
! 	MZ_GC_VAR_IN_REG(0, c_string);
! 	MZ_GC_VAR_IN_REG(1, byte_string);
! 	MZ_GC_VAR_IN_REG(2, info);
! 	MZ_GC_REG();
! 
! 	info = scheme_make_string(add_info);
! 	MZ_GC_CHECK();
! 	c_string = scheme_format(fmt, STRLEN(fmt), 1, &info, NULL);
! 	MZ_GC_CHECK();
! 	byte_string = scheme_make_string(c_string);
! 	MZ_GC_CHECK();
! 	argv[0] = scheme_byte_string_to_char_string(byte_string);
! 	MZ_GC_CHECK();
  	SCHEME_SET_IMMUTABLE(argv[0]);
+ 	MZ_GC_UNREG();
      }
      else
  	argv[0] = scheme_make_string(_("Vim error"));
+     MZ_GC_CHECK();
  
  #if MZSCHEME_VERSION_MAJOR < 360
      argv[1] = scheme_current_continuation_marks();
+     MZ_GC_CHECK();
  #else
      argv[1] = scheme_current_continuation_marks(NULL);
+     MZ_GC_CHECK();
  #endif
  
!     exn = scheme_make_struct_instance(vim_exn, 2, argv);
!     MZ_GC_CHECK();
!     scheme_raise(exn);
!     MZ_GC_UNREG();
  }
  
      void
***************
*** 2570,2575 ****
--- 3008,3015 ----
  	    curwin->w_cursor.lnum = lo;
  	    check_cursor();
  	}
+ 	else
+ 	    check_cursor_col();
  	changed_cline_bef_curs();
      }
      invalidate_botline();
***************
*** 2595,2601 ****
      {mzscheme_open_buffer, "open-buff", 1, 1},
      {get_buffer_by_name, "get-buff-by-name", 1, 1},
      {get_buffer_by_num, "get-buff-by-num", 1, 1},
-     {get_buffer_namespace, "get-buff-namespace", 0, 1},
      /*
       * Window-related commands
       */
--- 3035,3040 ----
***************
*** 2653,2675 ****
  }
  
      static void
! make_modules(Scheme_Env *env)
  {
!     int		i;
!     Scheme_Env	*mod;
! 
!     mod = scheme_primitive_module(scheme_intern_symbol("vimext"), env);
      /* all prims made closed so they can access their own names */
!     for (i = 0; i < sizeof(prims)/sizeof(prims[0]); i++)
      {
  	Vim_Prim *prim = prims + i;
! 	scheme_add_global(prim->name,
! 		scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
! 		    prim->mina, prim->maxa),
! 		mod);
      }
-     scheme_add_global("global-namespace", (Scheme_Object *)environment, mod);
      scheme_finish_primitive_module(mod);
  }
  
  #ifdef HAVE_SANDBOX
--- 3092,3126 ----
  }
  
      static void
! make_modules()
  {
!     int		    i;
!     Scheme_Env	    *mod = NULL;
!     Scheme_Object   *vimext_symbol = NULL;
!     Scheme_Object   *closed_prim = NULL;
! 
!     MZ_GC_DECL_REG(3);
!     MZ_GC_VAR_IN_REG(0, mod);
!     MZ_GC_VAR_IN_REG(1, vimext_symbol);
!     MZ_GC_VAR_IN_REG(2, closed_prim);
!     MZ_GC_REG();
! 
!     vimext_symbol = scheme_intern_symbol("vimext");
!     MZ_GC_CHECK();
!     mod = scheme_primitive_module(vimext_symbol, environment);
!     MZ_GC_CHECK();
      /* all prims made closed so they can access their own names */
!     for (i = 0; i < (int)(sizeof(prims)/sizeof(prims[0])); i++)
      {
  	Vim_Prim *prim = prims + i;
! 	closed_prim = scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
! 			    prim->mina, prim->maxa);
! 	scheme_add_global(prim->name, closed_prim, mod);
! 	MZ_GC_CHECK();
      }
      scheme_finish_primitive_module(mod);
+     MZ_GC_CHECK();
+     MZ_GC_UNREG();
  }
  
  #ifdef HAVE_SANDBOX
***************
*** 2697,2717 ****
--- 3148,3172 ----
  	{
  	    MZ_REGISTER_STATIC(M_write);
  	    M_write = scheme_intern_symbol("write");
+ 	    MZ_GC_CHECK();
  	}
  	if (M_read == NULL)
  	{
  	    MZ_REGISTER_STATIC(M_read);
  	    M_read = scheme_intern_symbol("read");
+ 	    MZ_GC_CHECK();
  	}
  	if (M_execute == NULL)
  	{
  	    MZ_REGISTER_STATIC(M_execute);
  	    M_execute = scheme_intern_symbol("execute");
+ 	    MZ_GC_CHECK();
  	}
  	if (M_delete == NULL)
  	{
  	    MZ_REGISTER_STATIC(M_delete);
  	    M_delete = scheme_intern_symbol("delete");
+ 	    MZ_GC_CHECK();
  	}
  
  	while (!SCHEME_NULLP(requested_access))
*** ../vim-7.2.190/src/if_mzsch.h	2006-03-24 23:43:11.000000000 +0100
--- src/if_mzsch.h	2009-05-26 19:08:21.000000000 +0200
***************
*** 11,16 ****
--- 11,17 ----
  
  /* #ifdef needed for "make depend" */
  #ifdef FEAT_MZSCHEME
+ # include <schvers.h>
  # include <scheme.h>
  #endif
  
***************
*** 46,49 ****
--- 47,77 ----
  # define scheme_byte_string_to_char_string(obj) (obj)
  #endif
  
+ /* Precise GC macros */
+ #ifndef MZ_GC_DECL_REG
+ # define MZ_GC_DECL_REG(size)            /* empty */
+ #endif
+ #ifndef MZ_GC_VAR_IN_REG
+ # define MZ_GC_VAR_IN_REG(x, v)          /* empty */
+ #endif
+ #ifndef MZ_GC_ARRAY_VAR_IN_REG
+ # define MZ_GC_ARRAY_VAR_IN_REG(x, v, l) /* empty */
+ #endif
+ #ifndef MZ_GC_REG
+ # define MZ_GC_REG()                     /* empty */
+ #endif
+ #ifndef MZ_GC_UNREG
+ # define MZ_GC_UNREG()                   /* empty */
+ #endif
+ 
+ #ifdef MZSCHEME_FORCE_GC
+ /*
+  * force garbage collection to check all references are registered
+  * seg faults will indicate not registered refs
+  */
+ # define MZ_GC_CHECK() scheme_collect_garbage();
+ #else
+ # define MZ_GC_CHECK()			/* empty */
+ #endif
+ 
  #endif /* _IF_MZSCH_H_ */
*** ../vim-7.2.190/src/main.c	2009-05-17 13:30:58.000000000 +0200
--- src/main.c	2009-05-26 19:09:01.000000000 +0200
***************
*** 935,942 ****
--- 935,948 ----
  
      /*
       * Call the main command loop.  This never returns.
+      * For embedded MzScheme the main_loop will be called by Scheme
+      * for proper stack tracking
       */
+ #ifndef FEAT_MZSCHEME
      main_loop(FALSE, FALSE);
+ #else
+     mzscheme_main();
+ #endif
  
      return 0;
  }
*** ../vim-7.2.190/src/proto/if_mzsch.pro	2004-07-12 17:51:52.000000000 +0200
--- src/proto/if_mzsch.pro	2009-05-26 19:09:55.000000000 +0200
***************
*** 15,24 ****
  void *mzvim_eval_string __ARGS((char_u *str));
  struct Scheme_Object *mzvim_apply __ARGS((struct Scheme_Object *, int argc,
      struct Scheme_Object **));
! int mzthreads_allowed (void);
! #ifdef FEAT_GUI_KDE
! void timer_proc (void);
! void mzscheme_kde_start_timer (void);
! void mzscheme_kde_stop_timer (void);
! #endif
  /* vim: set ft=c : */
--- 15,20 ----
  void *mzvim_eval_string __ARGS((char_u *str));
  struct Scheme_Object *mzvim_apply __ARGS((struct Scheme_Object *, int argc,
      struct Scheme_Object **));
! int mzthreads_allowed __ARGS((void));
! void mzscheme_main __ARGS((void));
  /* vim: set ft=c : */
*** ../vim-7.2.190/src/version.c	2009-05-26 18:12:13.000000000 +0200
--- src/version.c	2009-05-26 22:52:53.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     191,
  /**/

-- 
Scientists decoded the first message from an alien civilization:
        SIMPLY SEND 6 TIMES 10 TO THE 50 ATOMS OF HYDROGEN TO THE STAR
SYSTEM AT THE TOP OF THE LIST, CROSS OFF THAT STAR SYSTEM, THEN PUT
YOUR STAR SYSTEM AT THE BOTTOM OF THE LIST AND SEND IT TO 100 OTHER
STAR SYSTEMS.  WITHIN ONE TENTH GALACTIC ROTATION YOU WILL RECEIVE
ENOUGH HYDROGREN TO POWER YOUR CIVILIZATION UNTIL ENTROPY REACHES ITS
MAXIMUM!  IT REALLY WORKS!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
