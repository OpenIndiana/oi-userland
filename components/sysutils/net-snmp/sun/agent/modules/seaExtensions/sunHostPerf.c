/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 *
 * U.S. Government Rights - Commercial software. Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and applicable
 * provisions of the FAR and its supplements.
 *
 *
 * This distribution may include materials developed by third parties. Sun,
 * Sun Microsystems, the Sun logo and Solaris are trademarks or registered
 * trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 *
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *         : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <rpcsvc/rstat.h>

#include "sunHostPerf.h"

int hp_cache_lifetime = 45;
time_t rs_cache_time = 0;
time_t hp_cache_now = 0;
static struct statstime sts;
static char hostName[10];

void
get_rstats()
{
    (void) time(&hp_cache_now);

    if ((hp_cache_now - rs_cache_time) <= hp_cache_lifetime)
        return;

    rs_cache_time = hp_cache_now;

    (void) rstat(hostName, &sts);
}

/* Initializes the sunHostPerf module */
void
init_sunHostPerf(void)
{
    static oid rsNiceModeTime_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 2,  0 };
    static oid rsIdleModeTime_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 4,  0 };
    static oid rsVSwapIn_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 11,  0 };
    static oid rsDiskXfer1_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 5,  0 };
    static oid rsDiskXfer2_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 6,  0 };
    static oid rsIfInErrors_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 16,  0 };
    static oid rsDiskXfer3_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 7,  0 };
    static oid rsVSwapOut_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 12,  0 };
    static oid rsVPagesOut_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 10,  0 };
    static oid rsDiskXfer4_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 8,  0 };
    static oid rsSystemProcessTime_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 3,  0 };
    static oid rsIfInPackets_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 14,  0 };
    static oid rsVPagesIn_oid[] = { 1, 3, 6, 1, 4, 1, 42, 3, 13, 9,  0 };
    static oid rsIfOutErrors_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 17,  0 };
    static oid rsUserProcessTime_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 1,  0 };
    static oid rsIfOutPackets_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 15,  0 };
    static oid rsVIntr_oid[] = { 1, 3, 6, 1, 4, 1, 42, 3, 13, 13,  0 };
    static oid rsIfCollisions_oid[] =
                            { 1, 3, 6, 1, 4, 1, 42, 3, 13, 18,  0 };

    DEBUGMSGTL(("sunHostPerf", "Initializing\n"));

    /* Initialize host, current time */
    strcpy(hostName, "localhost");
    (void) time(&hp_cache_now);

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsNiceModeTime",
                                    get_rsNiceModeTime,
                                    rsNiceModeTime_oid,
                                    OID_LENGTH(rsNiceModeTime_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsIdleModeTime",
                                    get_rsIdleModeTime,
                                    rsIdleModeTime_oid,
                                    OID_LENGTH(rsIdleModeTime_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsVSwapIn",
                                    get_rsVSwapIn,
                                    rsVSwapIn_oid,
                                    OID_LENGTH(rsVSwapIn_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsDiskXfer1",
                                    get_rsDiskXfer1,
                                    rsDiskXfer1_oid,
                                    OID_LENGTH(rsDiskXfer1_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsDiskXfer2",
                                    get_rsDiskXfer2,
                                    rsDiskXfer2_oid,
                                    OID_LENGTH(rsDiskXfer2_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsIfInErrors",
                                    get_rsIfInErrors,
                                    rsIfInErrors_oid,
                                    OID_LENGTH(rsIfInErrors_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsDiskXfer3",
                                    get_rsDiskXfer3,
                                    rsDiskXfer3_oid,
                                    OID_LENGTH(rsDiskXfer3_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsVSwapOut",
                                    get_rsVSwapOut,
                                    rsVSwapOut_oid,
                                    OID_LENGTH(rsVSwapOut_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsVPagesOut",
                                    get_rsVPagesOut,
                                    rsVPagesOut_oid,
                                    OID_LENGTH(rsVPagesOut_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsDiskXfer4",
                                    get_rsDiskXfer4,
                                    rsDiskXfer4_oid,
                                    OID_LENGTH(rsDiskXfer4_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsSystemProcessTime",
                                    get_rsSystemProcessTime,
                                    rsSystemProcessTime_oid,
                                    OID_LENGTH(rsSystemProcessTime_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsIfInPackets",
                                    get_rsIfInPackets,
                                    rsIfInPackets_oid,
                                    OID_LENGTH(rsIfInPackets_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsVPagesIn",
                                    get_rsVPagesIn,
                                    rsVPagesIn_oid,
                                    OID_LENGTH(rsVPagesIn_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsIfOutErrors",
                                    get_rsIfOutErrors,
                                    rsIfOutErrors_oid,
                                    OID_LENGTH(rsIfOutErrors_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsUserProcessTime",
                                    get_rsUserProcessTime,
                                    rsUserProcessTime_oid,
                                    OID_LENGTH(rsUserProcessTime_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsIfOutPackets",
                                    get_rsIfOutPackets,
                                    rsIfOutPackets_oid,
                                    OID_LENGTH(rsIfOutPackets_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsVIntr",
                                    get_rsVIntr,
                                    rsVIntr_oid,
                                    OID_LENGTH(rsVIntr_oid),
                                    HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                    ("rsIfCollisions",
                                    get_rsIfCollisions,
                                    rsIfCollisions_oid,
                                    OID_LENGTH(rsIfCollisions_oid),
                                    HANDLER_CAN_RONLY));
}

int
get_rsNiceModeTime(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    long cp_time;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        cp_time = (long)sts.cp_time[RSTAT_CPU_NICE];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &cp_time, sizeof (cp_time));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsIdleModeTime(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    long cp_time;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        cp_time = (long)sts.cp_time[RSTAT_CPU_IDLE];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &cp_time, sizeof (cp_time));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsVSwapIn(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    u_long v_pswpin;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        v_pswpin = (u_long)sts.v_pswpin;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &v_pswpin, sizeof (v_pswpin));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsDiskXfer1(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    long dk_xfer;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        dk_xfer = (long)sts.dk_xfer[0];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &dk_xfer, sizeof (dk_xfer));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsDiskXfer2(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    long dk_xfer;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
    */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        dk_xfer = sts.dk_xfer[1];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &dk_xfer, sizeof (dk_xfer));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsIfInErrors(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    long if_ierrors;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        if_ierrors = (long)sts.if_ierrors;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &if_ierrors, sizeof (if_ierrors));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsDiskXfer3(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    long dk_xfer;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        dk_xfer = (long)sts.dk_xfer[2];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &dk_xfer, sizeof (dk_xfer));
        break;


    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsVSwapOut(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    u_long v_pswpout;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        v_pswpout = (u_long)sts.v_pswpout;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &v_pswpout, sizeof (v_pswpout));
        break;


    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsVPagesOut(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    u_long v_pgpgout;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        v_pgpgout = (u_long)sts.v_pgpgout;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &v_pgpgout, sizeof (v_pgpgout));
        break;


    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsDiskXfer4(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    long dk_xfer;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        dk_xfer = (long)sts.dk_xfer[3];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &dk_xfer, sizeof (dk_xfer));
        break;


    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsSystemProcessTime(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    long cp_time;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        cp_time = (long)sts.cp_time[RSTAT_CPU_SYS];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &cp_time, sizeof (cp_time));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsIfInPackets(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    long if_ipackets;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        if_ipackets = (long)sts.if_ipackets;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &if_ipackets, sizeof (if_ipackets));
        break;


    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsVPagesIn(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    u_long v_pgpgin;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        v_pgpgin = (u_long)sts.v_pgpgin;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &v_pgpgin, sizeof (v_pgpgin));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsIfOutErrors(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    long if_oerrors;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        if_oerrors = (long)sts.if_oerrors;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &if_oerrors, sizeof (if_oerrors));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsUserProcessTime(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    long cp_time;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        cp_time = sts.cp_time[RSTAT_CPU_USER];
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &cp_time, sizeof (cp_time));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsIfOutPackets(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    long if_opackets;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        if_opackets = (long)sts.if_opackets;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &if_opackets, sizeof (if_opackets));
        break;


    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsVIntr(netsnmp_mib_handler *handler,
            netsnmp_handler_registration *reginfo,
            netsnmp_agent_request_info *reqinfo,
            netsnmp_request_info *requests)
{
    u_long v_intr;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        v_intr = (u_long)sts.v_intr;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &v_intr, sizeof (v_intr));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}

int
get_rsIfCollisions(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    long if_collisions;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        get_rstats();
        if_collisions = (long)sts.if_collisions;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &if_collisions, 
                                 sizeof (if_collisions));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        return (SNMP_ERR_GENERR);
    }

    return (SNMP_ERR_NOERROR);
}
