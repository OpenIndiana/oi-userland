From 45a488481f4a32cd7bcf5f72c39e587a32b7edba Mon Sep 17 00:00:00 2001
From: Karl Williamson <khw@cpan.org>
Date: Fri, 2 Feb 2018 15:14:27 -0700
Subject: (perl #132227) restart a node if we change to uni rules within the
 node and encounter a sharp S

This could lead to a buffer overflow.

Test case trivially backported from the corresponding blead fix by Niko Tyni.

Origin: backport
Bug: https://rt.perl.org/Public/Bug/Display.html?id=132227
Patch-Name: fixes/CVE-2018-6797.diff
---
 regcomp.c           | 12 ++++++++++++
 t/re/pat_advanced.t |  4 ++++
 2 files changed, 16 insertions(+)

diff --git a/regcomp.c b/regcomp.c
index 29b1ffe7c..1b84be0b4 100644
--- a/regcomp.c
+++ b/regcomp.c
@@ -13319,6 +13319,18 @@ S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
                          * /u.  This includes the multi-char fold SHARP S to
                          * 'ss' */
                         if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {
+
+                            /* If the node started out having uni rules, we
+                             * wouldn't have gotten here.  So this means
+                             * something in the middle has changed it, but
+                             * didn't think it needed to reparse.  But this
+                             * sharp s now does indicate the need for
+                             * reparsing. */
+                            if (RExC_uni_semantics) {
+                                p = oldp;
+                                goto loopdone;
+                            }
+
                             RExC_seen_unfolded_sharp_s = 1;
                             maybe_exactfu = FALSE;
                         }
diff --git a/t/re/pat_advanced.t b/t/re/pat_advanced.t
index 913e84662..1c11e446e 100644
--- a/t/re/pat_advanced.t
+++ b/t/re/pat_advanced.t
@@ -2369,6 +2369,10 @@ EOF
         unlike("s\N{U+DF}", qr/^\x{00DF}/i, "\"s\\N{U+DF}\", qr/^\\x{00DF}/i");
     }
 
+    {   # Bug #132227, caused failed assertion
+        ok(qr/0b\N{U+41}\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF/i, "No seqgfault [perl #132227]");
+    }
+
     # User-defined Unicode properties to match above-Unicode code points
     sub Is_32_Bit_Super { return "110000\tFFFFFFFF\n" }
     sub Is_Portable_Super { return '!utf8::Any' }   # Matches beyond 32 bits
