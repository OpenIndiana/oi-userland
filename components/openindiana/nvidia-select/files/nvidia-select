#! /bin/sh

#
# This file and its contents are supplied under the terms of the
# Common Development and Distribution License ("CDDL"), version 1.0.
# You may only use this file in accordance with the terms of version
# 1.0 of the CDDL.
#
# A full copy of the text of the CDDL should have accompanied this
# source.  A copy of the CDDL is also available via the Internet at
# http://www.illumos.org/license/CDDL.
#
# Copyright 2017, Jim Klimov
# Portions Copyright 2003-2005 Sun Microsystems, Inc.  All rights reserved.
#

#
# Select one of the installed mediatable NVidia drivers
# as the one to run for your current system under BASEDIR.
# This should be executed as root (or sufficiently privileged user).
#

DRV="nvidia"
# When guessing in auto mode and there is no good hint from prtinfo etc.,
# pick this version as the legacy default - the only one provided previously.
DISTRO_DEFAULT_VERSION="340"

# From driver makefiles:
# NVIDIA_MEDIATOR="mediator=nvidia-drv mediator-implementation=nvidia-drv-proprietary mediator-version=$(NVIDIA_DRIVER_MAJOR_VERSION)"
MEDIATOR_NAME="nvidia-drv"
MEDIATOR_IMPL="nvidia-drv-proprietary"

PATH="/usr/sbin:/sbin:/usr/bin:/bin:$PATH"
LANG=C
LC_ALL=C
TZ=UTC
export PATH LANG LC_ALL TZ

die() {
    echo "FATAL: $*" >&2
    exit 1
}

usage() {
    cat << EOF
Usage: $0 [-R dirname] {select VERSION | uninstall}
    -R dirname  Manipulate system image in an alternate boot
                environment under dirname
    uninstall   Remove nvidia driver from driver_aliases (if any)
    select VER  (Verify that the request is valid, and) Uninstall
                an existing setup, if any, and add the driver_aliases
                entries for the chosen major version - if it is
                installed on your system. Also mediate the symlinks
                to point to this version's drivers, libraries and
                other files via default system paths.
                A version named "auto" (the default) would guess the
                best driver for you - be careful.
    --update-smf    Updates "options/NVIDIA_VERSION" in \$SMF_FMRI
                (defaults to svc:/system/nvidia-select:default)
EOF
}

uninstall() {
    if grep "\<nvidia\>" "$BASEDIR"/etc/name_to_major > /dev/null 2>&1 ; then
        rem_drv -b "$BASEDIR" "$DRV"
    fi
}

list_available_versions() {
    # Return the number after "/usr/share/nvidia-" prefix, which happens
    # to be part of the IPS mediation tag too.
    ls -1d "$BASEDIR"/usr/share/nvidia-* \
        | sed 's,^.*/nvidia-,,' | sort -n
}

detect_best_version() {
    # Use the distro default if available, or newest version otherwise.
    # TODO: Make this smarter, e.g. following prtconf lookup of existing
    # devices and matching against provided driver_aliases snippets, and
    # then pick the newest candidate. At a later point this can refer to
    # some sort of database of some known device-vs-driver best matches.

    AVAILABLE_VERSIONS="`list_available_versions`" || AVAILABLE_VERSIONS=""
    [ -n "$AVAILABLE_VERSIONS" ] || return

    if echo "$AVAILABLE_VERSIONS" | grep -w "$DISTRO_DEFAULT_VERSION" >/dev/null ; then
        echo "$DISTRO_DEFAULT_VERSION"
        return 0
    fi

    echo "$AVAILABLE_VERSIONS" | tail -1
}

check_add_drv()
{
# Function: check_add_drv()
#
# This function will check if the module has an entry in etc/name_to_major
# If not simply calls add_drv with the arguments given. If there is
# such an entry in name_to_major file, it adds entries in driver_aliases
# driver_classes and minor_perm if necessary.
# The syntax of this function is the same as add_drv.

    alias=""
    class=""
    ADD_ALIAS=0
    ADD_CLASS=0
    ADD_MINOR=0
    OPTIND=1
    IS_NET_DRIVER=0

    cmd="add_drv"

    NO_CMD=
    while getopts i:b:m:c:N  opt
    do
        case $opt in
            N ) NO_CMD=1;;
            i ) ADD_ALIAS=1
                alias="$OPTARG"
                cmd="$cmd -i '$alias'"
                ;;
            m ) ADD_MINOR=1
                minor="$OPTARG"
                cmd="$cmd -m '$minor'"
                ;;
            c)  ADD_CLASS=1
                class="$OPTARG"
                cmd="$cmd -c $class"
                ;;
            b)  BASEDIR="$OPTARG"
                cmd="$cmd -b $BASEDIR"
                ;;
            \?)     echo "check_add_drv can not handle this option"
                return
                ;;
            esac
    done
    shift "`/usr/bin/expr $OPTIND - 1`"

    drvname="$1"
    cmd="$cmd $drvname"
    drvname="`echo $drvname | /usr/bin/sed 's;.*/;;g'`"

    /usr/bin/grep "^$drvname[   ]" $BASEDIR/etc/name_to_major >  /dev/null 2>&1

    if [ "$NO_CMD" = "" -a $? -ne 0 ]
    then
        eval $cmd
    else
        # entry already in name_to_major, add alias, class, minorperm
        # if necessary
        if [ $ADD_ALIAS = 1 ]
        then
            for i in $alias
            do
                /usr/bin/egrep "^$drvname[  ]+$i" $BASEDIR/etc/driver_aliases>/dev/null 2>&1
                if [ $? -ne 0 ]
                then
                    echo "$drvname $i" >> $BASEDIR/etc/driver_aliases
                fi
            done
        fi

        if [ $ADD_CLASS = 1 ]
        then
            /usr/bin/egrep "^$drvname[  ]+$class( | |$)" $BASEDIR/etc/driver_classes > /dev/null 2>&1
            if [ $? -ne 0 ]
            then
                echo "$drvname\t$class" >> $BASEDIR/etc/driver_classes
            fi
        fi

        if [ $ADD_MINOR = 1 ]
        then
            /usr/bin/grep "^$drvname:" $BASEDIR/etc/minor_perm > /dev/null 2>&1
            if [ $? -ne 0 ]
            then
                minorentry="$drvname:$minor"
                echo $minorentry >> $BASEDIR/etc/minor_perm
            fi
        fi
    fi
}

unload_drv() {
    # NOTE: If the driver is not loaded, there is no fault here
    DRV_PATH="$1"
    DRV="`basename "$DRV_PATH"`"

    echo "INFO: Trying to unload the kernel driver $DRV..." 2>&1
    OLD_DRV="`/usr/sbin/modinfo | awk '( $6 == "'"$DRV"'") { print $0 }'`" \
    || OLD_DRV=""
    eval OLD_DRV_${DRV}=\""$OLD_DRV"\"

    if [ -n "$OLD_DRV" ] ; then
        echo "INFO: Old driver info:" >&2
        echo "$OLD_DRV" >&2
        OLD_DRV_ID="`echo "$OLD_DRV" | head -1 | awk '{print $1}'`"
        [ -n "$OLD_DRV_ID" ] && /usr/sbin/modunload -i "$OLD_DRV_ID" \
            || { echo "FAILED to unload the old kernel driver $DRV..." ; return 1; }
    fi
}

load_drv() {
    # NOTE: Uses OLD_DRV data set by unload_drv above
    DRV_PATH="$1"
    DRV="`basename "$DRV_PATH"`"

    echo "INFO: Trying to (re)load the kernel driver $DRV..." 2>&1
    [ -s "$DRV_PATH" ] || { echo "SKIP: No such file: $DRV_PATH" >&2; return 1; }

    ACTUAL_DRV_PATH=""
    case "`isainfo`" in
        *amd64*)
            ACTUAL_DRV_PATH="`dirname "$DRV_PATH"`/amd64/$DRV" ;;
        *sparcv9*)
            ACTUAL_DRV_PATH="`dirname "$DRV_PATH"`/sparcv9/$DRV" ;;
        *i386*|*sparcv7*)
            ACTUAL_DRV_PATH="$DRV_PATH" ;;
        *)  echo "FAILED to detect an ACTUAL_DRV_PATH for the new kernel driver $DRV : Unexpected architecture: `isainfo`" >&2
            return 2
            ;;
    esac

    if [ -z "$ACTUAL_DRV_PATH" ] ; then
        echo "FAILED to detect an ACTUAL_DRV_PATH for the new kernel driver $DRV" >&2
    fi

    if [ ! -s "$ACTUAL_DRV_PATH" ] ; then
        if [ "$LOAD_DRV_SKIP_ABSENT" = true ] ; then
            echo "SKIPPED loading '$ACTUAL_DRV_PATH' for the new kernel driver $DRV: File not found (and not required)" >&2
            return 0
        fi
        echo "FAILED to load '$ACTUAL_DRV_PATH' for the new kernel driver $DRV: File not found (and is required)" >&2
        return 3
    fi

    modload "$ACTUAL_DRV_PATH" \
    || { echo "FAILED to load the new kernel driver $DRV..." >&2 ; return 4; }

    NEW_DRV="`/usr/sbin/modinfo | awk '( $6 == "'"$DRV"'") { print $0 }'`" \
    || NEW_DRV=""
    eval NEW_DRV_${DRV}=\""$NEW_DRV"\"
    eval OLD_DRV=\""\$OLD_DRV_${DRV}"\"

    if [ -n "$NEW_DRV" ] ; then
        if [ "$NEW_DRV" = "$OLD_DRV" ] ; then
            echo "INFO: New $DRV driver seems to be same as the old one" >&2
        else
            echo "INFO: New $DRV driver info:" >&2
            echo "$NEW_DRV" >&2
        fi
    else
        echo "WARNING: FAILED to find any details about the newly loaded driver $DRV" >&2
    fi
}

reload_drv() {
    unload_drv "$@"
    load_drv "$@"
}


if [ -z "${BASEDIR-}" ]; then
    BASEDIR="/"
fi

if [ -z "${NVIDIA_VERSION-}" ]; then
    NVIDIA_VERSION="auto"
fi

[ -n "${SMF_FMRI-}" ] || SMF_FMRI="svc:/system/nvidia-select:default"

SMF_ACTION=""
USER_ACTION=""
UPDATE_SMF="no"
while [ "$#" -gt 0 ]; do
    case "$1" in
        -h|--help|-help) usage ; exit 0 ;;
        -R) BASEDIR="$2"; shift ;;
        select) USER_ACTION="$1"; NVIDIA_VERSION="$2"; shift ;;
        uninstall) USER_ACTION="$1"; NVIDIA_VERSION="none" ;;
        --update-smf) UPDATE_SMF="yes" ;;
        start|refresh) SMF_ACTION="$1" ;;
        stop) exit 0 ;;
        *)  die "Unsuported argument: $1" ;;
    esac
    shift
done

[ -d "$BASEDIR" ] || \
    die "Non-existent BASEDIR requested: $BASEDIR"

# Note: no BASEDIR for SMF commands, these are assumed to run when this
# boot environment is actually running, so for it then the BASEDIR=="/"
NVIDIA_VERSION_SMF=""
if [ -n "$SMF_ACTION" ]; then
    svccfg -s "$SMF_FMRI" addpg options application 2>/dev/null || true
    NVIDIA_VERSION_SMF="`svcprop -p options/NVIDIA_VERSION $SMF_FMRI`" \
        && [ -n "$NVIDIA_VERSION_SMF" ] && NVIDIA_VERSION="$NVIDIA_VERSION_SMF"

    if [ "$SMF_ACTION" = start ] \
    && [ -d "$BASEDIR/usr/share/nvidia-$NVIDIA_VERSION" ] \
    ; then
        echo "SKIP: Driver already at a defined major version $NVIDIA_VERSION, and it is still installed" >&2
        exit 0
    fi

    if [ "$SMF_ACTION" = refresh ] \
    && [ -z "`ls -1d "$BASEDIR/usr/share/nvidia-"{0,1,2,3,4,5,6,7,8,9}* 2>/dev/null`" ] \
    ; then
        echo "NOTE: Last driver removed, uninstalling driver associations and reverting service to "auto" mode to try to re-detect something among installed packages..." >&2
        svccfg -s "$SMF_FMRI" setprop "options/NVIDIA_VERSION" = astring: auto
        uninstall
        exit
    fi

    if [ "$SMF_ACTION" = refresh ] \
    && [ "$NVIDIA_VERSION" -gt 0 ] 2>/dev/null \
    && [ ! -d "$BASEDIR/usr/share/nvidia-$NVIDIA_VERSION" ] \
    ; then
        echo "NOTE: NVIDIA_VERSION='$NVIDIA_VERSION' previously saved in SMF is no longer available; will try to re-detect something among installed packages" >&2
        NVIDIA_VERSION="auto"
    fi
fi

# In case of SMF refresh, if there was an NVIDIA_VERSION already set up,
# then it would still be used, unless that driver major version got removed
case "$NVIDIA_VERSION" in
    none) uninstall; exit ;;
    auto) NVIDIA_VERSION="`detect_best_version`" ;;
    nvidia-[0-9]*)
        NVIDIA_VERSION="`echo "$NVIDIA_VERSION" | sed 's,^nvidia-,,'`" ;;
esac


if [ -z "$NVIDIA_VERSION" ] \
|| [ ! -d "$BASEDIR/usr/share/nvidia-$NVIDIA_VERSION" ] \
; then
    die "Could not detect an NVIDIA_VERSION, or it is not installed: " \
        "got '$NVIDIA_VERSION'"
fi

if [ "$BASEDIR" = / ]; then
    echo "INFO: unloading old drivers ..." >&2
    unload_drv /kernel/drv/nvidia_modeset
    unload_drv /kernel/drv/nvidia
    unload_drv /kernel/misc/gfx_private
fi

echo "INFO: uninstalling driver associations under $BASEDIR ..." >&2
uninstall
[ "$USER_ACTION" = uninstall ] && exit 0

ALTROOT_FLAG=""
[ "$BASEDIR" = "/" ] || ALTROOT_FLAG="chroot '$BASEDIR'"

EXISTING_MEDIATOR_DATA="`$ALTROOT_FLAG /usr/bin/pkg mediator -H -Ftsv "$MEDIATOR_NAME"`" \
&& [ -n "${EXISTING_MEDIATOR_DATA-}" ] \
|| EXISTING_MEDIATOR_DATA=""

if [ -n "${EXISTING_MEDIATOR_DATA-}" ] ; then
    if [ x"`echo "$EXISTING_MEDIATOR_DATA" | awk '{print $1}'`" = x"$MEDIATOR_NAME" ] \
    && [ x"`echo "$EXISTING_MEDIATOR_DATA" | awk '{print $NF}'`" = x"$MEDIATOR_IMPL" ] \
    && [ x"`echo "$EXISTING_MEDIATOR_DATA" | awk '{print $3}'`" = x"$NVIDIA_VERSION" ] \
    ; then
        echo "INFO: mediator $MEDIATOR_NAME already set to $MEDIATOR_IMPL / $NVIDIA_VERSION under $BASEDIR ..." >&2
    else
        # Cause setting up the mediator below
        EXISTING_MEDIATOR_DATA=""
    fi
fi

if [ -z "${EXISTING_MEDIATOR_DATA-}" ] ; then
    echo "INFO: setting mediator $MEDIATOR_NAME to $MEDIATOR_IMPL / $NVIDIA_VERSION under $BASEDIR ..." >&2
    $ALTROOT_FLAG /usr/bin/pkg set-mediator \
        --no-backup-be --deny-new-be --no-be-activate --no-index \
        -I "$MEDIATOR_IMPL" -V "$NVIDIA_VERSION" "$MEDIATOR_NAME" \
        || die "Failed ($?) to select mediator version $NVIDIA_VERSION"
fi

# This file is provided by each nvidia-XYZ package we ship
if [ -s "$BASEDIR/usr/share/nvidia-$NVIDIA_VERSION/driver_aliases.txt" ] ; then
    echo "INFO: installing driver associations under $BASEDIR ..." >&2
    ALIASES="`cat "$BASEDIR/usr/share/nvidia-$NVIDIA_VERSION/driver_aliases.txt" | tr '[\\\n]' ' ' | sed 's,alias=\"\([^\"]*\)\",\1 ,g'`"
    check_add_drv -b "${BASEDIR}" -i "${ALIASES}" \
        -m '* 0666 root root' "${DRV}"
    touch "${BASEDIR}/reconfigure"
fi

if [ -n "$SMF_ACTION" ] || [ "$BASEDIR" = / -a "$UPDATE_SMF" = "yes" ] ; then
    echo "INFO: updating service properties under $BASEDIR ..." >&2
    svccfg -s "$SMF_FMRI" addpg options application 2>/dev/null || true
    svccfg -s "$SMF_FMRI" setprop "options/NVIDIA_VERSION" = astring: "$NVIDIA_VERSION" \
        || die "Failed to remember NVIDIA_VERSION='$NVIDIA_VERSION' into SMF properties for '$SMF_FMRI'"
fi

# TOTHINK: Should any failures here be fatal?
# e.g. mismatch of drv vs. hw?..
if [ "$BASEDIR" = / ]; then
    echo "INFO: loading new drivers ..." >&2
    LOAD_DRV_SKIP_ABSENT=true load_drv /kernel/misc/gfx_private
    load_drv /kernel/drv/nvidia
    LOAD_DRV_SKIP_ABSENT=true load_drv /kernel/drv/nvidia_modeset

    echo "NOTE: if (re)loading of drivers failed, you may have to reboot ..." >&2
fi

echo "NOTE: Consider also configuring ogl-select for nvidia:" >&2
echo "  svccfg -s ogl-select setprop options/vendor = nvidia" >&2
echo "  svcadm restart ogl-select" >&2
echo "Its current setting is: `svcprop -p options/vendor ogl-select`">&2

exit 0
