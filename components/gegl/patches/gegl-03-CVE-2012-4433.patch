--- gegl-0.1.2/operations/external/ppm-load.c.orig	2013-03-26 16:10:42.398086127 +0530
+++ gegl-0.1.2/operations/external/ppm-load.c	2013-03-26 16:13:34.660274946 +0530
@@ -36,6 +36,7 @@ gegl_chant_file_path (path, _("File"), "
 #include "gegl-chant.h"
 #include <stdio.h>
 #include <stdlib.h>
+#include <errno.h>
 
 typedef enum {
   PIXMAP_ASCII  = 51,
@@ -44,78 +45,165 @@ typedef enum {
 
 typedef struct {
 	map_type   type;
-	gint       width;
-	gint       height;
-        gint       size;
-	gint       maxval;
+	glong      width;
+	glong      height;
+	gsize      numsamples; /* width * height * channels */
+	gsize      bpc;        /* bytes per channel */
 	guchar    *data;
 } pnm_struct;
 
-void
+static gboolean
 ppm_load_read_header(FILE       *fp,
                      pnm_struct *img);
-void
+static void
 ppm_load_read_image(FILE       *fp,
                     pnm_struct *img);
 
-void
+static gboolean
 ppm_load_read_header(FILE       *fp,
                      pnm_struct *img)
   {
     /* PPM Headers Variable Declaration */
     gchar *ptr;
-    gchar *retval;
     gchar  header[MAX_CHARS_IN_ROW];
+    gint   maxval; 
 
-    /* Check the PPM file Type P2 or P5 */
-    retval = fgets (header,MAX_CHARS_IN_ROW,fp);
+    /* Check the PPM file Type P3 or P6 */
+    fgets (header,MAX_CHARS_IN_ROW,fp);
 
     if (header[0] != ASCII_P ||
         (header[1] != PIXMAP_ASCII && 
          header[1] != PIXMAP_RAW
         )
        )
-      printf ("Image is not a portable pixmap\n");
+      {
+	g_warning ("Image is not a portable pixmap");
+	return FALSE;
+      }
 
     img->type = header[1];
 
     /* Check the Comments */
-    retval = fgets (header,MAX_CHARS_IN_ROW,fp);
+    fgets (header,MAX_CHARS_IN_ROW,fp);
     while(header[0] == '#')
       {
-        retval = fgets (header,MAX_CHARS_IN_ROW,fp);
+        fgets (header,MAX_CHARS_IN_ROW,fp);
       }
 
     /* Get Width and Height */
-    img->width  = strtol (header,&ptr,0);
-    img->height = atoi (ptr);
+    errno = 0;
+    img->width  = strtol (header,&ptr,10);
+    if (errno)
+      {
+        g_warning ("Error reading width: %s", strerror(errno));
+        return FALSE;
+      }
+    else if (img->width < 0)
+      {
+        g_warning ("Error: width is negative");
+        return FALSE;
+      }
 
-    img->size = img->width * img->height * sizeof (guchar) * CHANNEL_COUNT;
+    img->height = strtol (ptr,&ptr,10);
+    if (errno)
+      {
+        g_warning ("Error reading height: %s", strerror(errno));
+        return FALSE;
+      }
+    else if (img->width < 0)
+      {
+        g_warning ("Error: height is negative");
+        return FALSE;
+      }
+
+    fgets (header,MAX_CHARS_IN_ROW,fp);
+    maxval = strtol (header,&ptr,10);
+
+    if ((maxval != 255) && (maxval != 65535))
+      {
+        g_warning ("Image is not an 8-bit or 16-bit portable pixmap");
+        return FALSE;
+      }
+
+  switch (maxval)
+    {
+    case 255:
+      img->bpc = sizeof (guchar);
+      break;
+
+    case 65535:
+      img->bpc = sizeof (gushort);
+      break;
+
+    default:
+      g_warning ("%s: Programmer stupidity error", G_STRLOC);
+    }
+
+    /* Later on, img->numsamples is multiplied with img->bpc to allocate
+     * memory. Ensure it doesn't overflow. */
+    if (!img->width || !img->height ||
+        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)
+      {
+        g_warning ("Illegal width/height: %ld/%ld", img->width, img->height);
+        return FALSE;
+      }
+    img->numsamples = img->width * img->height * CHANNEL_COUNT;
 
-    retval = fgets (header,100,fp);
-    /* Maxval is not used */
-    img->maxval = (int) strtol (header,&ptr,0);
+    return TRUE;
   }
 
-void
+static void
 ppm_load_read_image(FILE       *fp,
                     pnm_struct *img)
  {
-    gint    i;
-    gint    retval;
-    guchar *ptr;
+    guint    i;
 
     if (img->type == PIXMAP_RAW)
       {
-        /* Pixel Extraction */
-        retval = fread (img->data, 1, img->size, fp);
+        fread (img->data, img->bpc, img->numsamples, fp);
+
+        /* Fix endianness if necessary */
+        if (img->bpc > 1)
+          {
+            gushort *ptr = (gushort *) img->data;
+
+            for (i=0; i < img->numsamples; i++)
+              {
+                *ptr = GUINT16_FROM_BE (*ptr);
+                ptr++;
+              }
+          }
       }
     else
       {
-        ptr = img->data;
+        /* Plain PPM format */
 
-        for (i=0; i<img->size; i++)
-          retval = fscanf (fp, " %d", (int *) ptr++);
+        if (img->bpc == sizeof (guchar))
+          {
+            guchar *ptr = img->data;
+
+            for (i = 0; i < img->numsamples; i++)
+              {
+                guint sample;
+                fscanf (fp, " %u", &sample);
+                *ptr++ = sample;
+              }
+          }
+        else if (img->bpc == sizeof (gushort))
+          {
+            gushort *ptr = (gushort *) img->data;
+
+            for (i = 0; i < img->numsamples; i++)
+              {
+                guint sample;
+                fscanf (fp, " %u", &sample);
+                *ptr++ = sample;
+              }
+          }
+        else
+          {
+            g_warning ("%s: Programmer stupidity error", G_STRLOC);
+          }
       }
   }
 
@@ -130,20 +218,33 @@ get_bounding_box (GeglOperation *operati
   fp = (!strcmp (o->path, "-") ? stdin : fopen (o->path,"rb") );
 
   if (!fp)
-    {
-      return result;
-    }
-  ppm_load_read_header (fp, &img);
+    return result;
 
-  if (stdin != fp)
+  if (!ppm_load_read_header (fp, &img))
+    goto out;
+
+  switch (img.bpc)
     {
-      fclose (fp);
+    case 1:
+      gegl_operation_set_format (operation, "output",
+                                 babl_format ("R'G'B' u8"));
+      break;
+
+    case 2:
+      gegl_operation_set_format (operation, "output",
+                                 babl_format ("R'G'B' u16"));
+      break;
+
+    default:
+      g_warning ("%s: Programmer stupidity error", G_STRLOC);
     }
 
-  gegl_operation_set_format (operation, "output", babl_format ("R'G'B' u8"));
+  result.width = img.width;
+  result.height = img.height;
 
-  result.width  = img.width;
-  result.height  = img.height;
+ out:
+  if (stdin != fp)
+    fclose (fp);
 
   return result;
 }
@@ -157,35 +258,77 @@ process (GeglOperation       *operation,
   FILE         *fp;
   pnm_struct    img;
   GeglRectangle rect = {0,0,0,0};
+  gboolean      ret = FALSE;
 
   fp = (!strcmp (o->path, "-") ? stdin : fopen (o->path,"rb"));
 
   if (!fp)
+    return FALSE;
+
+  if (!ppm_load_read_header (fp, &img))
+    goto out;
+
+  /* Allocating Array Size */
+
+  /* Should use g_try_malloc(), but this causes crashes elsewhere because the
+   * error signalled by returning FALSE isn't properly acted upon. Therefore
+   * g_malloc() is used here which aborts if the requested memory size can't be
+   * allocated causing a controlled crash. */
+  img.data = (guchar*) g_malloc (img.numsamples * img.bpc);
+
+  /* No-op without g_try_malloc(), see above. */
+  if (! img.data)
     {
-      return FALSE;
+      g_warning ("Couldn't allocate %" G_GSIZE_FORMAT " bytes, giving up.", ((gsize)img.numsamples * img.bpc));
+      goto out;
     }
 
-  ppm_load_read_header (fp, &img);
   rect.height = img.height;
   rect.width = img.width;
 
-  /* Allocating Array Size */
-  img.data = (guchar*) g_malloc0 (img.size);
+  switch (img.bpc)
+    {
+    case 1:
+      gegl_buffer_get (output, 1.0, &rect, babl_format ("R'G'B' u8"), img.data,
+                       GEGL_AUTO_ROWSTRIDE);
+      break;
+
+    case 2:
+      gegl_buffer_get (output, 1.0, &rect, babl_format ("R'G'B' u16"), img.data,
+                       GEGL_AUTO_ROWSTRIDE);
+      break;
 
-  gegl_buffer_get (output, 1.0, &rect, babl_format ("R'G'B' u8"), img.data,
-          GEGL_AUTO_ROWSTRIDE);
+    default:
+      g_warning ("%s: Programmer stupidity error", G_STRLOC);
+    }
 
   ppm_load_read_image (fp, &img);
 
-  gegl_buffer_set (output, &rect, babl_format ("R'G'B' u8"), img.data,
-          GEGL_AUTO_ROWSTRIDE);
+  switch (img.bpc)
+    {
+    case 1:
+      gegl_buffer_set (output, &rect, babl_format ("R'G'B' u8"), img.data,
+                       GEGL_AUTO_ROWSTRIDE);
+      break;
+
+    case 2:
+      gegl_buffer_set (output, &rect, babl_format ("R'G'B' u16"), img.data,
+                       GEGL_AUTO_ROWSTRIDE);
+      break;
+
+    default:
+      g_warning ("%s: Programmer stupidity error", G_STRLOC);
+    }
 
   g_free (img.data);
+
+  ret = TRUE;
+
+ out:
   if (stdin != fp)
-    {
-      fclose (fp);
-    }
-  return  TRUE;
+    fclose (fp);
+
+  return ret;
 }
 
 static GeglRectangle
