Backport of  988f8365f7d8ad8073b6786e433d34c553ecf568
From: Michael Adams <mdadams@ece.uvic.ca>

Also backport jas_safe_size_mul()

diff -aur jasper-1.900.1-debian1.orig/src/libjasper/base/jas_seq.c jasper-1.900.1-debian1/src/libjasper/base/jas_seq.c
--- jasper-1.900.1-debian1.orig/src/libjasper/base/jas_seq.c	2017-03-15 16:30:46.000000000 +0100
+++ jasper-1.900.1-debian1/src/libjasper/base/jas_seq.c	2017-03-15 16:36:57.410704785 +0100
@@ -101,9 +101,16 @@
 {
 	jas_matrix_t *matrix;
 	int i;
+	size_t size;
 
+	matrix = 0;
+
+  	if (numrows < 0 || numcols < 0) {
+		goto error;
+ 	}
+ 
 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
-		return 0;
+		goto error;
 	}
 	matrix->flags_ = 0;
 	matrix->numrows_ = numrows;
@@ -111,21 +118,25 @@
 	matrix->rows_ = 0;
 	matrix->maxrows_ = numrows;
 	matrix->data_ = 0;
-	matrix->datasize_ = numrows * numcols;
+	matrix->datasize_ = 0;
+
+	// matrix->datasize_ = numrows * numcols;
+	if (!jas_safe_size_mul(numrows, numcols, &size)) {
+		goto error;
+	}
+	matrix->datasize_ = size;
 
 	if (matrix->maxrows_ > 0) {
 		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
 		  sizeof(jas_seqent_t *)))) {
-			jas_matrix_destroy(matrix);
-			return 0;
+			goto error;
 		}
 	}
 
 	if (matrix->datasize_ > 0) {
 		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
 		  sizeof(jas_seqent_t)))) {
-			jas_matrix_destroy(matrix);
-			return 0;
+			goto error;
 		}
 	}
 
@@ -143,6 +154,12 @@
 	matrix->yend_ = matrix->numrows_;
 
 	return matrix;
+
+error:
+	if (matrix) {
+		jas_matrix_destroy(matrix);
+	}
+	return 0;
 }
 
 void jas_matrix_destroy(jas_matrix_t *matrix)
--- jasper-1.900.1.orig/src/libjasper/include/jasper/jas_math.h	2016-11-30 15:16:36.376026487 +0100
+++ jasper-1.900.1/src/libjasper/include/jasper/jas_math.h	2016-11-30 15:17:11.011071690 +0100
@@ -79,6 +79,7 @@
 #include	<assert.h>
 #include	<stdio.h>
 #include	<string.h>
+#include <stdint.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -110,6 +111,19 @@
 #define	JAS_ONES(n) \
   ((1 << (n)) - 1)
 
+inline static int jas_safe_size_mul(size_t x, size_t y, size_t *result)
+{
+        /* Check if overflow would occur */
+        if (x && y > SIZE_MAX / x) {
+                /* Overflow would occur. */
+                return 0;
+        }
+        if (result) {
+                *result = x * y;
+        }
+        return 1;
+}
+
 #ifdef __cplusplus
 }
 #endif
