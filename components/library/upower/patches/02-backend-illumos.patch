diff -ur upower-0.99.4-orig/configure.ac upower-0.99.4/configure.ac
--- upower-0.99.4-orig/configure.ac	2017-12-22 13:49:01.103499900 +0000
+++ upower-0.99.4/configure.ac	2017-12-22 13:52:02.433807222 +0000
@@ -182,13 +182,14 @@
 dnl ---------------------------------------------------------------------------
 AC_ARG_WITH([backend],
 	    AS_HELP_STRING([--with-backend=<option>],
-			   [Default backend to use linux, freebsd, openbsd, dummy (dummy)]))
+			   [Default backend to use linux, freebsd, openbsd, illumos, dummy (dummy)]))
 # default to a sane option
 AC_CANONICAL_HOST
 if test x$with_backend = x; then
 	AS_CASE([$host],
 		[*-linux*],   [with_backend=linux],
 		[*-*freebsd*], [with_backend=freebsd],
+		[*-*solaris*], [with_backend=illumos],
 		[*-openbsd*], [with_backend=openbsd],
 		              [with_backend=dummy])
 fi
@@ -216,6 +217,7 @@
 AM_CONDITIONAL(BACKEND_TYPE_LINUX, [test x$with_backend = xlinux])
 AM_CONDITIONAL(BACKEND_TYPE_FREEBSD, [test x$with_backend = xfreebsd])
 AM_CONDITIONAL(BACKEND_TYPE_OPENBSD, [test x$with_backend = xopenbsd])
+AM_CONDITIONAL(BACKEND_TYPE_ILLUMOS, [test x$with_backend = xillumos])
 
 dnl ---------------------------------------------------------------------------
 dnl - Build self tests
@@ -252,6 +254,7 @@
 src/dummy/Makefile
 src/freebsd/Makefile
 src/openbsd/Makefile
+src/illumos/Makefile
 src/linux/Makefile
 src/bsd/Makefile
 tools/Makefile
diff -urN upower-0.99.4-orig/src/illumos/Makefile.am upower-0.99.4/src/illumos/Makefile.am
--- upower-0.99.4-orig/src/illumos/Makefile.am	1970-01-01 03:00:00.000000000 +0000
+++ upower-0.99.4/src/illumos/Makefile.am	2017-12-22 13:55:26.658441035 +0000
@@ -0,0 +1,28 @@
+## Process this file with automake to produce Makefile.in
+
+AM_CPPFLAGS = \
+	-I$(top_builddir)/src -I$(top_srcdir)/src		\
+	-I$(top_builddir)/ -I$(top_srcdir)/			\
+	-DUP_COMPILATION					\
+	-DG_LOG_DOMAIN=\"UPower-illumos\"			\
+	-I$(top_srcdir)/libupower-glib				\
+	$(POLKIT_CFLAGS)					\
+	$(GLIB_CFLAGS)
+
+if BACKEND_TYPE_ILLUMOS
+noinst_LTLIBRARIES = libupshared.la
+endif
+
+libupshared_la_SOURCES =					\
+	up-backend.c						\
+	up-native.c						\
+	up-apm-native.h						\
+	$(BUILT_SOURCES)
+
+libupshared_la_CFLAGS =					\
+	$(WARNINGFLAGS_C)
+
+clean-local :
+	rm -f *~
+
+-include $(top_srcdir)/git.mk
--- /dev/null	2017-12-25 11:21:27.000000000 +0000
+++ upower-0.99.4/src/illumos/up-apm-native.h	2017-12-25 11:21:02.569672318 +0000
@@ -0,0 +1,69 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2011 Landry Breuil <landry@openbsd.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __UP_APM_NATIVE_H__
+#define __UP_APM_NATIVE_H__
+
+/* os-specific headers */
+#include <errno.h> /* errno */
+#include <fcntl.h> /* open() */
+/* kevent() */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/ioctl.h> /* ioctl() */
+/* APM macros */
+
+#include <glib.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define UP_TYPE_APM_NATIVE		(up_apm_native_get_type ())
+#define UP_APM_NATIVE(o)	   	(G_TYPE_CHECK_INSTANCE_CAST ((o), UP_TYPE_APM_NATIVE, UpApmNative))
+#define UP_APM_NATIVE_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), UP_TYPE_APM_NATIVE, UpApmNativeClass))
+#define UP_IS_APM_NATIVE(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), UP_TYPE_APM_NATIVE))
+#define UP_IS_APM_NATIVE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), UP_TYPE_APM_NATIVE))
+#define UP_APM_NATIVE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UP_TYPE_APM_NATIVE, UpApmNativeClass))
+
+typedef struct
+{
+	GObject	parent;
+	gchar*	path;
+} UpApmNative;
+
+typedef struct
+{
+	GObjectClass	parent_class;
+} UpApmNativeClass;
+
+
+// XX in .c ?
+//GType up_apm_native_get_type (void);
+//G_DEFINE_TYPE (UpApmNative, up_apm_native, G_TYPE_OBJECT)
+
+UpApmNative* up_apm_native_new (const char*);
+const gchar * up_apm_native_get_path(UpApmNative*);
+int up_apm_get_fd();
+gboolean up_native_is_laptop();
+gboolean up_native_get_sensordev(const char*, struct sensordev*);
+G_END_DECLS
+
+#endif
diff -urN upower-0.99.4-orig/src/illumos/up-backend.c upower-0.99.4/src/illumos/up-backend.c
--- upower-0.99.4/src/illumos/up-backend.c.~1~	2017-12-25 11:29:28.648881474 +0000
+++ upower-0.99.4/src/illumos/up-backend.c	2017-12-25 18:13:14.653665012 +0000
@@ -0,0 +1,719 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2011 Landry Breuil <landry@openbsd.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "up-apm-native.h"
+
+#include "up-backend.h"
+#include "up-daemon.h"
+#include "up-device.h"
+#include <stdio.h>
+#include <string.h> /* strcmp() */
+#include <libdevinfo.h>
+#include <glib.h>
+#include <fcntl.h>
+#include <sys/acpi_drv.h>
+
+
+#define DEVFS_PREFIX "/devices"
+
+static void	up_backend_class_init	(UpBackendClass	*klass);
+static void	up_backend_init	(UpBackend		*backend);
+static void	up_backend_finalize	(GObject		*object);
+
+static gboolean	up_backend_apm_get_power_info(struct apm_power_info*);
+UpDeviceState up_backend_apm_get_battery_state_value(u_char battery_state);
+static void	up_backend_update_acpibat_state(UpDevice*, struct sensordev);
+static void	up_backend_update_lid_status(UpDaemon*);
+
+static gboolean		up_apm_device_get_on_battery	(UpDevice *device, gboolean *on_battery);
+static gboolean		up_apm_device_get_online		(UpDevice *device, gboolean *online);
+static gboolean		up_apm_device_refresh		(UpDevice *device);
+
+#define UP_BACKEND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UP_TYPE_BACKEND, UpBackendPrivate))
+
+struct UpBackendPrivate
+{
+	UpDaemon		*daemon;
+	UpDevice		*ac;
+	UpDevice		*battery;
+	GThread			*apm_thread;
+	gboolean		is_laptop;
+	UpConfig		*config;
+	GDBusProxy		*seat_manager_proxy;
+};
+
+enum {
+	SIGNAL_DEVICE_ADDED,
+	SIGNAL_DEVICE_REMOVED,
+	SIGNAL_LAST
+};
+
+struct lid_state {
+	gboolean present;
+	gboolean open;
+};
+
+static guint signals [SIGNAL_LAST] = { 0 };
+
+G_DEFINE_TYPE (UpBackend, up_backend, G_TYPE_OBJECT)
+
+/**
+ * functions called by upower daemon
+ **/
+
+
+/* those three ripped from freebsd/up-device-supply.c */
+gboolean
+up_apm_device_get_on_battery (UpDevice *device, gboolean * on_battery)
+{
+	UpDeviceKind type;
+	UpDeviceState state;
+	gboolean is_present;
+
+	g_return_val_if_fail (on_battery != NULL, FALSE);
+
+	g_object_get (device,
+		      "type", &type,
+		      "state", &state,
+		      "is-present", &is_present,
+		      (void*) NULL);
+
+	if (type != UP_DEVICE_KIND_BATTERY)
+		return FALSE;
+	if (state == UP_DEVICE_STATE_UNKNOWN)
+		return FALSE;
+	if (!is_present)
+		return FALSE;
+
+	*on_battery = (state == UP_DEVICE_STATE_DISCHARGING);
+	return TRUE;
+}
+
+gboolean
+up_apm_device_get_online (UpDevice *device, gboolean * online)
+{
+	UpDeviceKind type;
+	gboolean online_tmp;
+
+	g_return_val_if_fail (online != NULL, FALSE);
+
+	g_object_get (device,
+		      "type", &type,
+		      "online", &online_tmp,
+		      (void*) NULL);
+
+	if (type != UP_DEVICE_KIND_LINE_POWER)
+		return FALSE;
+
+	*online = online_tmp;
+
+	return TRUE;
+}
+/**
+ * up_backend_coldplug:
+ * @backend: The %UpBackend class instance
+ * @daemon: The %UpDaemon controlling instance
+ *
+ * Finds all the devices already plugged in, and emits device-add signals for
+ * each of them.
+ *
+ * Return value: %TRUE for success
+ **/
+gboolean
+up_backend_coldplug (UpBackend *backend, UpDaemon *daemon)
+{
+	UpApmNative *acnative = NULL;
+	UpApmNative *battnative = NULL;
+	backend->priv->daemon = g_object_ref (daemon);
+
+	if (backend->priv->is_laptop)
+	{
+		up_backend_update_lid_status(daemon);
+		acnative = up_apm_native_new("/ac");
+		if (!up_device_coldplug (backend->priv->ac, backend->priv->daemon, G_OBJECT(acnative)))
+			g_warning ("failed to coldplug ac");
+		else
+			g_signal_emit (backend, signals[SIGNAL_DEVICE_ADDED], 0, acnative, backend->priv->ac);
+
+		battnative = up_apm_native_new("/batt");
+		if (!up_device_coldplug (backend->priv->battery, backend->priv->daemon, G_OBJECT(battnative)))
+			g_warning ("failed to coldplug battery");
+		else
+			g_signal_emit (backend, signals[SIGNAL_DEVICE_ADDED], 0, battnative, backend->priv->battery);
+	}
+
+	return TRUE;
+}
+
+/**
+ * up_backend_unplug:
+ * @backend: The %UpBackend class instance
+ *
+ * Forget about all learned devices, effectively undoing up_backend_coldplug.
+ * Resources are released without emitting signals.
+ */
+void
+up_backend_unplug (UpBackend *backend)
+{
+	if (backend->priv->daemon != NULL) {
+		g_object_unref (backend->priv->daemon);
+		backend->priv->daemon = NULL;
+	}
+}
+
+/**
+ * up_backend_get_seat_manager_proxy:
+ * @backend: The %UpBackend class instance
+ *
+ * Returns the seat manager object or NULL on error. [transfer none]
+ */
+GDBusProxy *
+up_backend_get_seat_manager_proxy (UpBackend  *backend)
+{
+	g_return_val_if_fail (UP_IS_BACKEND (backend), NULL);
+
+	return backend->priv->seat_manager_proxy;
+}
+
+/**
+ * up_backend_get_config:
+ * @backend: The %UpBackend class instance
+ *
+ * Returns the UpConfig object or NULL on error. [transfer none]
+ */
+UpConfig *
+up_backend_get_config (UpBackend  *backend)
+{
+	g_return_val_if_fail (UP_IS_BACKEND (backend), NULL);
+
+	return backend->priv->config;
+}
+
+
+/**
+ * OpenBSD specific code
+ **/
+
+static gboolean
+up_backend_apm_get_power_info(struct apm_power_info *bstate) {
+	bstate->battery_state = 255;
+	bstate->ac_state = 255;
+	bstate->battery_life = 0;
+	bstate->minutes_left = -1;
+
+	if (-1 == ioctl(up_apm_get_fd(), APM_IOC_GETPOWER, bstate)) {
+		g_error("ioctl on apm fd failed : %s", g_strerror(errno));
+		return FALSE;
+	}
+	return TRUE;
+}
+
+UpDeviceState up_backend_apm_get_battery_state_value(u_char battery_state) {
+	switch(battery_state) {
+		case APM_BATT_HIGH:
+			return UP_DEVICE_STATE_FULLY_CHARGED;
+		case APM_BATT_LOW:
+			return UP_DEVICE_STATE_DISCHARGING; // XXXX
+		case APM_BATT_CRITICAL:
+			return UP_DEVICE_STATE_EMPTY;
+		case APM_BATT_CHARGING:
+			return UP_DEVICE_STATE_CHARGING;
+		case APM_BATTERY_ABSENT:
+			return UP_DEVICE_STATE_EMPTY;
+		case APM_BATT_UNKNOWN:
+			return UP_DEVICE_STATE_UNKNOWN;
+	}
+	return -1;
+}
+
+static gboolean
+up_backend_update_ac_state(UpDevice* device)
+{
+	gboolean ret, new_is_online, cur_is_online;
+	struct apm_power_info a;
+
+	up_backend_update_lid_status(up_device_get_daemon(device));
+	ret = up_backend_apm_get_power_info(&a);
+	if (!ret)
+		return ret;
+
+	g_object_get (device, "online", &cur_is_online, (void*) NULL);
+	/* XXX use acpiac0.indicator0 if available */
+	new_is_online = (a.ac_state == APM_AC_ON ? TRUE : FALSE);
+	if (cur_is_online != new_is_online)
+	{
+		g_object_set (device,
+			"online", new_is_online,
+			(void*) NULL);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static gboolean
+up_backend_update_battery_state(UpDevice* device)
+{
+	gdouble percentage;
+	gboolean ret, is_present;
+	struct sensordev sdev;
+	UpDeviceState cur_state, new_state;
+	gint64 cur_time_to_empty, new_time_to_empty;
+	struct apm_power_info a;
+
+	ret = up_backend_apm_get_power_info(&a);
+	if (!ret)
+		return ret;
+
+	g_object_get (device,
+		"state", &cur_state,
+		"percentage", &percentage,
+		"time-to-empty", &cur_time_to_empty,
+		"is-present", &is_present,
+		(void*) NULL);
+
+	/* XXX use acpibat0.raw0 if available */
+	/*
+	 * XXX: Stop having a split brain regarding
+	 * up_backend_apm_get_battery_state_value(). Either move the state
+	 * setting code below into that function, or inline that function here.
+	 */
+	new_state = up_backend_apm_get_battery_state_value(a.battery_state);
+	// if percentage/minutes goes down or ac is off, we're likely discharging..
+	if (percentage < a.battery_life || cur_time_to_empty < new_time_to_empty || a.ac_state == APM_AC_OFF)
+		new_state = UP_DEVICE_STATE_DISCHARGING;
+	/*
+	 * If we're on AC, we may either be charging, or the battery is already
+	 * fully charged. Figure out which.
+	 */
+	if (a.ac_state == APM_AC_ON)
+		if ((gdouble) a.battery_life >= 99.0)
+			new_state = UP_DEVICE_STATE_FULLY_CHARGED;
+		else
+			new_state = UP_DEVICE_STATE_CHARGING;
+
+	if ((a.battery_state == APM_BATTERY_ABSENT) ||
+	    (a.battery_state == APM_BATT_UNKNOWN)) {
+		/* Reset some known fields which remain untouched below. */
+		g_object_set(device,
+			     "is-rechargeable", FALSE,
+			     "energy", (gdouble) 0.0,
+			     "energy-empty", (gdouble) 0.0,
+			     "energy-full", (gdouble) 0.0,
+			     "energy-full-design", (gdouble) 0.0,
+			     "energy-rate", (gdouble) 0.0,
+			     NULL);
+		is_present = FALSE;
+		if (a.battery_state == APM_BATTERY_ABSENT)
+			new_state = UP_DEVICE_STATE_EMPTY;
+		else
+			new_state = UP_DEVICE_STATE_UNKNOWN;
+	} else {
+		is_present = TRUE;
+	}
+
+	// zero out new_time_to empty if we're not discharging or minutes_left is negative
+	new_time_to_empty = (new_state == UP_DEVICE_STATE_DISCHARGING && a.minutes_left > 0 ? a.minutes_left : 0);
+
+	if (cur_state != new_state ||
+		percentage != (gdouble) a.battery_life ||
+		cur_time_to_empty != new_time_to_empty)
+	{
+		g_object_set (device,
+			"state", new_state,
+			"percentage", (gdouble) a.battery_life,
+			"time-to-empty", new_time_to_empty * 60,
+			"is-present", is_present,
+			(void*) NULL);
+		if(up_native_get_sensordev("acpibat0", &sdev))
+			up_backend_update_acpibat_state(device, sdev);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+/* update acpibat properties */
+static void
+up_backend_update_acpibat_state(UpDevice* device, struct sensordev s)
+{
+	enum sensor_type type;
+	int numt;
+	gdouble bst_volt, bst_rate, bif_cap, bif_lastfullcap, bst_cap, bif_lowcap, capacity;
+	/* gdouble bif_dvolt; */
+	struct sensor sens;
+	size_t slen = sizeof(sens);
+	int mib[] = {CTL_HW, HW_SENSORS, 0, 0, 0};
+
+	mib[2] = s.num;
+	for (type = 0; type < SENSOR_MAX_TYPES; type++) {
+		mib[3] = type;
+		for (numt = 0; numt < s.maxnumt[type]; numt++) {
+			mib[4] = numt;
+			if (sysctl(mib, 5, &sens, &slen, NULL, 0) < 0)
+				g_error("failed to get sensor type %d(%s) numt %d on %s", type, sensor_type_s[type], numt, s.xname);
+			else if (slen > 0 && (sens.flags & SENSOR_FINVALID) == 0) {
+				if (sens.type == SENSOR_VOLTS_DC && !strcmp(sens.desc, "current voltage"))
+					bst_volt = sens.value / 1000000.0f;
+				if ((sens.type == SENSOR_AMPHOUR || sens.type == SENSOR_WATTHOUR) && !strcmp(sens.desc, "design capacity")) {
+					bif_cap = (sens.type == SENSOR_AMPHOUR ? bst_volt : 1) * sens.value / 1000000.0f;
+				}
+				if ((sens.type == SENSOR_AMPHOUR || sens.type == SENSOR_WATTHOUR) && !strcmp(sens.desc, "last full capacity")) {
+					bif_lastfullcap = (sens.type == SENSOR_AMPHOUR ? bst_volt : 1) * sens.value / 1000000.0f;
+				}
+				if ((sens.type == SENSOR_AMPHOUR || sens.type == SENSOR_WATTHOUR) && !strcmp(sens.desc, "low capacity")) {
+					bif_lowcap = (sens.type == SENSOR_AMPHOUR ? bst_volt : 1) * sens.value / 1000000.0f;
+				}
+				if ((sens.type == SENSOR_AMPHOUR || sens.type == SENSOR_WATTHOUR) && !strcmp(sens.desc, "remaining capacity")) {
+					bst_cap = (sens.type == SENSOR_AMPHOUR ? bst_volt : 1) * sens.value / 1000000.0f;
+				}
+				if ((sens.type == SENSOR_AMPS || sens.type == SENSOR_WATTS) && !strcmp(sens.desc, "rate")) {
+					bst_rate = (sens.type == SENSOR_AMPS ? bst_volt : 1) * sens.value / 1000000.0f;
+				}
+				/*
+				bif_dvolt = "voltage" = unused ?
+				amphour1 = warning capacity ?
+				raw0 = battery state
+				*/
+			}
+		}
+	}
+
+	capacity = 0.0f;
+	if(bif_lastfullcap > 0 && bif_cap > 0) {
+		capacity = (bif_lastfullcap / bif_cap) * 100.0f;
+		if (capacity < 0)
+			capacity = 0.0f;
+		if (capacity > 100.0)
+			capacity = 100.0f;
+	}
+
+	g_object_set (device,
+		"energy", bst_cap,
+		"energy-full", bif_lastfullcap,
+		"energy-full-design", bif_cap,
+		"energy-rate", bst_rate,
+		"energy-empty", bif_lowcap,
+		"voltage", bst_volt,
+		"capacity", capacity,
+		(void*) NULL);
+}
+
+/* callback updating the device */
+static gboolean
+up_backend_apm_powerchange_event_cb(gpointer object)
+{
+	UpBackend *backend;
+
+	g_return_val_if_fail (UP_IS_BACKEND (object), FALSE);
+	backend = UP_BACKEND (object);
+	up_apm_device_refresh(backend->priv->ac);
+	up_apm_device_refresh(backend->priv->battery);
+	/* return false to not endless loop */
+	return FALSE;
+}
+
+static gboolean
+up_apm_device_refresh(UpDevice* device)
+{
+	UpDeviceKind type;
+	gboolean ret;
+	g_object_get (device, "type", &type, NULL);
+
+	switch (type) {
+		case UP_DEVICE_KIND_LINE_POWER:
+			ret = up_backend_update_ac_state(device);
+			break;
+		case UP_DEVICE_KIND_BATTERY:
+			ret = up_backend_update_battery_state(device);
+			break;
+		default:
+			g_assert_not_reached ();
+			break;
+	}
+
+	if (ret)
+		g_object_set (device, "update-time", (guint64) g_get_real_time () / G_USEC_PER_SEC, NULL);
+
+	return ret;
+}
+
+static int
+get_lid_status(di_node_t node, void *arg)
+{
+	struct lid_state *st;
+	
+	st = (struct lid_state*) arg;
+	st->present = st->open = FALSE;
+	
+	char * dn=di_driver_name(node);
+	if (dn && !strcmp("acpi_drv",dn)) {
+		di_minor_t minor;
+		
+		minor = DI_MINOR_NIL;
+		while ((minor = di_minor_next(node, minor)) != DI_MINOR_NIL) {
+			char *dp, *fdp;
+			int fd;
+			int state;
+			char *mname;
+			
+			dp=di_devfs_path(node);
+			if (!dp) {
+				g_warning("Couldn't get path for acpi_drv device");
+				continue;
+			}
+			
+			mname = di_minor_name(minor);
+			if (strcmp("lid", mname) != 0) {
+				g_debug("Device %s is not a lid. Skipping.", mname);
+				di_devfs_path_free(dp);
+				continue;
+			}
+			fdp = g_strconcat(DEVFS_PREFIX, dp,":", di_minor_name(minor), NULL);
+			if (!fdp) {
+				g_warning("Couldn't allocate memory");
+				di_devfs_path_free(dp);
+				continue;
+			}
+			
+			fd = open(fdp, O_RDONLY);
+			if (fd == -1) {
+				g_warning("Couldn't open %s device", fdp);
+				di_devfs_path_free(dp);
+				g_free(fdp);
+				continue;
+			}
+			
+			st->present = TRUE;
+			
+			if (ioctl(fd, ACPI_DRV_IOC_LID_UPDATE, &state) < 0) {          
+				close(fd);  
+				g_warning("Couldn't get lid status for device %s", fdp);
+				di_devfs_path_free(dp);
+				g_free(fdp);
+				continue;
+			}
+			
+			if (state != 0) {
+				st->open = TRUE;
+			}
+			
+			close(fd);
+			g_free(fdp);
+			di_devfs_path_free(dp);
+			return DI_WALK_TERMINATE;
+		}
+	}
+	return DI_WALK_CONTINUE;
+}
+
+/*
+ * Check the lid status, return TRUE if one was found, FALSE otherwise.
+ */
+static void
+up_backend_update_lid_status(UpDaemon *daemon)
+{
+	di_node_t root_node;
+	struct lid_state st;
+	st.present = FALSE;
+	st.open = FALSE;
+	
+	errno = 0;
+	if((root_node = di_init("/", DINFOSUBTREE|DINFOMINOR)) == DI_NODE_NIL) {
+		g_error("di_init() failed: %s", g_strerror(errno));
+		return;
+	}
+	di_walk_node(root_node, DI_WALK_CLDFIRST, &st, get_lid_status);
+	di_fini(root_node);
+	
+	up_daemon_set_lid_is_present (daemon, st.present);
+	up_daemon_set_lid_is_closed (daemon, !st.open);
+}
+
+/* thread doing kqueue() on apm device */
+static gpointer
+up_backend_apm_event_thread(gpointer object)
+{
+	int kq, nevents;
+	struct kevent ev;
+	struct timespec ts = {600, 0}, sts = {0, 0};
+
+	UpBackend *backend;
+
+	g_return_val_if_fail (UP_IS_BACKEND (object), NULL);
+	backend = UP_BACKEND (object);
+
+	g_debug("setting up apm thread");
+
+	kq = kqueue();
+	if (kq <= 0)
+		g_error("kqueue");
+	EV_SET(&ev, up_apm_get_fd(), EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR,
+	    0, 0, NULL);
+	nevents = 1;
+	if (kevent(kq, &ev, nevents, NULL, 0, &sts) < 0)
+		g_error("kevent");
+
+	/* blocking wait on kqueue */
+	for (;;) {
+		int rv;
+
+		/* 10mn timeout */
+		sts = ts;
+		if ((rv = kevent(kq, NULL, 0, &ev, 1, &sts)) < 0)
+			break;
+		if (!rv)
+			continue;
+		if (ev.ident == (guint) up_apm_get_fd() && APM_EVENT_TYPE(ev.data) == APM_POWER_CHANGE ) {
+			/* g_idle_add the callback */
+			g_idle_add((GSourceFunc) up_backend_apm_powerchange_event_cb, backend);
+		}
+	}
+	return NULL;
+	/* shouldnt be reached ? */
+}
+
+/**
+ * GObject class functions
+ **/
+
+/**
+ * up_backend_new:
+ *
+ * Return value: a new %UpBackend object.
+ **/
+UpBackend *
+up_backend_new (void)
+{
+	return g_object_new (UP_TYPE_BACKEND, NULL);
+}
+
+/**
+ * up_backend_class_init:
+ * @klass: The UpBackendClass
+ **/
+static void
+up_backend_class_init (UpBackendClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	object_class->finalize = up_backend_finalize;
+
+	signals [SIGNAL_DEVICE_ADDED] =
+		g_signal_new ("device-added",
+			      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (UpBackendClass, device_added),
+			      NULL, NULL, NULL,
+			      G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_POINTER);
+	signals [SIGNAL_DEVICE_REMOVED] =
+		g_signal_new ("device-removed",
+			      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (UpBackendClass, device_removed),
+			      NULL, NULL, NULL,
+			      G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_POINTER);
+
+	g_type_class_add_private (klass, sizeof (UpBackendPrivate));
+}
+
+/**
+ * up_backend_init:
+ **/
+static void
+up_backend_init (UpBackend *backend)
+{
+	GError *err = NULL;
+	UpDeviceClass *device_class;
+	gint64 current_time;
+
+	backend->priv = UP_BACKEND_GET_PRIVATE (backend);
+	backend->priv->is_laptop = up_native_is_laptop();
+	g_debug("is_laptop:%d",backend->priv->is_laptop);
+	if (backend->priv->is_laptop)
+	{
+		backend->priv->ac = UP_DEVICE(up_device_new());
+		backend->priv->battery = UP_DEVICE(up_device_new ());
+		device_class = UP_DEVICE_GET_CLASS (backend->priv->battery);
+		device_class->get_on_battery = up_apm_device_get_on_battery;
+		device_class->get_online = up_apm_device_get_online;
+		device_class->refresh = up_apm_device_refresh;
+		device_class = UP_DEVICE_GET_CLASS (backend->priv->ac);
+		device_class->get_on_battery = up_apm_device_get_on_battery;
+		device_class->get_online = up_apm_device_get_online;
+		device_class->refresh = up_apm_device_refresh;
+		/* creates thread */
+		if((backend->priv->apm_thread = (GThread*) g_thread_try_new("apm-poller",(GThreadFunc)up_backend_apm_event_thread, (void*) backend, &err) == NULL))
+		{
+			g_warning("Thread create failed: %s", err->message);
+			g_error_free (err);
+		}
+
+		/* setup dummy */
+		current_time = g_get_real_time () / G_USEC_PER_SEC;
+		g_object_set (backend->priv->battery,
+			      "type", UP_DEVICE_KIND_BATTERY,
+			      "power-supply", TRUE,
+			      "is-present", TRUE,
+			      "is-rechargeable", TRUE,
+			      "has-history", TRUE,
+			      "state", UP_DEVICE_STATE_UNKNOWN,
+			      "percentage", 0.0f,
+			      "time-to-empty", (gint64) 0,
+			      "update-time", (guint64) current_time,
+			      (void*) NULL);
+		g_object_set (backend->priv->ac,
+			      "type", UP_DEVICE_KIND_LINE_POWER,
+			      "online", TRUE,
+			      "power-supply", TRUE,
+			      "update-time", (guint64) current_time,
+			      (void*) NULL);
+	}
+
+	backend->priv->config = up_config_new ();
+	backend->priv->seat_manager_proxy = g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,
+									   0,
+									   NULL,
+									   CONSOLEKIT2_DBUS_NAME,
+									   CONSOLEKIT2_DBUS_PATH,
+									   CONSOLEKIT2_DBUS_INTERFACE,
+									   NULL,
+									   NULL);
+}
+/**
+ * up_backend_finalize:
+ **/
+static void
+up_backend_finalize (GObject *object)
+{
+	UpBackend *backend;
+
+	g_return_if_fail (UP_IS_BACKEND (object));
+
+	backend = UP_BACKEND (object);
+
+	g_object_unref (backend->priv->config);
+	if (backend->priv->daemon != NULL)
+		g_object_unref (backend->priv->daemon);
+	if (backend->priv->battery != NULL)
+		g_object_unref (backend->priv->battery);
+	if (backend->priv->ac != NULL)
+		g_object_unref (backend->priv->ac);
+	g_clear_object (&backend->priv->seat_manager_proxy);
+	/* XXX stop apm_thread ? */
+
+	G_OBJECT_CLASS (up_backend_parent_class)->finalize (object);
+}
--- upower-0.99.4-orig/src/Makefile.am	2017-12-22 13:49:01.088869218 +0000
+++ upower-0.99.4/src/Makefile.am	2017-12-22 14:11:15.858740851 +0000
@@ -1,7 +1,7 @@
 ## Process this file with automake to produce Makefile.in
 
-DIST_SUBDIRS = dummy freebsd linux openbsd bsd
-SUBDIRS = dummy freebsd linux openbsd
+DIST_SUBDIRS = dummy freebsd linux openbsd bsd illumos
+SUBDIRS = dummy freebsd linux openbsd illumos
 
 if BACKEND_TYPE_FREEBSD
 SUBDIRS += bsd
@@ -11,6 +11,10 @@
 SUBDIRS += bsd
 endif
 
+if BACKEND_TYPE_ILLUMOS
+SUBDIRS += bsd
+endif
+
 AM_CPPFLAGS = \
 	$(PIE_CFLAGS)						\
 	-I$(top_builddir)/src -I$(top_srcdir)/src		\
@@ -89,6 +93,13 @@
 	bsd/libupsharedcommon.la
 endif
 
+if BACKEND_TYPE_ILLUMOS
+upowerd_LDADD +=						\
+	illumos/libupshared.la				\
+	bsd/libupsharedcommon.la
+endif
+
+
 if BACKEND_TYPE_LINUX
 upowerd_LDADD += 						\
 	linux/libupshared.la					\
--- upower-0.99.4/src/illumos/up-native.c.~1~	2017-12-25 18:14:39.290078739 +0000
+++ upower-0.99.4/src/illumos/up-native.c	2017-12-25 18:16:32.978550764 +0000
@@ -0,0 +1,188 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2011 Landry Breuil <landry@openbsd.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "up-apm-native.h"
+#include "up-native.h"
+#include <libdevinfo.h>
+#include <glib.h>
+#include <fcntl.h>
+#include <string.h> /* strcmp() */
+#include <sys/acpi_drv.h>
+#include <unistd.h> /* close() */
+
+#define DEVFS_PREFIX "/devices"
+
+/* XXX why does this macro needs to be in the .c ? */
+G_DEFINE_TYPE (UpApmNative, up_apm_native, G_TYPE_OBJECT)
+
+static void
+up_apm_native_class_init (UpApmNativeClass *klass)
+{
+}
+
+static void
+up_apm_native_init (UpApmNative *self)
+{
+	self->path = "empty";
+}
+
+UpApmNative *
+up_apm_native_new(const gchar * path)
+{
+	UpApmNative *native;
+	native = UP_APM_NATIVE (g_object_new (UP_TYPE_APM_NATIVE, NULL));
+	native->path = g_strdup(path);
+	return native;
+}
+
+const gchar *
+up_apm_native_get_path(UpApmNative * native)
+{
+	return native->path;
+}
+
+/**
+ * up_native_get_native_path:
+ * @object: the native tracking object
+ *
+ * This converts a GObject used as the device data into a native path.
+ *
+ * Return value: The native path for the device which is unique, e.g. "/sys/class/power/BAT1"
+ **/
+const gchar *
+up_native_get_native_path (GObject *object)
+{
+	return up_apm_native_get_path (UP_APM_NATIVE (object));
+}
+
+static int
+find_acpi_power_device(di_node_t node, void *arg)
+{
+     gboolean *pfound;
+     char *dn;
+
+     pfound = (gboolean *) arg;
+     *pfound = FALSE;
+
+     dn=di_driver_name(node);
+     if (dn && !strcmp("acpi_drv",dn)) {
+        di_minor_t minor;
+
+        minor = DI_MINOR_NIL;
+        while ((minor = di_minor_next(node, minor)) != DI_MINOR_NIL) {
+            char *dp, *fdp;
+            int fd;
+            int pow;
+            char *mname;
+
+            dp=di_devfs_path(node);
+            if (!dp) {
+                g_warning("Couldn't get path for acpi_drv device");
+                continue;
+            }
+
+            mname = di_minor_name(minor);
+            if (strncmp("battery", mname, strlen("battery")) != 0 && strncmp("ac", mname, strlen("ac")) != 0) {
+                g_debug("Device %s is not ac or battery. Skipping.", mname);
+                di_devfs_path_free(dp);
+                continue;
+            }
+            fdp = g_strconcat(DEVFS_PREFIX, dp,":", di_minor_name(minor), NULL);
+            if (!fdp) {
+                g_warning("Couldn't allocate memory");
+                di_devfs_path_free(dp);
+                continue;
+            }
+            
+            fd = open(fdp, O_RDONLY);
+            if (fd == -1) {
+                g_warning("Couldn't open %s device", fdp);
+                di_devfs_path_free(dp);
+                g_free(fdp);
+                continue;
+            }
+
+            if (ioctl(fd, ACPI_DRV_IOC_POWER_STATUS, &pow) < 0) {          
+                close(fd);  
+                g_warning("Couldn't get power status for device %s", fdp);
+                di_devfs_path_free(dp);
+                g_free(fdp);
+                continue;
+            }
+
+            *pfound = TRUE;
+            close(fd);
+            g_free(fdp);
+            di_devfs_path_free(dp);
+            return DI_WALK_TERMINATE;
+	}
+     }
+     return DI_WALK_CONTINUE;
+}
+
+/**
+ * detect if we are on a desktop system or a laptop
+ * We consider system a laptop if acpi_drv is present
+ * and we can get power state from ac or button
+ * device
+ */
+gboolean
+up_native_is_laptop()
+{
+     gboolean found;
+
+     di_node_t root_node;
+
+     errno = 0;
+     if((root_node = di_init("/", DINFOSUBTREE|DINFOMINOR)) == DI_NODE_NIL) {
+           g_error("di_init() failed: %s", g_strerror(errno));
+           return FALSE;
+     }
+     di_walk_node(root_node, DI_WALK_CLDFIRST, &found, find_acpi_power_device);
+     di_fini(root_node);
+     return found;
+}
+
+/**
+ * get a sensordev by its xname (acpibatX/acpiacX)
+ * returns a gboolean if found or not
+ */
+gboolean
+up_native_get_sensordev(const char * id, struct sensordev * snsrdev)
+{
+	int devn;
+	size_t sdlen = sizeof(struct sensordev);
+	int mib[] = {CTL_HW, HW_SENSORS, 0, 0 ,0};
+
+	for (devn = 0 ; ; devn++) {
+		mib[2] = devn;
+		if (sysctl(mib, 3, snsrdev, &sdlen, NULL, 0) == -1) {
+			if (errno == ENXIO)
+				continue;
+			if (errno == ENOENT)
+				break;
+		}
+		if (!strcmp(snsrdev->xname, id))
+			return TRUE;
+	}
+	return FALSE;
+}
+
