from
https://github.com/GNOME/libxml2/commit/9bd7abfba41ca219ab39cb912f020f8e02116f32
https://github.com/GNOME/libxml2/commit/3e7e75bed2cf2853b0d42d635d36676b3330d475
https://github.com/GNOME/libxml2/commit/52649b63ebd0dc45df0c5e6b209af6f6d96515ca
https://github.com/GNOME/libxml2/commit/c9faa29259ac23b5fbf945f61056288e413dae81
diff --git a/nanoftp.c b/nanoftp.c
index 54fa026..80685da 100644
--- a/nanoftp.c
+++ b/nanoftp.c
@@ -1251,8 +1251,7 @@ xmlNanoFTPConnectTo(const char *server, int port) {
 	xmlNanoFTPFreeCtxt(ctxt);
 	return(NULL);
     }
-    if (port != 0)
-	ctxt->port = port;
+    ctxt->port = port;
     res = xmlNanoFTPConnect(ctxt);
     if (res < 0) {
 	xmlNanoFTPFreeCtxt(ctxt);
diff --git a/parser.c b/parser.c
index 4bef4fd..df308a9 100644
--- a/parser.c
+++ b/parser.c
@@ -3891,7 +3891,6 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
                            "AttValue length too long\n");
             goto mem_error;
         }
-	if (c == 0) break;
 	if (c == '&') {
 	    in_space = 0;
 	    if (NXT(1) == '#') {
diff --git a/valid.c b/valid.c
index b1cfede..f85f856 100644
--- a/valid.c
+++ b/valid.c
@@ -5876,28 +5876,27 @@ xmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {
 		    break;
 		case XML_ELEMENT_TYPE_MIXED:
 		    break;
-		case XML_ELEMENT_TYPE_ELEMENT:
-		    if (len > 0) {
-			int i;
-
-			for (i = 0;i < len;i++) {
-			    if (!IS_BLANK_CH(data[i])) {
-				xmlErrValidNode(ctxt, state->node,
-						XML_DTD_CONTENT_MODEL,
-	   "Element %s content does not follow the DTD, Text not allowed\n",
-				       state->node->name, NULL, NULL);
-				ret = 0;
-				goto done;
-			    }
-			}
-			/*
-			 * TODO:
-			 * VC: Standalone Document Declaration
-			 *  element types with element content, if white space
-			 *  occurs directly within any instance of those types.
-			 */
-		    }
-		    break;
+		case XML_ELEMENT_TYPE_ELEMENT: {
+                    int i;
+
+                    for (i = 0;i < len;i++) {
+                        if (!IS_BLANK_CH(data[i])) {
+                            xmlErrValidNode(ctxt, state->node,
+                                            XML_DTD_CONTENT_MODEL,
+       "Element %s content does not follow the DTD, Text not allowed\n",
+                                   state->node->name, NULL, NULL);
+                            ret = 0;
+                            goto done;
+                        }
+                    }
+                    /*
+                     * TODO:
+                     * VC: Standalone Document Declaration
+                     *  element types with element content, if white space
+                     *  occurs directly within any instance of those types.
+                     */
+                    break;
+                }
 	    }
 	}
     }
diff --git a/win32/configure.js b/win32/configure.js
index dbf238c..c635590 100644
--- a/win32/configure.js
+++ b/win32/configure.js
@@ -210,16 +210,16 @@ function discoverVersion()
 		s = new String(ln);
 		if (s.search(/^LIBXML_MAJOR_VERSION=/) != -1) {
 			vf.WriteLine(s);
-			verMajor = s.substring(s.indexOf("=") + 1, s.length)
+			verMajor = s.substring(s.indexOf("=") + 1, s.length);
 		} else if(s.search(/^LIBXML_MINOR_VERSION=/) != -1) {
 			vf.WriteLine(s);
-			verMinor = s.substring(s.indexOf("=") + 1, s.length)
+			verMinor = s.substring(s.indexOf("=") + 1, s.length);
 		} else if(s.search(/^LIBXML_MICRO_VERSION=/) != -1) {
 			vf.WriteLine(s);
-			verMicro = s.substring(s.indexOf("=") + 1, s.length)
+			verMicro = s.substring(s.indexOf("=") + 1, s.length);
 		} else if(s.search(/^LIBXML_MICRO_VERSION_SUFFIX=/) != -1) {
 			vf.WriteLine(s);
-			verMicroSuffix = s.substring(s.indexOf("=") + 1, s.length)
+			verMicroSuffix = s.substring(s.indexOf("=") + 1, s.length);
 		}
 	}
 	cf.Close();
@@ -280,7 +280,7 @@ function discoverVersion()
 		vf.WriteLine("DYNRUNTIME=" + (dynruntime? "1" : "0"));
 	}
 	vf.Close();
-	versionFile = "rcVersion.h"
+	versionFile = "rcVersion.h";
 	vf = fso.CreateTextFile(versionFile, true);
 	vf.WriteLine("/*");
 	vf.WriteLine("  " + versionFile);
@@ -291,7 +291,7 @@ function discoverVersion()
 	vf.WriteLine("#define LIBXML_MINOR_VERSION " + verMinor);
 	vf.WriteLine("#define LIBXML_MICRO_VERSION " + verMicro);
 	vf.WriteLine("#define LIBXML_DOTTED_VERSION " + "\"" + verMajor + "." + verMinor + "." + verMicro + "\"");
-	vf.Close()
+	vf.Close();
 }
 
 /* Configures libxml. This one will generate xmlversion.h from xmlversion.h.in
@@ -544,8 +544,6 @@ for (i = 0; (i < WScript.Arguments.length) && (error == 0); i++) {
 			buildStatic = strToBool(arg.substring(opt.length + 1, arg.length));
 		else if (opt == "prefix")
 			buildPrefix = arg.substring(opt.length + 1, arg.length);
-		else if (opt == "incdir")
-			buildIncPrefix = arg.substring(opt.length + 1, arg.length);
 		else if (opt == "bindir")
 			buildBinPrefix = arg.substring(opt.length + 1, arg.length);
 		else if (opt == "libdir")
diff --git a/xmlregexp.c b/xmlregexp.c
index d255fbf..51d9586 100644
--- a/xmlregexp.c
+++ b/xmlregexp.c
@@ -26,6 +26,9 @@
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
 
 #include <libxml/tree.h>
 #include <libxml/parserInternals.h>
@@ -36,6 +39,9 @@
 #ifndef INT_MAX
 #define INT_MAX 123456789 /* easy to flag and big enough for our needs */
 #endif
+#ifndef SIZE_MAX
+#define SIZE_MAX ((size_t) -1)
+#endif
 
 /* #define DEBUG_REGEXP_GRAPH */
 /* #define DEBUG_REGEXP_EXEC */
@@ -418,6 +424,32 @@ xmlRegexpErrCompile(xmlRegParserCtxtPtr ctxt, const char *extra)
  ************************************************************************/
 
 static int xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt);
+
+/**
+ * xmlRegCalloc2:
+ * @dim1:  size of first dimension
+ * @dim2:  size of second dimension
+ * @elemSize:  size of element
+ *
+ * Allocate a two-dimensional array and set all elements to zero.
+ *
+ * Returns the new array or NULL in case of error.
+ */
+static void*
+xmlRegCalloc2(size_t dim1, size_t dim2, size_t elemSize) {
+    size_t totalSize;
+    void *ret;
+
+    /* Check for overflow */
+    if (dim1 > SIZE_MAX / dim2 / elemSize)
+        return (NULL);
+    totalSize = dim1 * dim2 * elemSize;
+    ret = xmlMalloc(totalSize);
+    if (ret != NULL)
+        memset(ret, 0, totalSize);
+    return (ret);
+}
+
 /**
  * xmlRegEpxFromParse:
  * @ctxt:  the parser context used to build it
@@ -540,8 +572,8 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 #ifdef DEBUG_COMPACTION
 	printf("Final: %d atoms\n", nbatoms);
 #endif
-	transitions = (int *) xmlMalloc((nbstates + 1) *
-	                                (nbatoms + 1) * sizeof(int));
+	transitions = (int *) xmlRegCalloc2(nbstates + 1, nbatoms + 1,
+                                            sizeof(int));
 	if (transitions == NULL) {
 	    xmlFree(stateRemap);
 	    xmlFree(stringRemap);
@@ -549,7 +581,6 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 	    xmlFree(ret);
 	    return(NULL);
 	}
-	memset(transitions, 0, (nbstates + 1) * (nbatoms + 1) * sizeof(int));
 
 	/*
 	 * Allocate the transition table. The first entry for each
@@ -575,12 +606,9 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 		    continue;
                 atomno = stringRemap[trans->atom->no];
 		if ((trans->atom->data != NULL) && (transdata == NULL)) {
-		    transdata = (void **) xmlMalloc(nbstates * nbatoms *
-			                            sizeof(void *));
-		    if (transdata != NULL)
-			memset(transdata, 0,
-			       nbstates * nbatoms * sizeof(void *));
-		    else {
+		    transdata = (void **) xmlRegCalloc2(nbstates, nbatoms,
+			                                sizeof(void *));
+		    if (transdata == NULL) {
 			xmlRegexpErrMemory(ctxt, "compiling regexp");
 			break;
 		    }
@@ -6042,7 +6070,7 @@ xmlAutomataNewOnceTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	return(NULL);
     if (min < 1)
 	return(NULL);
-    if ((max < min) || (max < 1))
+    if (max < min)
 	return(NULL);
     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
     if (atom == NULL)
@@ -6121,7 +6149,7 @@ xmlAutomataNewOnceTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	return(NULL);
     if (min < 1)
 	return(NULL);
-    if ((max < min) || (max < 1))
+    if (max < min)
 	return(NULL);
     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
     if (atom == NULL)
diff --git a/xmlsave.c b/xmlsave.c
index 7a05d83..2f3fa65 100644
--- a/xmlsave.c
+++ b/xmlsave.c
@@ -2202,7 +2202,7 @@ xmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level,
             int format)
 {
     xmlBufPtr buffer;
-    int ret;
+    size_t ret;
 
     if ((buf == NULL) || (cur == NULL))
         return(-1);
diff --git a/xmlschemas.c b/xmlschemas.c
index 019988a..61ef5de 100644
--- a/xmlschemas.c
+++ b/xmlschemas.c
@@ -24200,7 +24200,7 @@ xmlSchemaValidateFacets(xmlSchemaAbstractCtxtPtr actxt,
 			unsigned long length,
 			int fireErrors)
 {
-    int ret, error = 0;
+    int ret, error = 0, found;
 
     xmlSchemaTypePtr tmpType;
     xmlSchemaFacetLinkPtr facetLink;
@@ -24324,8 +24324,7 @@ WXS_IS_LIST:
     }
 
 pattern_and_enum:
-    if (error >= 0) {
-	int found = 0;
+	found = 0;
 	/*
 	* Process enumerations. Facet values are in the value space
 	* of the defining type's base type. This seems to be a bug in the
@@ -24372,10 +24371,7 @@ pattern_and_enum:
 	    if (error == 0)
 		error = ret;
 	}
-    }
 
-    if (error >= 0) {
-	int found;
 	/*
 	* Process patters. Pattern facets are ORed at type level
 	* and ANDed if derived. Walk the base type axis.
@@ -24420,7 +24416,6 @@ pattern_and_enum:
 	    }
 	    tmpType = tmpType->baseType;
 	} while ((tmpType != NULL) && (tmpType->type != XML_SCHEMA_TYPE_BASIC));
-    }
 
     return (error);
 }
