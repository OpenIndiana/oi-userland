Description: fix information disclosure via overflows
Origin: other, http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/efc8652da937
Bug: http://bugs.icu-project.org/trac/ticket/11865

Index: icu-55.1/source/layout/Features.cpp
===================================================================
--- icu-55.1.orig/source/layout/Features.cpp	2015-03-27 17:17:46.000000000 -0400
+++ icu-55.1/source/layout/Features.cpp	2015-09-11 08:21:26.318996833 -0400
@@ -16,7 +16,7 @@
 LEReferenceTo<FeatureTable> FeatureListTable::getFeatureTable(const LETableReference &base, le_uint16 featureIndex, LETag *featureTag, LEErrorCode &success) const
 {
     LEReferenceToArrayOf<FeatureRecord>
-        featureRecordArrayRef(base, success, featureRecordArray, featureIndex);
+        featureRecordArrayRef(base, success, featureRecordArray, featureIndex+1);
 
   if (featureIndex >= SWAPW(featureCount) || LE_FAILURE(success)) {
     return LEReferenceTo<FeatureTable>();
Index: icu-55.1/source/layout/LETableReference.h
===================================================================
--- icu-55.1.orig/source/layout/LETableReference.h	2015-09-11 08:19:32.393829155 -0400
+++ icu-55.1/source/layout/LETableReference.h	2015-09-11 08:22:38.791739469 -0400
@@ -180,6 +180,18 @@
   }
 
   /**
+  * Throw an error if size*count overflows
+  */
+  size_t verifyLength(size_t offset, size_t size, le_uint32 count, LEErrorCode &success) {
+    if(count!=0 && size>LE_UINT32_MAX/count) {
+      LE_DEBUG_TR3("verifyLength failed size=%u, count=%u", size, count);
+      success = LE_INDEX_OUT_OF_BOUNDS_ERROR;
+      return 0;
+    }
+    return verifyLength(offset, size*count, success);
+  }
+
+  /**
    * Change parent link to another
    */
   LETableReference &reparent(const LETableReference &base) {
@@ -269,7 +281,7 @@
       if(count == LE_UNBOUNDED_ARRAY) { // not a known length
         count = getLength()/LETableVarSizer<T>::getSize(); // fit to max size
       }
-      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize()*count, success);
+      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize(), count, success);
     }
     if(LE_FAILURE(success)) {
       fCount=0;
@@ -284,7 +296,7 @@
       if(count == LE_UNBOUNDED_ARRAY) { // not a known length
         count = getLength()/LETableVarSizer<T>::getSize(); // fit to max size
       }
-      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize()*count, success);
+      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize(), count, success);
     }
     if(LE_FAILURE(success)) clear();
   }
@@ -295,7 +307,7 @@
       if(count == LE_UNBOUNDED_ARRAY) { // not a known length
         count = getLength()/LETableVarSizer<T>::getSize(); // fit to max size
       }
-      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize()*count, success);
+      LETableReference::verifyLength(0, LETableVarSizer<T>::getSize(), count, success);
     }
     if(LE_FAILURE(success)) clear();
   }
