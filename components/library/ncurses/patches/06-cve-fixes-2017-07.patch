Author: Sven Joachim <svenjoac@gmx.de>
Description: Fixes for four CVEs
 Fixes for CVE 2017-10684, CVE-2017-10685, CVE-2017-11112,
 CVE-2017-11113 cherry-picked from upstream patchlevels 20170701 and
 20170708.
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1464684
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1464685
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1464686
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1464687
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1464691
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1464692
Forwarded: not-needed
Last-Update: 2017-07-09

---
 ncurses/tinfo/alloc_entry.c |    6 +++++-
 ncurses/tinfo/parse_entry.c |   22 ++++++++++++----------
 progs/dump_entry.c          |   30 +++++++++++++++++++-----------
 3 files changed, 36 insertions(+), 22 deletions(-)

--- ncurses-5.9/ncurses/tinfo/alloc_entry.c.~1~	2010-12-26 02:06:01.000000000 +0000
+++ ncurses-5.9/ncurses/tinfo/alloc_entry.c	2017-07-21 16:35:19.414080515 +0000
@@ -120,7 +120,11 @@
 {
     char *result = 0;
     size_t old_next_free = next_free;
-    size_t len = strlen(string) + 1;
+    size_t len;
+
+    if (string == 0)
+	return _nc_save_str("");
+    len = strlen(string) + 1;
 
     if (len == 1 && next_free != 0) {
 	/*
--- ncurses-5.9/ncurses/tinfo/parse_entry.c.~1~	2010-05-01 23:35:09.000000000 +0000
+++ ncurses-5.9/ncurses/tinfo/parse_entry.c	2017-07-21 16:36:41.484978197 +0000
@@ -234,13 +234,14 @@
      * implemented it.  Note that the resulting terminal type was never the
      * 2-character name, but was instead the first alias after that.
      */
+#define ok_TC2(s) (isgraph(UChar(s)) && (s) != '|')
     ptr = _nc_curr_token.tk_name;
     if (_nc_syntax == SYN_TERMCAP
 #if NCURSES_XNAMES
 	&& !_nc_user_definable
 #endif
 	) {
-	if (ptr[2] == '|') {
+	if (ok_TC2(ptr[0]) && ok_TC2(ptr[1]) && (ptr[2] == '|')) {
 	    ptr += 3;
 	    _nc_curr_token.tk_name[2] = '\0';
 	}
@@ -282,9 +283,11 @@
 	if (is_use || is_tc) {
 	    entryp->uses[entryp->nuses].name = _nc_save_str(_nc_curr_token.tk_valstring);
 	    entryp->uses[entryp->nuses].line = _nc_curr_line;
-	    entryp->nuses++;
-	    if (entryp->nuses > 1 && is_tc) {
-		BAD_TC_USAGE
+	    if (VALID_STRING(entryp->uses[entryp->nuses].name)) {
+		entryp->nuses++;
+		if (entryp->nuses > 1 && is_tc) {
+		    BAD_TC_USAGE
+		}
 	    }
 	} else {
 	    /* normal token lookup */
@@ -565,7 +568,7 @@
 static void
 append_acs(string_desc * dst, int code, char *src)
 {
-    if (src != 0 && strlen(src) == 1) {
+    if (VALID_STRING(src) && strlen(src) == 1) {
 	append_acs0(dst, code, *src);
     }
 }
@@ -817,15 +820,14 @@
 	    }
 
 	    if (tp->Strings[to_ptr->nte_index]) {
+		const char *s = tp->Strings[from_ptr->nte_index];
+		const char *t = tp->Strings[to_ptr->nte_index];
 		/* There's no point in warning about it if it's the same
 		 * string; that's just an inefficiency.
 		 */
-		if (strcmp(
-			      tp->Strings[from_ptr->nte_index],
-			      tp->Strings[to_ptr->nte_index]) != 0)
+		if (VALID_STRING(s) && VALID_STRING(t) && strcmp(s, t) != 0)
 		    _nc_warning("%s (%s) already has an explicit value %s, ignoring ko",
-				ap->to, ap->from,
-				_nc_visbuf(tp->Strings[to_ptr->nte_index]));
+				ap->to, ap->from, t);
 		continue;
 	    }
 
--- ncurses-5.9/progs/dump_entry.c.~1~	2010-05-02 02:04:08.000000000 +0000
+++ ncurses-5.9/progs/dump_entry.c	2017-07-21 16:47:42.985139892 +0000
@@ -577,9 +577,10 @@
     PredIdx num_strings = 0;
     bool outcount = 0;
 
-#define WRAP_CONCAT	\
-	wrap_concat(buffer); \
-	outcount = TRUE
+#define WRAP_CONCAT1(s)		wrap_concat(s); outcount = TRUE
+#define WRAP_CONCAT2(a,b)	wrap_concat(a); WRAP_CONCAT1(b)
+#define WRAP_CONCAT3(a,b,c)	wrap_concat(a); WRAP_CONCAT2(b,c)
+#define WRAP_CONCAT		WRAP_CONCAT1(buffer)
 
     len = 12;			/* terminfo file-header */
 
@@ -752,13 +753,21 @@
 		    if (outform == F_TCONVERR) {
 			sprintf(buffer, "%s=!!! %s WILL NOT CONVERT !!!",
 				name, srccap);
+                        WRAP_CONCAT;
 		    } else if (suppress_untranslatable) {
 			continue;
 		    } else {
 			char *s = srccap, *d = buffer;
-			sprintf(d, "..%s=", name);
-			d += strlen(d);
+			WRAP_CONCAT3("..", name, "=");
 			while ((*d = *s++) != 0) {
+                            if ((d - buffer + 1) >= (int) sizeof(buffer)) {
+                                fprintf(stderr,
+                                        "%s: value for %s is too long\n",
+                                        _nc_progname,
+                                        name);
+                                *d = '\0';
+                                break;
+                            }
 			    if (*d == ':') {
 				*d++ = '\\';
 				*d = ':';
@@ -767,12 +776,12 @@
 			    }
 			    d++;
 			}
+                        WRAP_CONCAT;
 		    }
 		} else {
-		    sprintf(buffer, "%s=%s", name, cv);
+		    WRAP_CONCAT3(name, "=", cv);
 		}
 		len += (int) strlen(capability) + 1;
-		WRAP_CONCAT;
 	    } else {
 		char *src = _nc_tic_expand(capability,
 					   outform == F_TERMINFO, numbers);
@@ -788,8 +797,7 @@
 		    strcpy_DYN(&tmpbuf, src);
 		}
 		len += (int) strlen(capability) + 1;
-		wrap_concat(tmpbuf.text);
-		outcount = TRUE;
+		WRAP_CONCAT1(tmpbuf.text);
 	    }
 	}
 	/* e.g., trimmed_sgr0 */
@@ -1116,7 +1124,8 @@
 		}
 		if (len > critlen) {
 		    (void) fprintf(stderr,
-				   "warning: %s entry is %d bytes long\n",
+				   "%s: %s entry is %d bytes long\n",
+				   _nc_progname,
 				   _nc_first_name(tterm->term_names),
 				   len);
 		    SHOW_WHY("# WARNING: this entry, %d bytes long, may core-dump %s libraries!\n",
