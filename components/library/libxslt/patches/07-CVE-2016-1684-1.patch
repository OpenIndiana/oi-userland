commit 91d0540ac9beaa86719a05b749219a69baa0dd8d
Author: Nick Wellnhofer <wellnhofer@aevum.de>
Date:   Sun Apr 10 13:12:28 2016 +0200

    Lower and upper bound for format token "i"
    
    Handle xsl:number with format "i" and value 0 according to XSLT 2.0.
    
    Also introduce an upper bound to fix a denial of service.

Index: libxslt-1.1.28/libxslt/numbers.c
===================================================================
--- libxslt-1.1.28.orig/libxslt/numbers.c
+++ libxslt-1.1.28/libxslt/numbers.c
@@ -253,11 +253,24 @@ xsltNumberFormatAlpha(xmlBufferPtr buffe
 }
 
 static void
-xsltNumberFormatRoman(xmlBufferPtr buffer,
+xsltNumberFormatRoman(xsltNumberDataPtr data,
+		      xmlBufferPtr buffer,
 		      double number,
 		      int is_upper)
 {
     /*
+     * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper
+     * bound to avoid denial of service.
+     */
+    if (number < 1.0 || number > 5000.0) {
+        xsltNumberFormatDecimal(buffer, number, '0', 1,
+                                data->digitsPerGroup,
+                                data->groupingCharacter,
+                                data->groupingCharacterLen);
+        return;
+    }
+
+    /*
      * Based on an example by Jim Walsh
      */
     while (number >= 1000.0) {
@@ -495,16 +508,10 @@ xsltNumberFormatInsertNumbers(xsltNumber
 
 		    break;
 		case 'I':
-		    xsltNumberFormatRoman(buffer,
-					  number,
-					  TRUE);
-
+		    xsltNumberFormatRoman(data, buffer, number, TRUE);
 		    break;
 		case 'i':
-		    xsltNumberFormatRoman(buffer,
-					  number,
-					  FALSE);
-
+		    xsltNumberFormatRoman(data, buffer, number, FALSE);
 		    break;
 		default:
 		    if (IS_DIGIT_ZERO(token->token)) {
