Description: Fixes for write out-of-bounds error (CVE-2016-6352)
Origin: backport, https://git.gnome.org/browse/gdk-pixbuf/commit/?id=88af50a864195da1a4f7bda5f02539704fbda599
Bug: https://bugzilla.gnome.org/show_bug.cgi?id=769170
Forwarded: not-needed
Last-Update: <2016-09-13>

--- gdk-pixbuf-2.32.2.orig/gdk-pixbuf/io-ico.c
+++ gdk-pixbuf-2.32.2/gdk-pixbuf/io-ico.c
@@ -23,6 +23,8 @@
  */
 
 #undef DUMPBIH
+#define DEBUG(s)
+
 /*
 
 Icons are just like BMP's, except for the header.
@@ -75,14 +77,14 @@ struct BitmapInfoHeader {
 };
 
 #ifdef DUMPBIH
-/* 
+/*
 
 DumpBIH printf's the values in a BitmapInfoHeader to the screen, for 
 debugging purposes.
 
 */
 static void DumpBIH(unsigned char *BIH)
-{				
+{
 	printf("biSize      = %i \n",
 	       (int)(BIH[3] << 24) + (BIH[2] << 16) + (BIH[1] << 8) + (BIH[0]));
 	printf("biWidth     = %i \n",
@@ -125,6 +127,8 @@ struct headerpair {
 /* Score the various parts of the icon */
 struct ico_direntry_data {
 	gint ImageScore;
+        gint width;
+        gint height;
 	gint DIBoffset;
 	gint x_hot;
 	gint y_hot;
@@ -220,10 +224,10 @@ static void DecodeHeader(guchar *Data, g
 
 	/* First word should be 0 according to specs */
 	if (((Data[1] << 8) + Data[0]) != 0) {
-		g_set_error_literal (error,
-				     GDK_PIXBUF_ERROR,
-				     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-				     _("Invalid header in icon"));
+		g_set_error (error,
+			     GDK_PIXBUF_ERROR,
+			     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			     _("Invalid header in icon (%s)"), "first word");
 		return;
 
 	}
@@ -234,18 +238,19 @@ static void DecodeHeader(guchar *Data, g
 
 	/* If it is not a cursor make sure it is actually an icon */
 	if (!State->cursor && imgtype != 1) {
-		g_set_error_literal (error,
-				     GDK_PIXBUF_ERROR,
-				     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-				     _("Invalid header in icon"));
+		g_set_error (error,
+			     GDK_PIXBUF_ERROR,
+			     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			     _("Invalid header in icon (%s)"), "image type");
 		return;
 	}
 
-
  	IconCount = (Data[5] << 8) + (Data[4]);
 	
  	State->HeaderSize = 6 + IconCount*16;
 
+        DEBUG(g_print ("Image type: %d (%s)\nImage count: %d\n", imgtype, imgtype == 2 ? "cursor" : "icon", IconCount));
+
  	if (State->HeaderSize>State->BytesInHeaderBuf) {
  		guchar *tmp=g_try_realloc(State->HeaderBuf,State->HeaderSize);
 		if (!tmp) {
@@ -267,17 +272,37 @@ static void DecodeHeader(guchar *Data, g
 	State->entries = 0;
 	Ptr = Data + 6;
 	for (I=0;I<IconCount;I++) {
+                int width;
+                int height;
+                int x_hot;
+                int y_hot;
+                int data_size;
+                int data_offset;
+
+                width = Ptr[0];
+                height = Ptr[1];
+		x_hot = (Ptr[5] << 8) + Ptr[4];
+		y_hot = (Ptr[7] << 8) + Ptr[6];
+                data_size = (Ptr[11] << 24) + (Ptr[10] << 16) + (Ptr[9] << 8) + (Ptr[8]);
+		data_offset = (Ptr[15] << 24) + (Ptr[14] << 16) + (Ptr[13] << 8) + (Ptr[12]);
+                DEBUG(g_print ("Image %d: %d x %d\n\tPalette: %d\n", I, width, height, Ptr[2]);
+                if (imgtype == 2)
+                  g_print ("\tHotspot: %d x %d\n", x_hot, y_hot);
+                else
+                  g_print ("\tColor planes: %d\n\tBits per pixel: %d\n", x_hot, y_hot);
+                g_print ("\tSize: %d\n\tOffset: %d\n", data_size, data_offset);)
+
 		entry = g_new0 (struct ico_direntry_data, 1);
-		entry->ImageScore = (Ptr[11] << 24) + (Ptr[10] << 16) + (Ptr[9] << 8) + (Ptr[8]);
-		if (entry->ImageScore == 0)
-			entry->ImageScore = 256;
-		entry->x_hot = (Ptr[5] << 8) + Ptr[4];
-		entry->y_hot = (Ptr[7] << 8) + Ptr[6];
-		entry->DIBoffset = (Ptr[15]<<24)+(Ptr[14]<<16)+
-		                   (Ptr[13]<<8) + (Ptr[12]);
+		entry->ImageScore = data_size;
+
+                entry->width = width ? width : 256;
+                entry->height = height ? height : 256;
+		entry->x_hot = x_hot;
+		entry->y_hot = y_hot;
+		entry->DIBoffset = data_offset;
 		State->entries = g_list_insert_sorted (State->entries, entry, compare_direntry_scores);
 		Ptr += 16;
-	} 
+	}
 
 	/* Now go through and find one we can parse */
 	entry = NULL;
@@ -285,10 +310,10 @@ static void DecodeHeader(guchar *Data, g
 		entry = l->data;
 
 		if (entry->DIBoffset < 0) {
-			g_set_error_literal (error,
-			                     GDK_PIXBUF_ERROR,
-			                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-			                     _("Invalid header in icon"));
+			g_set_error (error,
+			             GDK_PIXBUF_ERROR,
+			             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			             _("Invalid header in icon (%s)"), "dib offset");
 			return;
 		}
 
@@ -296,10 +321,10 @@ static void DecodeHeader(guchar *Data, g
 		State->HeaderSize = entry->DIBoffset + 40; /* 40 = sizeof(InfoHeader) */
 
 		if (State->HeaderSize < 0) {
-			g_set_error_literal (error,
-			                     GDK_PIXBUF_ERROR,
-			                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-			                     _("Invalid header in icon"));
+			g_set_error (error,
+			             GDK_PIXBUF_ERROR,
+			             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			             _("Invalid header in icon (%s)"), "header size");
 			return;
 		}
 
@@ -346,9 +371,9 @@ static void DecodeHeader(guchar *Data, g
 
 #ifdef DUMPBIH
 	DumpBIH(BIH);
-#endif	
+#endif
 	/* Add the palette to the headersize */
-		
+
 	State->Header.width =
 	    (int)(BIH[7] << 24) + (BIH[6] << 16) + (BIH[5] << 8) + (BIH[4]);
 	if (State->Header.width == 0)
@@ -359,12 +384,28 @@ static void DecodeHeader(guchar *Data, g
 	    /* /2 because the BIH height includes the transparency mask */
 	if (State->Header.height == 0)
 		State->Header.height = 256;
+
+	/* Negative heights mean top-down pixel-order */
+	if (State->Header.height < 0) {
+		State->Header.height = -State->Header.height;
+		State->Header.Negative = 1;
+	}
+	if (State->Header.width < 0) {
+		State->Header.width = -State->Header.width;
+	}
+
+        if (State->Header.width != entry->width ||
+            State->Header.height != entry->height) {
+		g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             _("Invalid header in icon (%s)"), "image size");
+		return;
+        }
+
 	State->Header.depth = (BIH[15] << 8) + (BIH[14]);
+	State->Type = State->Header.depth;
 
-	State->Type = State->Header.depth;	
-	if (State->Lines>=State->Header.height)
-		State->Type = 1; /* The transparency mask is 1 bpp */
-	
 	/* Determine the  palette size. If the header indicates 0, it
 	   is actually the maximum for the bpp. You have to love the
 	   guys who made the spec. */
@@ -380,10 +421,10 @@ static void DecodeHeader(guchar *Data, g
 	State->HeaderSize+=I;
 	
 	if (State->HeaderSize < 0) {
-		g_set_error_literal (error,
-                                     GDK_PIXBUF_ERROR,
-                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-                                     _("Invalid header in icon"));
+		g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             _("Invalid header in icon (%s)"), "palette size");
 		return;
 	}
 
@@ -402,17 +443,6 @@ static void DecodeHeader(guchar *Data, g
  	if (Bytes < State->HeaderSize)
  		return;
 
-	/* Negative heights mean top-down pixel-order */
-	if (State->Header.height < 0) {
-		State->Header.height = -State->Header.height;
-		State->Header.Negative = 1;
-	}
-	if (State->Header.width < 0) {
-		State->Header.width = -State->Header.width;
-	}
-	g_assert (State->Header.width > 0);
-	g_assert (State->Header.height > 0);
-
         if (State->Type == 32)
                 State->LineWidth = State->Header.width * 4;
         else if (State->Type == 24)
@@ -455,7 +485,6 @@ static void DecodeHeader(guchar *Data, g
 
 
 	if (State->pixbuf == NULL) {
-#if 1
 		if (State->size_func) {
 			gint width = State->Header.width;
 			gint height = State->Header.height;
@@ -466,7 +495,6 @@ static void DecodeHeader(guchar *Data, g
 				return;
 			}
 		}
-#endif
 
 		State->pixbuf =
 		    gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8,
