Description: Fix a heap based buffer overflow (CVE-2015-7552)
Origin: upstream, multiple
Bug: https://bugzilla.gnome.org/show_bug.cgi?id=747605
Upstream commits: 
 https://git.gnome.org/browse/gdk-pixbuf/commit/?id=7b10db13ff370bf2500688054249101ff175a942
 https://git.gnome.org/browse/gdk-pixbuf/commit/?id=ca74893a8e06e99b4adc682ee1550bfd020687c7
 https://git.gnome.org/browse/gdk-pixbuf/commit/?id=b7bf6fbfb310fceba2d35d4de143b8d5ffdad990
 https://git.gnome.org/browse/gdk-pixbuf/commit/?id=4f68cb78a5277f169b9531e6998c00c7976594e4
Forwarded: not-needed
Last-Update: 2016-09-20

--- gdk-pixbuf-2.30.7.orig/gdk-pixbuf/gdk-pixbuf-scale.c
+++ gdk-pixbuf-2.30.7/gdk-pixbuf/gdk-pixbuf-scale.c
@@ -373,7 +373,7 @@ gdk_pixbuf_composite_color_simple (const
   return dest;
 }
 
-#define OFFSET(pb, x, y) ((x) * (pb)->n_channels + (y) * (pb)->rowstride)
+#define OFFSET(pb, x, y) ((x) * (pb)->n_channels + (gsize)(y) * (pb)->rowstride)
 
 /**
  * gdk_pixbuf_rotate_simple:
--- gdk-pixbuf-2.30.7.orig/gdk-pixbuf/io-bmp.c
+++ gdk-pixbuf-2.30.7/gdk-pixbuf/io-bmp.c
@@ -318,11 +318,31 @@ static gboolean DecodeHeader(unsigned ch
 		return FALSE;
 	}
 
+        if (State->Header.depth > 32)
+          {
+		g_set_error_literal (error,
+                                     GDK_PIXBUF_ERROR,
+                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                                     _("BMP image has unsupported depth"));
+		State->read_state = READ_STATE_ERROR;
+		return FALSE;
+          }
+
 	if (State->Header.size == 12)
 		clrUsed = 1 << State->Header.depth;
 	else
 		clrUsed = (int) (BIH[35] << 24) + (BIH[34] << 16) + (BIH[33] << 8) + (BIH[32]);
 
+        if (clrUsed > (1 << State->Header.depth))
+          {
+		g_set_error_literal (error,
+                                     GDK_PIXBUF_ERROR,
+                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                                     _("BMP image has oversize palette"));
+		State->read_state = READ_STATE_ERROR;
+		return FALSE;
+          }
+
 	if (clrUsed != 0)
 		State->Header.n_colors = clrUsed;
 	else
--- gdk-pixbuf-2.30.7.orig/gdk-pixbuf/io-ico.c
+++ gdk-pixbuf-2.30.7/gdk-pixbuf/io-ico.c
@@ -586,11 +586,11 @@ OneLine32 (struct ico_progressive_state
         X = 0;
         if (context->Header.Negative == 0)
                 Pixels = (context->pixbuf->pixels +
-                          context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
                           (context->Header.height - context->Lines - 1));
         else
                 Pixels = (context->pixbuf->pixels +
-                          context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
                           context->Lines);
         while (X < context->Header.width) {
                 Pixels[X * 4 + 0] = context->LineBuf[X * 4 + 2];
@@ -609,11 +609,11 @@ static void OneLine24(struct ico_progres
 	X = 0;
 	if (context->Header.Negative == 0)
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  (context->Header.height - context->Lines - 1));
 	else
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  context->Lines);
 	while (X < context->Header.width) {
 		Pixels[X * 4 + 0] = context->LineBuf[X * 3 + 2];
@@ -633,10 +633,12 @@ OneLine16 (struct ico_progressive_state
 
         if (context->Header.Negative == 0)
                 pixels = (context->pixbuf->pixels +
-                          context->pixbuf->rowstride * (context->Header.height - context->Lines - 1));
+			  (gsize) context->pixbuf->rowstride *
+                          (context->Header.height - context->Lines - 1));
         else
                 pixels = (context->pixbuf->pixels +
-                          context->pixbuf->rowstride * context->Lines);
+			  (gsize) context->pixbuf->rowstride *
+                          context->Lines);
 
         src = context->LineBuf;
 
@@ -670,11 +672,11 @@ static void OneLine8(struct ico_progress
 	X = 0;
 	if (context->Header.Negative == 0)
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  (context->Header.height - context->Lines - 1));
 	else
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  context->Lines);
 	while (X < context->Header.width) {
 		/* The joys of having a BGR byteorder */
@@ -695,11 +697,11 @@ static void OneLine4(struct ico_progress
 	X = 0;
 	if (context->Header.Negative == 0)
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  (context->Header.height - context->Lines - 1));
 	else
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  context->Lines);
 	
 	while (X < context->Header.width) {
@@ -736,11 +738,11 @@ static void OneLine1(struct ico_progress
 	X = 0;
 	if (context->Header.Negative == 0)
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  (context->Header.height - context->Lines - 1));
 	else
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  context->Lines);
 	while (X < context->Header.width) {
 		int Bit;
@@ -767,11 +769,11 @@ static void OneLineTransp(struct ico_pro
 	X = 0;
 	if (context->Header.Negative == 0)
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  (2*context->Header.height - context->Lines - 1));
 	else
 		Pixels = (context->pixbuf->pixels +
-			  context->pixbuf->rowstride *
+			  (gsize) context->pixbuf->rowstride *
 			  (context->Lines-context->Header.height));
 	while (X < context->Header.width) {
 		int Bit;
@@ -1047,7 +1049,7 @@ fill_entry (IconEntry *icon,
 	pixels = gdk_pixbuf_get_pixels (pixbuf);
 	n_channels = gdk_pixbuf_get_n_channels (pixbuf);
 	for (y = 0; y < icon->height; y++) {
-		p = pixels + gdk_pixbuf_get_rowstride (pixbuf) * (icon->height - 1 - y);
+		p = pixels + (gsize) gdk_pixbuf_get_rowstride (pixbuf) * (icon->height - 1 - y);
 		and = icon->and + icon->and_rowstride * y;
 		xor = icon->xor + icon->xor_rowstride * y;
 		for (x = 0; x < icon->width; x++) {
