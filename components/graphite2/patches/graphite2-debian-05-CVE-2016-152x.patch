Description: fix out of bounds access
Origin: backport, https://github.com/silnrsi/graphite/commit/4e232ad3697bd0121fd3cbfd8c3d9e2617fce1b8

Index: graphite2-1.2.4/src/Bidi.cpp
===================================================================
--- src/Bidi.cpp	2016-02-11 09:07:31.504431805 -0500
+++ src/Bidi.cpp	2016-02-11 09:07:31.496431724 -0500
@@ -571,35 +571,38 @@
             mask |= 2;
         }
     }
-    for (p = stack.start(); p; p =p->next())      // walk the stack
+    if (stack.size())
     {
-        if (p->close() && p->mask())
+        for (p = stack.start(); p; p =p->next())      // walk the stack
         {
-            int dir = (level & 1) + 1;
-            if (p->mask() & dir)
-            { }
-            else if (p->mask() & (1 << (~level & 1)))  // if inside has strong other embedding
+            if (p->close() && p->mask())
             {
-                int ldir = p->before();
-                if ((p->before() == OPP || p->before() == CPP) && p->prev())
+                int dir = (level & 1) + 1;
+                if (p->mask() & dir)
+                { }
+                else if (p->mask() & (1 << (~level & 1)))  // if inside has strong other embedding
                 {
-                    for (BracketPair *q = p->prev(); q; q = q->prev())
+                    int ldir = p->before();
+                    if ((p->before() == OPP || p->before() == CPP) && p->prev())
                     {
-                        ldir = q->open()->getBidiClass();
-                        if (ldir < 3) break;
-                        ldir = q->before();
-                        if (ldir < 3) break;
+                        for (BracketPair *q = p->prev(); q; q = q->prev())
+                        {
+                            ldir = q->open()->getBidiClass();
+                            if (ldir < 3) break;
+                            ldir = q->before();
+                            if (ldir < 3) break;
+                        }
+                        if (ldir > 2) ldir = 0;
                     }
-                    if (ldir > 2) ldir = 0;
+                    if (ldir > 0 && (ldir - 1) != (level & 1))     // is dir given opp. to level dir (ldir == R or L)
+                        dir = (~level & 1) + 1;
                 }
-                if (ldir > 0 && (ldir - 1) != (level & 1))     // is dir given opp. to level dir (ldir == R or L)
-                    dir = (~level & 1) + 1;
+                p->open()->setBidiClass(dir);
+                p->close()->setBidiClass(dir);
             }
-            p->open()->setBidiClass(dir);
-            p->close()->setBidiClass(dir);
         }
+        stack.clear();
     }
-    stack.clear();
 }
 
 int GetDeferredNeutrals(int action, int level)
Description: handle fonts with 0 features
Origin: backport, https://github.com/silnrsi/graphite/commit/a94bbf1a651b13ecfaf9a774a841d36964c25929

diff --git a/src/FeatureMap.cpp b/src/FeatureMap.cpp
index 7cc3c72..199ff70 100644
--- src/FeatureMap.cpp
+++ src/FeatureMap.cpp
@@ -165,16 +165,16 @@ bool FeatureMap::readFeats(const Face & face)
                                        label, uiName, flags,
                                        uiSet, num_settings);
     }
-    m_defaultFeatures = new Features(bits/(sizeof(uint32)*8) + 1, *this);
+    new (&m_defaultFeatures) Features(bits/(sizeof(uint32)*8) + 1, *this);
     m_pNamedFeats = new NameAndFeatureRef[m_numFeats];
-    if (!m_defaultFeatures || !m_pNamedFeats)
+    if (!m_pNamedFeats)
     {
         free(defVals);
         return false;
     }
     for (int i = 0; i < m_numFeats; ++i)
     {
-        m_feats[i].applyValToFeature(defVals[i], *m_defaultFeatures);
+        m_feats[i].applyValToFeature(defVals[i], m_defaultFeatures);
         m_pNamedFeats[i] = m_feats+i;
     }
     
@@ -214,7 +214,7 @@ bool SillMap::readSill(const Face & face)
         uint16 numSettings = be::read<uint16>(p);
         uint16 offset = be::read<uint16>(p);
         if (offset + 8U * numSettings > sill.size() && numSettings > 0) return false;
-        Features* feats = new Features(*m_FeatureMap.m_defaultFeatures);
+        Features* feats = new Features(m_FeatureMap.m_defaultFeatures);
         if (!feats) return false;
         const byte *pLSet = sill + offset;
 
@@ -250,7 +250,7 @@ Features* SillMap::cloneFeatures(uint32 langname/*0 means default*/) const
                 return new Features(*m_langFeats[i].m_pFeatures);
         }
     }
-    return new Features (*m_FeatureMap.m_defaultFeatures);
+    return new Features (m_FeatureMap.m_defaultFeatures);
 }
 
 
diff --git a/src/inc/FeatureMap.h b/src/inc/FeatureMap.h
index bc8a5db..a199a87 100644
--- src/inc/FeatureMap.h
+++ src/inc/FeatureMap.h
@@ -117,9 +117,8 @@ class NameAndFeatureRef
 class FeatureMap
 {
 public:
-    FeatureMap() : m_numFeats(0), m_feats(NULL), m_pNamedFeats(NULL),
-        m_defaultFeatures(NULL) {}
-    ~FeatureMap() { delete [] m_feats; delete[] m_pNamedFeats; delete m_defaultFeatures; }
+    FeatureMap() : m_numFeats(0), m_feats(NULL), m_pNamedFeats(NULL) {}
+    ~FeatureMap() { delete [] m_feats; delete[] m_pNamedFeats; }
 
     bool readFeats(const Face & face);
     const FeatureRef *findFeatureRef(uint32 name) const;
@@ -135,7 +134,7 @@ friend class SillMap;
 
     FeatureRef *m_feats;
     NameAndFeatureRef* m_pNamedFeats;   //owned
-    FeatureVal* m_defaultFeatures;        //owned
+    FeatureVal m_defaultFeatures;        //owned
     
 private:        //defensive on m_feats, m_pNamedFeats, and m_defaultFeatures
     FeatureMap(const FeatureMap&);
Description: fix out-of-bounds read
Origin: backport, https://github.com/silnrsi/graphite/commit/98266d29bf0c9ebc5553630385abd868767f160b

Index: graphite2-1.2.4/src/TtfUtil.cpp
===================================================================
--- src/TtfUtil.cpp	2016-02-11 09:34:35.537727854 -0500
+++ src/TtfUtil.cpp	2016-02-11 09:34:35.533727812 -0500
@@ -1149,7 +1149,7 @@
     // CheckTable verifies the index_to_loc_format is valid
     if (be::swap(pTable->index_to_loc_format) == Sfnt::FontHeader::ShortIndexLocFormat)
     { // loca entries are two bytes and have been divided by two
-        if (nGlyphId < (lLocaSize >> 1) - 1) // allow sentinel value to be accessed
+        if (lLocaSize > 1 && nGlyphId + 1u < lLocaSize >> 1) // allow sentinel value to be accessed
         {
             const uint16 * pShortTable = reinterpret_cast<const uint16 *>(pLoca);
             return (be::peek<uint16>(pShortTable + nGlyphId) << 1);
@@ -1158,7 +1158,7 @@
     
     if (be::swap(pTable->index_to_loc_format) == Sfnt::FontHeader::LongIndexLocFormat)
     { // loca entries are four bytes
-        if (nGlyphId < (lLocaSize >> 2) - 1)
+        if (lLocaSize > 3 && nGlyphId + 1u < lLocaSize >> 2)
         {
             const uint32 * pLongTable = reinterpret_cast<const uint32 *>(pLoca);
             return be::peek<uint32>(pLongTable + nGlyphId);
Description: check for cntxtItem misalignment
Origin: backport, https://github.com/silnrsi/graphite/commit/6c50e793e5879a0aaf830fcdd16841dd28906f8b
Origin: backport, https://github.com/silnrsi/graphite/commit/f9278ab70cdff869e81082016fd848e98ba184de

Index: graphite2-1.2.4/src/Code.cpp
===================================================================
--- src/Code.cpp	2016-02-11 10:25:52.373490083 -0500
+++ src/Code.cpp	2016-02-11 10:26:43.790054613 -0500
@@ -94,7 +94,7 @@
 
     };
     
-    decoder(const limits & lims, Code &code) throw();
+    decoder(limits & lims, Code &code) throw();
     
     bool        load(const byte * bc_begin, const byte * bc_end);
     void        apply_analysis(instr * const code, instr * code_end);
@@ -114,14 +114,14 @@
     uint16              _rule_length;
     instr             * _instr;
     byte              * _data;
-    const limits      & _max;
+    limits            & _max;
     analysis            _analysis;
 };
 
 
 struct Machine::Code::decoder::limits
 {
-  const byte * const bytecode;
+  const byte       * bytecode;
   const uint8        pre_context;
   const uint16       rule_length,
                      classes,
@@ -130,7 +130,7 @@
   const byte         attrid[gr_slatMax];
 };
    
-inline Machine::Code::decoder::decoder(const limits & lims, Code &code) throw()
+inline Machine::Code::decoder::decoder(limits & lims, Code &code) throw()
 : _code(code),
   _pre_context(code._constraint ? 0 : lims.pre_context), 
   _rule_length(code._constraint ? 1 : lims.rule_length), 
@@ -168,7 +168,7 @@
         return;
     }
     
-    const decoder::limits lims = {
+    decoder::limits lims = {
         bytecode_end,
         pre_context,
         rule_length,
@@ -237,6 +237,7 @@
 
 bool Machine::Code::decoder::load(const byte * bc, const byte * bc_end)
 {
+    _max.bytecode = bc_end;
     while (bc < bc_end)
     {
         const opcode opc = fetch_opcode(bc++);
@@ -506,16 +507,20 @@
         byte & instr_skip = _data[-1];
         byte & data_skip  = *_data++;
         ++_code._data_size;
+        const byte *curr_end = _max.bytecode;
 
         if (load(bc, bc + instr_skip))
         {
             bc += instr_skip;
             data_skip  = instr_skip - (_code._instr_count - ctxt_start);
             instr_skip = _code._instr_count - ctxt_start;
+            _max.bytecode = curr_end;
 
             _rule_length = 1;
             _pre_context = 0;
         }
+        else
+            return false;
     }
     
     return bool(_code);
@@ -554,7 +559,7 @@
     }
     const opcode_t & op = Machine::getOpcodeTable()[opc];
     const size_t param_sz = op.param_sz == VARARGS ? bc[0] + 1 : op.param_sz;
-    if (bc + param_sz > _max.bytecode)
+    if (bc - 1 + param_sz >= _max.bytecode)
     {
         failure(arguments_exhausted);
         return false;
Description: disallow nested cntxt_item
Origin: backport, https://github.com/silnrsi/graphite/commit/2fc07f868146f924621307925b92a5161b7bd571
Origin: backport, https://github.com/silnrsi/graphite/commit/6106dcbd5bc4df2e6ef6a7c632c69ca71ba2b518

Index: graphite2-1.2.4/src/Code.cpp
===================================================================
--- src/Code.cpp	2016-02-11 10:40:10.922786019 -0500
+++ src/Code.cpp	2016-02-11 10:40:38.159076948 -0500
@@ -116,6 +116,7 @@
     byte              * _data;
     limits            & _max;
     analysis            _analysis;
+    bool                _in_ctxt_item;
 };
 
 
@@ -134,7 +135,7 @@
 : _code(code),
   _pre_context(code._constraint ? 0 : lims.pre_context), 
   _rule_length(code._constraint ? 1 : lims.rule_length), 
-  _instr(code._code), _data(code._data), _max(lims)
+  _instr(code._code), _data(code._data), _max(lims), _in_ctxt_item(false)
 { }
     
 
@@ -319,8 +320,8 @@
             break;
         case CNTXT_ITEM :
             valid_upto(_max.rule_length, _max.pre_context + int8(bc[0]));
-            if (bc + 2 + bc[1] >= _max.bytecode)  failure(jump_past_end);
-            if (_pre_context != 0)                failure(nested_context_item);
+            if (bc + 2 + bc[1] >= _max.bytecode)    failure(jump_past_end);
+            if (_in_ctxt_item)                      failure(nested_context_item);
             break;
         case ATTR_SET :
         case ATTR_ADD :
@@ -500,6 +501,7 @@
     if (opc == CNTXT_ITEM)
     {
         assert(_pre_context == 0);
+        _in_ctxt_item = true;
         _pre_context = _max.pre_context + int8(_data[-2]);
         _rule_length = _max.rule_length;
 
@@ -518,6 +520,7 @@
 
             _rule_length = 1;
             _pre_context = 0;
+            _in_ctxt_item = false;
         }
         else
             return false;
