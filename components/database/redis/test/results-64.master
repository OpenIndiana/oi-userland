make[1]: Entering directory '$(@D)'
cd src && /usr/gnu/bin/make check
make[2]: Entering directory '$(@D)/src'
    [34mCC[0m [33mMakefile.dep[0m
rm -rf redis-server redis-sentinel redis-cli redis-benchmark redis-check-rdb redis-check-aof *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep
rm -f adlist.d quicklist.d ae.d anet.d dict.d server.d sds.d zmalloc.d lzf_c.d lzf_d.d pqsort.d zipmap.d sha1.d ziplist.d release.d networking.d util.d object.d db.d replication.d rdb.d t_string.d t_list.d t_set.d t_zset.d t_hash.d config.d aof.d pubsub.d multi.d debug.d sort.d intset.d syncio.d cluster.d crc16.d endianconv.d slowlog.d scripting.d bio.d rio.d rand.d memtest.d crcspeed.d crc64.d bitops.d sentinel.d notify.d setproctitle.d blocked.d hyperloglog.d latency.d sparkline.d redis-check-rdb.d redis-check-aof.d geo.d lazyfree.d module.d evict.d expire.d geohash.d geohash_helper.d childinfo.d defrag.d siphash.d rax.d t_stream.d listpack.d localtime.d lolwut.d lolwut5.d lolwut6.d acl.d gopher.d tracking.d connection.d tls.d sha256.d timeout.d setcpuaffinity.d monotonic.d mt19937-64.d anet.d adlist.d dict.d redis-cli.d zmalloc.d release.d ae.d crcspeed.d crc64.d siphash.d crc16.d monotonic.d cli_common.d mt19937-64.d ae.d anet.d redis-benchmark.d adlist.d dict.d zmalloc.d release.d crcspeed.d crc64.d siphash.d crc16.d monotonic.d cli_common.d mt19937-64.d
(cd ../deps && /usr/gnu/bin/make distclean)
make[3]: Entering directory '$(@D)/deps'
(cd hiredis && /usr/gnu/bin/make clean) > /dev/null || true
(cd linenoise && /usr/gnu/bin/make clean) > /dev/null || true
(cd lua && /usr/gnu/bin/make clean) > /dev/null || true
(cd jemalloc && [ -f Makefile ] && /usr/gnu/bin/make distclean) > /dev/null || true
(cd hdr_histogram && /usr/gnu/bin/make clean) > /dev/null || true
(rm -f .make-*)
make[3]: Leaving directory '$(@D)/deps'
(rm -f .make-*)
echo STD=-pedantic -DREDIS_STATIC= -std=c99 >> .make-settings
echo WARN=-Wall -W -Wno-missing-field-initializers >> .make-settings
echo OPT=-O2 >> .make-settings
echo MALLOC=libc >> .make-settings
echo BUILD_TLS= >> .make-settings
echo USE_SYSTEMD= >> .make-settings
echo CFLAGS=-m64 -O3 -m64 -m64 >> .make-settings
echo LDFLAGS=-m64 -m64 -m64 >> .make-settings
echo REDIS_CFLAGS= >> .make-settings
echo REDIS_LDFLAGS= >> .make-settings
echo PREV_FINAL_CFLAGS=-pedantic -DREDIS_STATIC= -std=c99 -Wall -W -Wno-missing-field-initializers -O2 -g -m64 -O3 -m64 -m64  -D__EXTENSIONS__ -D_XPG6 -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -I../deps/hdr_histogram >> .make-settings
echo PREV_FINAL_LDFLAGS=-m64 -m64 -m64  -g >> .make-settings
(cd ../deps && /usr/gnu/bin/make hiredis linenoise lua hdr_histogram)
make[3]: Entering directory '$(@D)/deps'
(cd hiredis && /usr/gnu/bin/make clean) > /dev/null || true
(cd linenoise && /usr/gnu/bin/make clean) > /dev/null || true
(cd lua && /usr/gnu/bin/make clean) > /dev/null || true
(cd jemalloc && [ -f Makefile ] && /usr/gnu/bin/make distclean) > /dev/null || true
(cd hdr_histogram && /usr/gnu/bin/make clean) > /dev/null || true
(rm -f .make-*)
(echo "-m64 -O3 -m64 -m64" > .make-cflags)
(echo "-m64 -m64 -m64" > .make-ldflags)
[32;1mMAKE[0m [37;1mhiredis[0m
cd hiredis && /usr/gnu/bin/make static 
make[4]: Entering directory '$(@D)/deps/hiredis'
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g alloc.c
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g net.c
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g hiredis.c
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g sds.c
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g async.c
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g read.c
/usr/gcc/7/bin/gcc -std=c99 -pedantic -c -O3 -fPIC  -m64 -O3 -m64 -m64 -I/usr/local/opt/openssl/include -Wall -W -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -g sockcompat.c
ar rcs libhiredis.a alloc.o net.o hiredis.o sds.o async.o read.o sockcompat.o
make[4]: Leaving directory '$(@D)/deps/hiredis'
[32;1mMAKE[0m [37;1mlinenoise[0m
cd linenoise && /usr/gnu/bin/make
make[4]: Entering directory '$(@D)/deps/linenoise'
/usr/gcc/7/bin/gcc  -Wall -Os -g -m64 -O3 -m64 -m64 -c linenoise.c
make[4]: Leaving directory '$(@D)/deps/linenoise'
[32;1mMAKE[0m [37;1mlua[0m
cd lua/src && /usr/gnu/bin/make all CFLAGS="-O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64" MYLDFLAGS="-m64 -m64 -m64" AR="ar rc"
make[4]: Entering directory '$(@D)/deps/lua/src'
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lapi.o lapi.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lcode.o lcode.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ldebug.o ldebug.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ldo.o ldo.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ldump.o ldump.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lfunc.o lfunc.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lgc.o lgc.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o llex.o llex.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lmem.o lmem.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lobject.o lobject.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lopcodes.o lopcodes.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lparser.o lparser.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lstate.o lstate.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lstring.o lstring.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ltable.o ltable.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ltm.o ltm.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lundump.o lundump.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lvm.o lvm.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lzio.o lzio.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o strbuf.o strbuf.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o fpconv.o fpconv.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lauxlib.o lauxlib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lbaselib.o lbaselib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ldblib.o ldblib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o liolib.o liolib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lmathlib.o lmathlib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o loslib.o loslib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o ltablib.o ltablib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lstrlib.o lstrlib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o loadlib.o loadlib.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o linit.o linit.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lua_cjson.o lua_cjson.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lua_struct.o lua_struct.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lua_cmsgpack.o lua_cmsgpack.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lua_bit.o lua_bit.c
ar rc liblua.a lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o ltm.o lundump.o lvm.o lzio.o strbuf.o fpconv.o lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o loadlib.o linit.o lua_cjson.o lua_struct.o lua_cmsgpack.o lua_bit.o	# DLL needs all object files
ranlib liblua.a
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o lua.o lua.c
/usr/gcc/7/bin/gcc -o lua -m64 -m64 -m64 lua.o liblua.a -lm 
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o luac.o luac.c
/usr/gcc/7/bin/gcc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' -DLUA_USE_MKSTEMP -m64 -O3 -m64 -m64   -c -o print.o print.c
/usr/gcc/7/bin/gcc -o luac -m64 -m64 -m64 luac.o print.o liblua.a -lm 
make[4]: Leaving directory '$(@D)/deps/lua/src'
[32;1mMAKE[0m [37;1mhdr_histogram[0m
cd hdr_histogram && /usr/gnu/bin/make
make[4]: Entering directory '$(@D)/deps/hdr_histogram'
/usr/gcc/7/bin/gcc  -Wall -Os -g -m64 -O3 -m64 -m64 -c  hdr_histogram.c 
make[4]: Leaving directory '$(@D)/deps/hdr_histogram'
make[3]: Leaving directory '$(@D)/deps'
    [34mCC[0m [33madlist.o[0m
    [34mCC[0m [33mquicklist.o[0m
    [34mCC[0m [33mae.o[0m
    [34mCC[0m [33manet.o[0m
    [34mCC[0m [33mdict.o[0m
    [34mCC[0m [33mserver.o[0m
    [34mCC[0m [33msds.o[0m
    [34mCC[0m [33mzmalloc.o[0m
    [34mCC[0m [33mlzf_c.o[0m
    [34mCC[0m [33mlzf_d.o[0m
    [34mCC[0m [33mpqsort.o[0m
    [34mCC[0m [33mzipmap.o[0m
    [34mCC[0m [33msha1.o[0m
    [34mCC[0m [33mziplist.o[0m
    [34mCC[0m [33mrelease.o[0m
    [34mCC[0m [33mnetworking.o[0m
    [34mCC[0m [33mutil.o[0m
    [34mCC[0m [33mobject.o[0m
    [34mCC[0m [33mdb.o[0m
    [34mCC[0m [33mreplication.o[0m
    [34mCC[0m [33mrdb.o[0m
    [34mCC[0m [33mt_string.o[0m
    [34mCC[0m [33mt_list.o[0m
    [34mCC[0m [33mt_set.o[0m
    [34mCC[0m [33mt_zset.o[0m
    [34mCC[0m [33mt_hash.o[0m
    [34mCC[0m [33mconfig.o[0m
    [34mCC[0m [33maof.o[0m
    [34mCC[0m [33mpubsub.o[0m
    [34mCC[0m [33mmulti.o[0m
    [34mCC[0m [33mdebug.o[0m
    [34mCC[0m [33msort.o[0m
    [34mCC[0m [33mintset.o[0m
    [34mCC[0m [33msyncio.o[0m
    [34mCC[0m [33mcluster.o[0m
    [34mCC[0m [33mcrc16.o[0m
    [34mCC[0m [33mendianconv.o[0m
    [34mCC[0m [33mslowlog.o[0m
    [34mCC[0m [33mscripting.o[0m
    [34mCC[0m [33mbio.o[0m
    [34mCC[0m [33mrio.o[0m
    [34mCC[0m [33mrand.o[0m
    [34mCC[0m [33mmemtest.o[0m
    [34mCC[0m [33mcrcspeed.o[0m
    [34mCC[0m [33mcrc64.o[0m
    [34mCC[0m [33mbitops.o[0m
bitops.c: In function 'bitfieldGeneric':
bitops.c:213:54: warning: 'wrapped' may be used uninitialized in this function [-Wmaybe-uninitialized]
         bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~
bitops.c:1085:42: note: 'wrapped' was declared here
                 uint64_t oldval, newval, wrapped, retval;
                                          ^~~~~~~
    [34mCC[0m [33msentinel.o[0m
    [34mCC[0m [33mnotify.o[0m
    [34mCC[0m [33msetproctitle.o[0m
    [34mCC[0m [33mblocked.o[0m
    [34mCC[0m [33mhyperloglog.o[0m
    [34mCC[0m [33mlatency.o[0m
    [34mCC[0m [33msparkline.o[0m
    [34mCC[0m [33mredis-check-rdb.o[0m
    [34mCC[0m [33mredis-check-aof.o[0m
    [34mCC[0m [33mgeo.o[0m
    [34mCC[0m [33mlazyfree.o[0m
    [34mCC[0m [33mmodule.o[0m
    [34mCC[0m [33mevict.o[0m
    [34mCC[0m [33mexpire.o[0m
    [34mCC[0m [33mgeohash.o[0m
    [34mCC[0m [33mgeohash_helper.o[0m
    [34mCC[0m [33mchildinfo.o[0m
    [34mCC[0m [33mdefrag.o[0m
    [34mCC[0m [33msiphash.o[0m
    [34mCC[0m [33mrax.o[0m
    [34mCC[0m [33mt_stream.o[0m
    [34mCC[0m [33mlistpack.o[0m
    [34mCC[0m [33mlocaltime.o[0m
    [34mCC[0m [33mlolwut.o[0m
    [34mCC[0m [33mlolwut5.o[0m
    [34mCC[0m [33mlolwut6.o[0m
    [34mCC[0m [33macl.o[0m
    [34mCC[0m [33mgopher.o[0m
    [34mCC[0m [33mtracking.o[0m
    [34mCC[0m [33mconnection.o[0m
    [34mCC[0m [33mtls.o[0m
    [34mCC[0m [33msha256.o[0m
    [34mCC[0m [33mtimeout.o[0m
    [34mCC[0m [33msetcpuaffinity.o[0m
    [34mCC[0m [33mmonotonic.o[0m
    [34mCC[0m [33mmt19937-64.o[0m
    [34;1mLINK[0m [37;1mredis-server[0m
    [34;1mINSTALL[0m [37;1mredis-check-aof[0m
    [34mCC[0m [33mredis-cli.o[0m
    [34mCC[0m [33mcli_common.o[0m
    [34;1mLINK[0m [37;1mredis-cli[0m
    [34mCC[0m [33mredis-benchmark.o[0m
    [34;1mLINK[0m [37;1mredis-benchmark[0m
Cleanup: may take some time... OK
Starting test server at port 21079
[ready]: 15665
[1;37;49mTesting unit/printver[0m
[ready]: 15666
[1;37;49mTesting unit/dump[0m
[ready]: 15667
[1;37;49mTesting unit/auth[0m
[ready]: 15668
[1;37;49mTesting unit/protocol[0m
[ready]: 15669
[1;37;49mTesting unit/keyspace[0m
[ready]: 15670
[1;37;49mTesting unit/scan[0m
[ready]: 15671
[1;37;49mTesting unit/info[0m
[ready]: 15672
[1;37;49mTesting unit/type/string[0m
[ready]: 15673
[1;37;49mTesting unit/type/incr[0m
[ready]: 15674
[1;37;49mTesting unit/type/list[0m
[ready]: 15675
[1;37;49mTesting unit/type/list-2[0m
[ready]: 15678
[1;37;49mTesting unit/type/list-3[0m
[ready]: 15676
[1;37;49mTesting unit/type/set[0m
[ready]: 15679
[1;37;49mTesting unit/type/zset[0m
[ready]: 15680
[1;37;49mTesting unit/type/hash[0m
[ready]: 15677
[1;37;49mTesting unit/type/stream[0m
[[0;32;49mok[0m]: DUMP / RESTORE are able to serialize / unserialize a simple key
[[0;32;49mok[0m]: RESTORE can set an arbitrary expire to the materialized key
[[0;32;49mok[0m]: RESTORE can set an expire that overflows a 32 bit integer
[[0;32;49mok[0m]: RESTORE can set an absolute expire
[[0;32;49mok[0m]: RESTORE with ABSTTL in the past
[[0;32;49mok[0m]: AUTH fails if there is no password configured server side
[[0;32;49mok[0m]: RESTORE can set LRU
[[0;32;49mok[0m]: RESTORE can set LFU
[[0;32;49mok[0m]: RESTORE returns an error of the key already exists
[[0;32;49mok[0m]: Handle an empty query
[[0;32;49mok[0m]: Negative multibulk length
[[0;32;49mok[0m]: RESTORE can overwrite an existing key with REPLACE
[[0;32;49mok[0m]: RESTORE can detect a syntax error for unrecongized options
[[0;32;49mok[0m]: Out of range multibulk length
[[0;32;49mok[0m]: DUMP of non existing key returns nil
[[0;32;49mok[0m]: Wrong multibulk payload header
[[0;32;49mok[0m]: Negative multibulk payload length
[[0;32;49mok[0m]: Out of range multibulk payload length
[[0;32;49mok[0m]: Non-number multibulk payload length
[[0;32;49mok[0m]: Multi bulk request not followed by bulk arguments
[[0;32;49mok[0m]: Generic wrong number of args
[[0;32;49mok[0m]: Unbalanced number of quotes
[[0;32;49mok[0m]: SET and GET an item
[[0;32;49mok[0m]: DEL against a single item
[[0;32;49mok[0m]: SET and GET an empty item
[[0;32;49mok[0m]: Vararg DEL
[[0;32;49mok[0m]: KEYS with pattern
[[0;32;49mok[0m]: KEYS to get all keys
[[0;32;49mok[0m]: DBSIZE
[[0;32;49mok[0m]: DEL all keys
[[0;32;49mok[0m]: SCAN basic
[[0;32;49mok[0m]: SCAN COUNT
[[0;32;49mok[0m]: SCAN MATCH
[[0;32;49mok[0m]: Protocol desync regression test #1
[[0;32;49mok[0m]: Very big payload in GET/SET
[[0;32;49mok[0m]: SCAN TYPE
[[0;32;49mok[0m]: Protocol desync regression test #2
[[0;32;49mok[0m]: SSCAN with encoding intset
[[0;32;49mok[0m]: SSCAN with encoding hashtable
[[0;32;49mok[0m]: HSCAN with encoding ziplist
[[0;32;49mok[0m]: HSCAN with encoding hashtable
[[0;32;49mok[0m]: ZSCAN with encoding ziplist
[[0;32;49mok[0m]: Protocol desync regression test #3
Testing Redis version 6.2.4 (146376c9)
[[0;32;49mok[0m]: ZSCAN with encoding skiplist
[[0;32;49mok[0m]: SCAN guarantees check under write load
[[0;32;49mok[0m]: SSCAN with integer encoded object (issue #1345)
[[0;32;49mok[0m]: SSCAN with PATTERN
[[0;32;49mok[0m]: HSCAN with PATTERN
[[0;32;49mok[0m]: ZSCAN with PATTERN
[[0;32;49mok[0m]: INCR against non existing key
[[0;32;49mok[0m]: INCR against key created by incr itself
[[0;32;49mok[0m]: INCR against key originally set with SET
[[0;32;49mok[0m]: INCR over 32bit value
[[0;32;49mok[0m]: INCRBY over 32bit value with over 32bit increment
[[0;32;49mok[0m]: INCR fails against key with spaces (left)
[[0;32;49mok[0m]: LPOS basic usage
[[0;32;49mok[0m]: INCR fails against key with spaces (right)
[[0;32;49mok[0m]: INCR fails against key with spaces (both)
[[0;32;49mok[0m]: LPOS RANK (positive and negative rank) option
[[0;32;49mok[0m]: INCR fails against a key holding a list
[[0;32;49mok[0m]: DECRBY over 32bit value with over 32bit increment, negative res
[[0;32;49mok[0m]: LPOS COUNT option
[[0;32;49mok[0m]: LPOS COUNT + RANK option
[[0;32;49mok[0m]: LPOS non existing key
[[0;32;49mok[0m]: INCR uses shared objects in the 0-9999 range
[[0;32;49mok[0m]: LPOS no match
[[0;32;49mok[0m]: INCR can modify objects in-place
[[0;32;49mok[0m]: LPOS MAXLEN
[[0;32;49mok[0m]: LPOS when RANK is greater than matches
[[0;32;49mok[0m]: INCRBYFLOAT against non existing key
[[0;32;49mok[0m]: INCRBYFLOAT against key originally set with SET
[[0;32;49mok[0m]: INCRBYFLOAT over 32bit value
[[0;32;49mok[0m]: INCRBYFLOAT over 32bit value with over 32bit increment
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (left)
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (right)
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (both)
[[0;32;49mok[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist
[[0;32;49mok[0m]: INCRBYFLOAT fails against a key holding a list
[[0;32;49mok[0m]: INCRBYFLOAT does not allow NaN or Infinity
[[0;32;49mok[0m]: INCRBYFLOAT decrement
[[0;32;49mok[0m]: string to double with null terminator
[[0;32;49mok[0m]: No negative zero
[[0;32;49mok[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list
[[0;32;49mok[0m]: R/LPOP against empty list
[[0;32;49mok[0m]: R/LPOP with the optional count argument
[[0;32;49mok[0m]: Variadic RPUSH/LPUSH
[[0;32;49mok[0m]: DEL a list
[[0;32;49mok[0m]: BLPOP, BRPOP: single existing list - linkedlist
[[0;32;49mok[0m]: BLPOP, BRPOP: multiple existing lists - linkedlist
[[0;32;49mok[0m]: BLPOP, BRPOP: second list has an entry - linkedlist
[[0;32;49mok[0m]: BRPOPLPUSH - linkedlist
[[0;32;49mok[0m]: BLMOVE left left - linkedlist
[[0;32;49mok[0m]: BLMOVE left right - linkedlist
[[0;32;49mok[0m]: BLMOVE right left - linkedlist
[[0;32;49mok[0m]: BLMOVE right right - linkedlist
[[0;32;49mok[0m]: BLPOP, BRPOP: single existing list - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: multiple existing lists - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: second list has an entry - ziplist
[[0;32;49mok[0m]: BRPOPLPUSH - ziplist
[[0;32;49mok[0m]: BLMOVE left left - ziplist
[[0;32;49mok[0m]: BLMOVE left right - ziplist
[[0;32;49mok[0m]: BLMOVE right left - ziplist
[[0;32;49mok[0m]: BLMOVE right right - ziplist
[[0;32;49mok[0m]: BLPOP, LPUSH + DEL should not awake blocked client
[[0;32;49mok[0m]: ZSCAN scores: regression test for issue #2175
[1/64 [0;33;49mdone[0m]: unit/printver (0 seconds)
[1;37;49mTesting unit/type/stream-cgroups[0m
[2/64 [0;33;49mdone[0m]: unit/type/incr (0 seconds)
[1;37;49mTesting unit/sort[0m
[[0;32;49mok[0m]: BLPOP, LPUSH + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: BLPOP with same key multiple times should work (issue #801)
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BLPOP
[[0;32;49mok[0m]: BLPOP with variadic LPUSH
[[0;32;49mok[0m]: BRPOPLPUSH with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLMOVE left left with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLMOVE left right with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLMOVE right left with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLMOVE right right with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLMOVE (left, left) with a client BLPOPing the target list
[[0;32;49mok[0m]: BLMOVE (left, right) with a client BLPOPing the target list
[[0;32;49mok[0m]: BLMOVE (right, left) with a client BLPOPing the target list
[[0;32;49mok[0m]: BLMOVE (right, right) with a client BLPOPing the target list
[[0;32;49mok[0m]: BRPOPLPUSH with wrong source type
[[0;32;49mok[0m]: BRPOPLPUSH with wrong destination type
[[0;32;49mok[0m]: BRPOPLPUSH maintains order of elements after failure
[[0;32;49mok[0m]: BRPOPLPUSH with multiple blocked clients
[[0;32;49mok[0m]: Linked LMOVEs
[[0;32;49mok[0m]: Circular BRPOPLPUSH
[[0;32;49mok[0m]: Self-referential BRPOPLPUSH
[[0;32;49mok[0m]: BRPOPLPUSH inside a transaction
[[0;32;49mok[0m]: PUSH resulting from BRPOPLPUSH affect WATCH
[[0;32;49mok[0m]: BRPOPLPUSH does not affect WATCH while still blocked
[[0;32;49mok[0m]: Very big payload random access
[[0;32;49mok[0m]: DEL against expired key
[[0;32;49mok[0m]: EXISTS
[[0;32;49mok[0m]: Zero length value in key. SET/GET/EXISTS
[[0;32;49mok[0m]: Commands pipelining
[[0;32;49mok[0m]: Non existing command
[[0;32;49mok[0m]: RENAME basic usage
[[0;32;49mok[0m]: RENAME source key should no longer exist
[[0;32;49mok[0m]: RENAME against already existing key
[[0;32;49mok[0m]: RENAMENX basic usage
[[0;32;49mok[0m]: RENAMENX against already existing key
[[0;32;49mok[0m]: RENAMENX against already existing key (2)
[[0;32;49mok[0m]: RENAME against non existing source key
[[0;32;49mok[0m]: RENAME where source and dest key are the same (existing)
[[0;32;49mok[0m]: RENAMENX where source and dest key are the same (existing)
[[0;32;49mok[0m]: RENAME where source and dest key are the same (non existing)
[[0;32;49mok[0m]: RENAME with volatile key, should move the TTL as well
[[0;32;49mok[0m]: RENAME with volatile key, should not inherit TTL of target key
[[0;32;49mok[0m]: DEL all keys again (DB 0)
[[0;32;49mok[0m]: DEL all keys again (DB 1)
[[0;32;49mok[0m]: COPY basic usage for string
[[0;32;49mok[0m]: COPY for string does not replace an existing key without REPLACE option
[[0;32;49mok[0m]: COPY for string can replace an existing key with REPLACE option
[[0;32;49mok[0m]: COPY for string ensures that copied data is independent of copying data
[[0;32;49mok[0m]: COPY for string does not copy data to no-integer DB
[[0;32;49mok[0m]: COPY can copy key expire metadata as well
[[0;32;49mok[0m]: COPY does not create an expire if it does not exist
[[0;32;49mok[0m]: COPY basic usage for list
[[0;32;49mok[0m]: COPY basic usage for intset set
[[0;32;49mok[0m]: COPY basic usage for hashtable set
[[0;32;49mok[0m]: COPY basic usage for ziplist sorted set
[[0;32;49mok[0m]: COPY basic usage for skiplist sorted set
[[0;32;49mok[0m]: COPY basic usage for ziplist hash
[[0;32;49mok[0m]: COPY basic usage for hashtable hash
[[0;32;49mok[0m]: SET 10000 numeric keys and access all them in reverse order
[[0;32;49mok[0m]: DBSIZE should be 10000 now
[[0;32;49mok[0m]: SETNX target key missing
[[0;32;49mok[0m]: SETNX target key exists
[[0;32;49mok[0m]: SETNX against not-expired volatile key
[[0;32;49mok[0m]: COPY basic usage for stream
[[0;32;49mok[0m]: COPY basic usage for stream-cgroups
[[0;32;49mok[0m]: MOVE basic usage
[[0;32;49mok[0m]: MOVE against key existing in the target DB
[[0;32;49mok[0m]: MOVE against non-integer DB (#1428)
[[0;32;49mok[0m]: MOVE can move key expire metadata as well
[[0;32;49mok[0m]: MOVE does not create an expire if it does not exist
[[0;32;49mok[0m]: SET/GET keys in different DBs
[[0;32;49mok[0m]: RANDOMKEY
[[0;32;49mok[0m]: RANDOMKEY against empty DB
[[0;32;49mok[0m]: RANDOMKEY regression 1
[[0;32;49mok[0m]: KEYS * two times with long key, Github issue #1208
[[0;32;49mok[0m]: Explicit regression for a list bug
[[0;32;49mok[0m]: Regression for quicklist #3343 bug
[[0;32;49mok[0m]: HSET/HLEN - Small hash creation
[[0;32;49mok[0m]: Check encoding - ziplist
[[0;32;49mok[0m]: SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - regular set
[[0;32;49mok[0m]: Is the small hash encoded with a ziplist?
[[0;32;49mok[0m]: ZSET basic ZADD and score update - ziplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZADD - ziplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZINCRBY - ziplist
[[0;32;49mok[0m]: XADD can add entries into a stream that XRANGE can fetch
[[0;32;49mok[0m]: ZADD with options syntax error with incomplete pair - ziplist
[[0;32;49mok[0m]: SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - intset
[[0;32;49mok[0m]: XADD IDs are incremental
[[0;32;49mok[0m]: SMISMEMBER against non set
[[0;32;49mok[0m]: ZADD XX option without key - ziplist
[[0;32;49mok[0m]: SMISMEMBER non existing key
[[0;32;49mok[0m]: ZADD XX existing key - ziplist
[[0;32;49mok[0m]: XADD IDs are incremental when ms is the same as well
[[0;32;49mok[0m]: ZADD XX returns the number of elements actually added - ziplist
[[0;32;49mok[0m]: SMISMEMBER requires one or more members
[[0;32;49mok[0m]: XADD IDs correctly report an error when overflowing
[[0;32;49mok[0m]: SADD against non set
[[0;32;49mok[0m]: ZADD XX updates existing elements score - ziplist
[[0;32;49mok[0m]: SADD a non-integer against an intset
[[0;32;49mok[0m]: ZADD GT updates existing elements when new scores are greater - ziplist
[[0;32;49mok[0m]: SADD an integer larger than 64 bits
[[0;32;49mok[0m]: ZADD LT updates existing elements when new scores are lower - ziplist
[[0;32;49mok[0m]: ZADD GT XX updates existing elements when new scores are greater and skips new elements - ziplist
[[0;32;49mok[0m]: ZADD LT XX updates existing elements when new scores are lower and skips new elements - ziplist
[[0;32;49mok[0m]: ZADD XX and NX are not compatible - ziplist
[[0;32;49mok[0m]: ZADD NX with non existing key - ziplist
[[0;32;49mok[0m]: ZADD NX only add new elements without updating old ones - ziplist
[[0;32;49mok[0m]: BRPOPLPUSH timeout
[[0;32;49mok[0m]: ZADD GT and NX are not compatible - ziplist
[[0;32;49mok[0m]: ZADD LT and NX are not compatible - ziplist
[[0;32;49mok[0m]: BLPOP when new key is moved into place
[[0;32;49mok[0m]: ZADD LT and GT are not compatible - ziplist
[[0;32;49mok[0m]: ZADD INCR LT/GT replies with nill if score not updated - ziplist
[[0;32;49mok[0m]: BLPOP when result key is created by SORT..STORE
[[0;32;49mok[0m]: BLPOP: with single empty list argument
[[0;32;49mok[0m]: BLPOP: with negative timeout
[[0;32;49mok[0m]: BLPOP: with non-integer timeout
[[0;32;49mok[0m]: ZADD INCR LT/GT with inf - ziplist
[[0;32;49mok[0m]: ZADD INCR works like ZINCRBY - ziplist
[[0;32;49mok[0m]: ZADD INCR works with a single score-elemenet pair - ziplist
[[0;32;49mok[0m]: ZADD CH option changes return value to all changed elements - ziplist
[[0;32;49mok[0m]: HRANDFIELD - ziplist
[[0;32;49mok[0m]: ZINCRBY calls leading to NaN result in error - ziplist
[[0;32;49mok[0m]: ZADD - Variadic version base case - $encoding
[[0;32;49mok[0m]: ZADD - Return value is the number of actually added items - $encoding
[[0;32;49mok[0m]: ZADD - Variadic version does not add nothing on single parsing err - $encoding
[[0;32;49mok[0m]: ZADD - Variadic version will raise error on missing arg - $encoding
[[0;32;49mok[0m]: ZINCRBY does not work variadic even if shares ZADD implementation - $encoding
[[0;32;49mok[0m]: ZCARD basics - ziplist
[[0;32;49mok[0m]: ZREM removes key after last element is removed - ziplist
[[0;32;49mok[0m]: ZREM variadic version - ziplist
[[0;32;49mok[0m]: ZREM variadic version -- remove elements after key deletion - ziplist
[[0;32;49mok[0m]: ZRANGE basics - ziplist
[[0;32;49mok[0m]: ZREVRANGE basics - ziplist
[[0;32;49mok[0m]: HRANDFIELD - hashtable
[[0;32;49mok[0m]: HRANDFIELD with RESP3
[[0;32;49mok[0m]: HRANDFIELD count of 0 is handled correctly
[[0;32;49mok[0m]: HRANDFIELD with <count> against non existing key
[[0;32;49mok[0m]: ZRANK/ZREVRANK basics - ziplist
[[0;32;49mok[0m]: ZRANK - after deletion - ziplist
[[0;32;49mok[0m]: ZINCRBY - can create a new sorted set - ziplist
[[0;32;49mok[0m]: ZINCRBY - increment and decrement - ziplist
[[0;32;49mok[0m]: ZINCRBY return value - ziplist
[[0;32;49mok[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - ziplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with WITHSCORES - ziplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT - ziplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES - ziplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with non-value min or max - ziplist
[[0;32;49mok[0m]: SADD overflows the maximum allowed integers in an intset
[[0;32;49mok[0m]: Variadic SADD
[[0;32;49mok[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - ziplist
[[0;32;49mok[0m]: ZLEXCOUNT advanced - ziplist
[[0;32;49mok[0m]: ZRANGEBYSLEX with LIMIT - ziplist
[[0;32;49mok[0m]: ZRANGEBYLEX with invalid lex range specifiers - ziplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE basics - ziplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE with non-value min or max - ziplist
[[0;32;49mok[0m]: ZREMRANGEBYRANK basics - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE against non-existing key doesn't set destination - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF against non-existing key - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with empty set - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with empty set - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE basics - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with integer members - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with weights - ziplist
[[0;32;49mok[0m]: ZUNION with weights - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with a regular set and weights - ziplist
[3/64 [0;33;49mdone[0m]: unit/keyspace (1 seconds)
[1;37;49mTesting unit/expire[0m
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZINTERSTORE basics - ziplist
[[0;32;49mok[0m]: ZINTER basics - ziplist
[[0;32;49mok[0m]: ZINTER RESP3 - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with weights - ziplist
[[0;32;49mok[0m]: ZINTER with weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with a regular set and weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with +inf/-inf scores - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with NaN weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with +inf/-inf scores - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with NaN weights - ziplist
[[0;32;49mok[0m]: ZDIFFSTORE basics - ziplist
[[0;32;49mok[0m]: ZDIFF basics - ziplist
[[0;32;49mok[0m]: ZDIFFSTORE with a regular set - ziplist
[[0;32;49mok[0m]: ZDIFF subtracting set from itself - ziplist
[[0;32;49mok[0m]: ZDIFF algorithm 1 - ziplist
[[0;32;49mok[0m]: ZDIFF algorithm 2 - ziplist
[[0;32;49mok[0m]: XADD with MAXLEN option
[[0;32;49mok[0m]: AUTH fails when a wrong password is given
[[0;32;49mok[0m]: Arbitrary command gives an error when AUTH is required
[[0;32;49mok[0m]: AUTH succeeds when the right password is given
[[0;32;49mok[0m]: Once AUTH succeeded we can actually send commands to the server
[[0;32;49mok[0m]: MIGRATE is caching connections
[[0;32;49mok[0m]: errorstats: failed call authentication error
[[0;32;49mok[0m]: errorstats: failed call within MULTI/EXEC
[[0;32;49mok[0m]: errorstats: failed call within LUA
[[0;32;49mok[0m]: errorstats: failed call NOSCRIPT error
[[0;32;49mok[0m]: errorstats: failed call NOGROUP error
[[0;32;49mok[0m]: errorstats: rejected call unknown command
[[0;32;49mok[0m]: HRANDFIELD with <count> - hashtable
[[0;32;49mok[0m]: errorstats: rejected call within MULTI/EXEC
[[0;32;49mok[0m]: errorstats: rejected call due to wrong arity
[[0;32;49mok[0m]: errorstats: rejected call by OOM error
[[0;32;49mok[0m]: errorstats: rejected call by authorization error
[[0;32;49mok[0m]: XADD with MAXLEN option and the '=' argument
[[0;32;49mok[0m]: Set encoding after DEBUG RELOAD
[[0;32;49mok[0m]: SREM basics - regular set
[[0;32;49mok[0m]: SREM basics - intset
[[0;32;49mok[0m]: SREM with multiple arguments
[[0;32;49mok[0m]: SREM variadic version with more args needed to destroy the key
[[0;32;49mok[0m]: EXPIRE - set timeouts multiple times
[[0;32;49mok[0m]: EXPIRE - It should be still possible to read 'x'
[[0;32;49mok[0m]: Regression for a crash with blocking ops and pipelining
[[0;32;49mok[0m]: XGROUP CREATE: creation and duplicate group name detection
[[0;32;49mok[0m]: XGROUP CREATE: automatic stream creation fails without MKSTREAM
[[0;32;49mok[0m]: XGROUP CREATE: automatic stream creation works with MKSTREAM
[[0;32;49mok[0m]: XREADGROUP will return only new elements
[[0;32;49mok[0m]: XREADGROUP can read the history of the elements we own
[[0;32;49mok[0m]: XPENDING is able to return pending items
[[0;32;49mok[0m]: XPENDING can return single consumer items
[[0;32;49mok[0m]: XPENDING only group
[[0;32;49mok[0m]: Generated sets must be encoded as hashtable
[[0;32;49mok[0m]: SINTER with two sets - hashtable
[[0;32;49mok[0m]: SINTERSTORE with two sets - hashtable
[[0;32;49mok[0m]: Old Ziplist: SORT BY key
[[0;32;49mok[0m]: Old Ziplist: SORT BY key with limit
[[0;32;49mok[0m]: Old Ziplist: SORT BY hash field
[[0;32;49mok[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - hashtable
[[0;32;49mok[0m]: SUNION with two sets - hashtable
[[0;32;49mok[0m]: SUNIONSTORE with two sets - hashtable
[[0;32;49mok[0m]: SINTER against three sets - hashtable
[[0;32;49mok[0m]: SINTERSTORE with three sets - hashtable
[[0;32;49mok[0m]: XPENDING with IDLE
[[0;32;49mok[0m]: XPENDING with exclusive range intervals works as expected
[[0;32;49mok[0m]: SUNION with non existing keys - hashtable
[[0;32;49mok[0m]: XACK is able to remove items from the consumer/group PEL
[[0;32;49mok[0m]: SDIFF with two sets - hashtable
[[0;32;49mok[0m]: XACK can't remove the same item multiple times
[[0;32;49mok[0m]: XACK is able to accept multiple arguments
[[0;32;49mok[0m]: SDIFF with three sets - hashtable
[[0;32;49mok[0m]: SDIFFSTORE with three sets - hashtable
[[0;32;49mok[0m]: XACK should fail if got at least one invalid ID
[[0;32;49mok[0m]: PEL NACK reassignment after XGROUP SETID event
[[0;32;49mok[0m]: HRANDFIELD with <count> - ziplist
[[0;32;49mok[0m]: XREADGROUP will not report data on empty history. Bug #5577
[[0;32;49mok[0m]: XREADGROUP history reporting of deleted entries. Bug #5570
[[0;32;49mok[0m]: XADD with MAXLEN option and the '~' argument
[[0;32;49mok[0m]: XADD with NOMKSTREAM option
[[0;32;49mok[0m]: Generated sets must be encoded as intset
[[0;32;49mok[0m]: SINTER with two sets - intset
[[0;32;49mok[0m]: Blocking XREADGROUP will not reply with an empty array
[[0;32;49mok[0m]: SINTERSTORE with two sets - intset
[[0;32;49mok[0m]: XGROUP DESTROY should unblock XREADGROUP with -NOGROUP
[[0;32;49mok[0m]: RENAME can unblock XREADGROUP with data
[[0;32;49mok[0m]: RENAME can unblock XREADGROUP with -NOGROUP
[[0;32;49mok[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - intset
[[0;32;49mok[0m]: SUNION with two sets - intset
[[0;32;49mok[0m]: SUNIONSTORE with two sets - intset
[[0;32;49mok[0m]: SINTER against three sets - intset
[[0;32;49mok[0m]: SINTERSTORE with three sets - intset
[[0;32;49mok[0m]: SUNION with non existing keys - intset
[[0;32;49mok[0m]: SDIFF with two sets - intset
[[0;32;49mok[0m]: SDIFF with three sets - intset
[[0;32;49mok[0m]: SDIFFSTORE with three sets - intset
[[0;32;49mok[0m]: SDIFF with first set empty
[[0;32;49mok[0m]: SDIFF with same set two times
[4/64 [0;33;49mdone[0m]: unit/protocol (1 seconds)
[1;37;49mTesting unit/other[0m
[[0;32;49mok[0m]: AUTH fails when binary password is wrong
[[0;32;49mok[0m]: AUTH succeeds when binary password is correct
[[0;32;49mok[0m]: HSET/HLEN - Big hash creation
[[0;32;49mok[0m]: Is the big hash encoded with an hash table?
[[0;32;49mok[0m]: HGET against the small hash
[[0;32;49mok[0m]: Unsafe command names are sanitized in INFO output
[[0;32;49mok[0m]: XADD with MINID option
[[0;32;49mok[0m]: XTRIM with MINID option
[[0;32;49mok[0m]: HGET against the big hash
[[0;32;49mok[0m]: HGET against non existing key
[[0;32;49mok[0m]: HSET in update and insert mode
[[0;32;49mok[0m]: HSETNX target key missing - small hash
[[0;32;49mok[0m]: HSETNX target key exists - small hash
[[0;32;49mok[0m]: HSETNX target key missing - big hash
[[0;32;49mok[0m]: HSETNX target key exists - big hash
[[0;32;49mok[0m]: HMSET wrong number of args
[[0;32;49mok[0m]: HMSET - small hash
[[0;32;49mok[0m]: HMSET - big hash
[[0;32;49mok[0m]: HMGET against non existing key and fields
[[0;32;49mok[0m]: HMGET against wrong type
[[0;32;49mok[0m]: HMGET - small hash
[[0;32;49mok[0m]: Old Linked list: SORT BY key
[[0;32;49mok[0m]: Old Linked list: SORT BY key with limit
[[0;32;49mok[0m]: HMGET - big hash
[[0;32;49mok[0m]: HKEYS - small hash
[[0;32;49mok[0m]: Old Linked list: SORT BY hash field
[[0;32;49mok[0m]: HKEYS - big hash
[[0;32;49mok[0m]: HVALS - small hash
[[0;32;49mok[0m]: SAVE - make sure there are all the types as values
[[0;32;49mok[0m]: HVALS - big hash
[[0;32;49mok[0m]: HGETALL - small hash
[[0;32;49mok[0m]: HGETALL - big hash
[[0;32;49mok[0m]: HDEL and return value
[[0;32;49mok[0m]: HDEL - more than a single value
[[0;32;49mok[0m]: HDEL - hash becomes empty before deleting all specified fields
[[0;32;49mok[0m]: HEXISTS
[[0;32;49mok[0m]: Is a ziplist encoded Hash promoted on big payload?
[[0;32;49mok[0m]: HINCRBY against non existing database key
[[0;32;49mok[0m]: HINCRBY against non existing hash key
[[0;32;49mok[0m]: HINCRBY against hash key created by hincrby itself
[[0;32;49mok[0m]: HINCRBY against hash key originally set with HSET
[[0;32;49mok[0m]: HINCRBY over 32bit value
[[0;32;49mok[0m]: HINCRBY over 32bit value with over 32bit increment
[[0;32;49mok[0m]: HINCRBY fails against hash value with spaces (left)
[[0;32;49mok[0m]: HINCRBY fails against hash value with spaces (right)
[[0;32;49mok[0m]: HINCRBY can detect overflows
[[0;32;49mok[0m]: HINCRBYFLOAT against non existing database key
[[0;32;49mok[0m]: HINCRBYFLOAT against non existing hash key
[[0;32;49mok[0m]: HINCRBYFLOAT against hash key created by hincrby itself
[[0;32;49mok[0m]: HINCRBYFLOAT against hash key originally set with HSET
[[0;32;49mok[0m]: HINCRBYFLOAT over 32bit value
[[0;32;49mok[0m]: HINCRBYFLOAT over 32bit value with over 32bit increment
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value with spaces (left)
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value with spaces (right)
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle
[[0;32;49mok[0m]: HSTRLEN against the small hash
[5/64 [0;33;49mdone[0m]: unit/info (1 seconds)
[1;37;49mTesting unit/multi[0m
[[0;32;49mok[0m]: HSTRLEN against the big hash
[[0;32;49mok[0m]: HSTRLEN against non existing field
[[0;32;49mok[0m]: HSTRLEN corner cases
[[0;32;49mok[0m]: Hash ziplist regression test for large keys
[[0;32;49mok[0m]: Hash fuzzing #1 - 10 fields
[[0;32;49mok[0m]: Hash fuzzing #2 - 10 fields
[[0;32;49mok[0m]: MUTLI / EXEC basics
[[0;32;49mok[0m]: DISCARD
[[0;32;49mok[0m]: Nested MULTI are not allowed
[[0;32;49mok[0m]: MULTI where commands alter argc/argv
[[0;32;49mok[0m]: WATCH inside MULTI is not allowed
[[0;32;49mok[0m]: EXEC fails if there are errors while queueing commands #1
[[0;32;49mok[0m]: EXEC fails if there are errors while queueing commands #2
[[0;32;49mok[0m]: If EXEC aborts, the client MULTI state is cleared
[[0;32;49mok[0m]: EXEC works on WATCHed key not modified
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified (1 key of 1 watched)
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified (1 key of 5 watched)
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified by SORT with STORE even if the result is empty
[[0;32;49mok[0m]: After successful EXEC key is no longer watched
[[0;32;49mok[0m]: After failed EXEC key is no longer watched
[[0;32;49mok[0m]: It is possible to UNWATCH
[[0;32;49mok[0m]: UNWATCH when there is nothing watched works as expected
[[0;32;49mok[0m]: FLUSHALL is able to touch the watched keys
[[0;32;49mok[0m]: FLUSHALL does not touch non affected keys
[[0;32;49mok[0m]: FLUSHDB is able to touch the watched keys
[[0;32;49mok[0m]: FLUSHDB does not touch non affected keys
[[0;32;49mok[0m]: SWAPDB is able to touch the watched keys that exist
[[0;32;49mok[0m]: SWAPDB is able to touch the watched keys that do not exist
[[0;32;49mok[0m]: WATCH is able to remember the DB a key belongs to
[[0;32;49mok[0m]: WATCH will consider touched keys target of EXPIRE
[[0;32;49mok[0m]: XCLAIM can claim PEL items from another consumer
[[0;32;49mok[0m]: Stress tester for #3343-alike bugs
[[0;32;49mok[0m]: FUZZ stresser with data model binary
[[0;32;49mok[0m]: BLPOP: with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLPOP: second argument is not a list
[[0;32;49mok[0m]: XCLAIM without JUSTID increments delivery count
[[0;32;49mok[0m]: MASTERAUTH test with binary password
[[0;32;49mok[0m]: ziplist implementation: value encoding and backlink
[[0;32;49mok[0m]: XCLAIM same consumer
[[0;32;49mok[0m]: FUZZ stresser with data model alpha
[6/64 [0;33;49mdone[0m]: unit/auth (2 seconds)
[1;37;49mTesting unit/quit[0m
[[0;32;49mok[0m]: QUIT returns OK
[[0;32;49mok[0m]: Pipelined commands after QUIT must not be executed
[[0;32;49mok[0m]: Pipelined commands after QUIT that exceed read buffer size
[[0;32;49mok[0m]: SCAN regression test for issue #4906
[[0;32;49mok[0m]: WATCH will consider touched expired keys
[[0;32;49mok[0m]: DISCARD should clear the WATCH dirty flag on the client
[[0;32;49mok[0m]: DISCARD should UNWATCH all the keys
[[0;32;49mok[0m]: Hash fuzzing #1 - 512 fields
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (single write command)
[7/64 [0;33;49mdone[0m]: unit/quit (1 seconds)
[1;37;49mTesting unit/aofrw[0m
[8/64 [0;33;49mdone[0m]: unit/scan (3 seconds)
[1;37;49mTesting unit/acl[0m
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (empty transaction)
[[0;32;49mok[0m]: XADD mass insertion and XLEN
[[0;32;49mok[0m]: XADD with ID 0-0
[[0;32;49mok[0m]: XRANGE COUNT works as expected
[[0;32;49mok[0m]: XREVRANGE COUNT works as expected
[[0;32;49mok[0m]: BLPOP: timeout
[[0;32;49mok[0m]: BLPOP: arguments are empty
[[0;32;49mok[0m]: BRPOP: with single empty list argument
[[0;32;49mok[0m]: BRPOP: with negative timeout
[[0;32;49mok[0m]: BRPOP: with non-integer timeout
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (read-only commands)
[[0;32;49mok[0m]: FUZZ stresser with data model compr
[[0;32;49mok[0m]: Connections start with the default user
[[0;32;49mok[0m]: It is possible to create new users
[[0;32;49mok[0m]: New users start disabled
[[0;32;49mok[0m]: Enabling the user allows the login
[[0;32;49mok[0m]: Only the set of correct passwords work
[[0;32;49mok[0m]: It is possible to remove passwords from the set of valid ones
[[0;32;49mok[0m]: Test password hashes can be added
[[0;32;49mok[0m]: Test password hashes validate input
[[0;32;49mok[0m]: ACL GETUSER returns the password hash instead of the actual password
[[0;32;49mok[0m]: XAUTOCLAIM can claim PEL items from another consumer
[[0;32;49mok[0m]: Test hashed passwords removal
[[0;32;49mok[0m]: By default users are not able to access any command
[[0;32;49mok[0m]: By default users are not able to access any key
[[0;32;49mok[0m]: It's possible to allow the access of a subset of keys
[[0;32;49mok[0m]: By default users are able to publish to any channel
[[0;32;49mok[0m]: By default users are able to subscribe to any channel
[[0;32;49mok[0m]: By default users are able to subscribe to any pattern
[[0;32;49mok[0m]: It's possible to allow publishing to a subset of channels
[[0;32;49mok[0m]: Validate subset of channels is prefixed with resetchannels flag
[[0;32;49mok[0m]: In transaction queue publish/subscribe/psubscribe to unauthorized channel will fail
[[0;32;49mok[0m]: It's possible to allow subscribing to a subset of channels
[[0;32;49mok[0m]: It's possible to allow subscribing to a subset of channel patterns
[[0;32;49mok[0m]: Subscribers are killed when revoked of channel permission
[[0;32;49mok[0m]: Subscribers are killed when revoked of pattern permission
[[0;32;49mok[0m]: Subscribers are pardoned if literal permissions are retained and/or gaining allchannels
[[0;32;49mok[0m]: Users can be configured to authenticate with any password
[[0;32;49mok[0m]: ACLs can exclude single commands
[[0;32;49mok[0m]: ACLs can include or exclude whole classes of commands
[[0;32;49mok[0m]: ACLs can include single subcommands
[[0;32;49mok[0m]: ACLs set can include subcommands, if already full command exists
[[0;32;49mok[0m]: ACL GETUSER is able to translate back command permissions
[[0;32;49mok[0m]: ACL GETUSER provides reasonable results
[[0;32;49mok[0m]: ACL #5998 regression: memory leaks adding / removing subcommands
[[0;32;49mok[0m]: ACL LOG shows failed command executions at toplevel
[[0;32;49mok[0m]: ACL LOG is able to test similar events
[[0;32;49mok[0m]: ACL LOG is able to log keys access violations and key name
[[0;32;49mok[0m]: ACL LOG is able to log channel access violations and channel name
[[0;32;49mok[0m]: ACL LOG RESET is able to flush the entries in the log
[[0;32;49mok[0m]: ACL LOG can distinguish the transaction context (1)
[[0;32;49mok[0m]: ACL LOG can distinguish the transaction context (2)
[[0;32;49mok[0m]: ACL can log errors in the context of Lua scripting
[[0;32;49mok[0m]: ACL LOG can accept a numerical argument to show less entries
[[0;32;49mok[0m]: ACL LOG can log failed auth attempts
[[0;32;49mok[0m]: ACL LOG entries are limited to a maximum amount
[[0;32;49mok[0m]: When default user is off, new connections are not authenticated
[[0;32;49mok[0m]: When default user has no command permission, hello command still works for other users
[[0;32;49mok[0m]: ACL HELP should not have unexpected options
[[0;32;49mok[0m]: Delete a user that the client doesn't use
[[0;32;49mok[0m]: Delete a user that the client is using
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (write command, no effect)
[[0;32;49mok[0m]: DISCARD should not fail during OOM
[[0;32;49mok[0m]: EXPIRE - After 2.1 seconds the key should no longer be here
[[0;32;49mok[0m]: EXPIRE - write on expire should work
[[0;32;49mok[0m]: EXPIREAT - Check for EXPIRE alike behavior
[[0;32;49mok[0m]: SETEX - Set + Expire combo operation. Check for TTL
[[0;32;49mok[0m]: SETEX - Check value
[[0;32;49mok[0m]: SETEX - Overwrite old key
[[0;32;49mok[0m]: XAUTOCLAIM as an iterator
[[0;32;49mok[0m]: XAUTOCLAIM COUNT must be > 0
[[0;32;49mok[0m]: XINFO FULL output
[[0;32;49mok[0m]: XGROUP CREATECONSUMER: create consumer if does not exist
[[0;32;49mok[0m]: XGROUP CREATECONSUMER: group must exist
[[0;32;49mok[0m]: XRANGE can be used to iterate the whole stream
[[0;32;49mok[0m]: default: load from include file, can access any channels
[[0;32;49mok[0m]: default: with config acl-pubsub-default allchannels after reset, can access any channels
[[0;32;49mok[0m]: XREADGROUP with NOACK creates consumer
[[0;32;49mok[0m]: default: with config acl-pubsub-default resetchannels after reset, can not access any channels
[[0;32;49mok[0m]: Alice: can execute all command
[[0;32;49mok[0m]: Bob: just execute @set and acl command
[[0;32;49mok[0m]: ACL load and save
[[0;32;49mok[0m]: ACL load and save with restricted channels
[[0;32;49mok[0m]: MULTI and script timeout
[[0;32;49mok[0m]: Hash fuzzing #2 - 512 fields
[[0;32;49mok[0m]: SETNX against expired volatile key
[[0;32;49mok[0m]: GETEX EX option
[[0;32;49mok[0m]: GETEX PX option
[[0;32;49mok[0m]: GETEX EXAT option
[[0;32;49mok[0m]: GETEX PXAT option
[[0;32;49mok[0m]: GETEX PERSIST option
[[0;32;49mok[0m]: GETEX no option
[[0;32;49mok[0m]: GETEX syntax errors
[[0;32;49mok[0m]: GETEX no arguments
[[0;32;49mok[0m]: GETDEL command
[[0;32;49mok[0m]: Default user has access to all channels irrespective of flag
[[0;32;49mok[0m]: Update acl-pubsub-default, existing users shouldn't get affected
[[0;32;49mok[0m]: Single channel is valid
[[0;32;49mok[0m]: Single channel is not valid with allchannels
[[0;32;49mok[0m]: GETDEL propagate as DEL command to replica
[[0;32;49mok[0m]: GETEX without argument does not propagate to replica
[[0;32;49mok[0m]: Only default user has access to all channels irrespective of flag
[[0;32;49mok[0m]: Old Big Linked list: SORT BY key
[[0;32;49mok[0m]: MGET
[[0;32;49mok[0m]: MGET against non existing key
[[0;32;49mok[0m]: MGET against non-string key
[[0;32;49mok[0m]: GETSET (set new value)
[[0;32;49mok[0m]: GETSET (replace old value)
[[0;32;49mok[0m]: MSET base case
[[0;32;49mok[0m]: MSET wrong number of args
[[0;32;49mok[0m]: MSETNX with already existent key
[[0;32;49mok[0m]: MSETNX with not existing keys
[[0;32;49mok[0m]: STRLEN against non-existing key
[[0;32;49mok[0m]: STRLEN against integer-encoded value
[[0;32;49mok[0m]: STRLEN against plain string
[[0;32;49mok[0m]: SETBIT against non-existing key
[[0;32;49mok[0m]: SETBIT against string-encoded key
[[0;32;49mok[0m]: SETBIT against integer-encoded key
[[0;32;49mok[0m]: SETBIT against key with wrong type
[[0;32;49mok[0m]: SETBIT with out of range bit offset
[[0;32;49mok[0m]: SETBIT with non-bit argument
[[0;32;49mok[0m]: Old Big Linked list: SORT BY key with limit
[[0;32;49mok[0m]: EXEC and script timeout
[[0;32;49mok[0m]: default: load from config file, can access any channels
[[0;32;49mok[0m]: BRPOP: with zero timeout should block indefinitely
[[0;32;49mok[0m]: BRPOP: second argument is not a list
[[0;32;49mok[0m]: BGSAVE
[[0;32;49mok[0m]: SELECT an out of range DB
[9/64 [0;33;49mdone[0m]: unit/acl (1 seconds)
[1;37;49mTesting unit/latency-monitor[0m
[[0;32;49mok[0m]: Old Big Linked list: SORT BY hash field
[[0;32;49mok[0m]: Intset: SORT BY key
[[0;32;49mok[0m]: Intset: SORT BY key with limit
[[0;32;49mok[0m]: Intset: SORT BY hash field
[[0;32;49mok[0m]: SETEX - Wait for the key to expire
[[0;32;49mok[0m]: SETEX - Wrong time parameter
[[0;32;49mok[0m]: PERSIST can undo an EXPIRE
[[0;32;49mok[0m]: PERSIST returns 0 against non existing or non volatile keys
[[0;32;49mok[0m]: MULTI-EXEC body and script timeout
[[0;32;49mok[0m]: Consumer without PEL is present in AOF after AOFRW
[[0;32;49mok[0m]: SETBIT fuzzing
[[0;32;49mok[0m]: GETBIT against non-existing key
[[0;32;49mok[0m]: GETBIT against string-encoded key
[[0;32;49mok[0m]: GETBIT against integer-encoded key
[[0;32;49mok[0m]: SETRANGE against non-existing key
[[0;32;49mok[0m]: SETRANGE against string-encoded key
[[0;32;49mok[0m]: SETRANGE against integer-encoded key
[[0;32;49mok[0m]: SETRANGE against key with wrong type
[[0;32;49mok[0m]: SETRANGE with out of range offset
[[0;32;49mok[0m]: GETRANGE against non-existing key
[[0;32;49mok[0m]: GETRANGE against string value
[[0;32;49mok[0m]: GETRANGE against integer-encoded value
[[0;32;49mok[0m]: XREVRANGE returns the reverse of XRANGE
[[0;32;49mok[0m]: XRANGE exclusive ranges
[[0;32;49mok[0m]: XREAD with non empty stream
[[0;32;49mok[0m]: Non blocking XREAD with empty streams
[[0;32;49mok[0m]: XREAD with non empty second stream
[[0;32;49mok[0m]: Blocking XREAD waiting new data
[[0;32;49mok[0m]: Blocking XREAD waiting old data
[[0;32;49mok[0m]: Blocking XREAD will not reply with an empty array
[[0;32;49mok[0m]: XREAD: XADD + DEL should not awake client
[[0;32;49mok[0m]: XREAD: XADD + DEL + LPUSH should not awake client
[[0;32;49mok[0m]: XREAD with same stream name multiple times should work
[[0;32;49mok[0m]: XREAD + multiple XADD inside transaction
[[0;32;49mok[0m]: XDEL basic test
[[0;32;49mok[0m]: Consumer group last ID propagation to slave (NOACK=0)
[[0;32;49mok[0m]: Hash table: SORT BY key
[[0;32;49mok[0m]: Hash table: SORT BY key with limit
[[0;32;49mok[0m]: Hash table: SORT BY hash field
[[0;32;49mok[0m]: just EXEC and script timeout
[[0;32;49mok[0m]: exec with write commands and state change
[[0;32;49mok[0m]: Consumer group last ID propagation to slave (NOACK=1)
[[0;32;49mok[0m]: exec with read commands and stale replica state change
[[0;32;49mok[0m]: EXEC with only read commands should not be rejected when OOM
[[0;32;49mok[0m]: EXEC with at least one use-memory command should fail
[[0;32;49mok[0m]: Blocking commands ignores the timeout
[[0;32;49mok[0m]: ZDIFF fuzzing - ziplist
[[0;32;49mok[0m]: Basic ZPOP with a single key - ziplist
[[0;32;49mok[0m]: ZPOP with count - ziplist
[[0;32;49mok[0m]: BZPOP with a single existing sorted set - ziplist
[[0;32;49mok[0m]: MULTI propagation of PUBLISH
[[0;32;49mok[0m]: BZPOP with multiple existing sorted sets - ziplist
[[0;32;49mok[0m]: BZPOP second sorted set has members - ziplist
[[0;32;49mok[0m]: Check encoding - skiplist
[[0;32;49mok[0m]: ZSET basic ZADD and score update - skiplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZADD - skiplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZINCRBY - skiplist
[[0;32;49mok[0m]: ZADD with options syntax error with incomplete pair - skiplist
[[0;32;49mok[0m]: ZADD XX option without key - skiplist
[[0;32;49mok[0m]: ZADD XX existing key - skiplist
[[0;32;49mok[0m]: ZADD XX returns the number of elements actually added - skiplist
[[0;32;49mok[0m]: ZADD XX updates existing elements score - skiplist
[[0;32;49mok[0m]: ZADD GT updates existing elements when new scores are greater - skiplist
[[0;32;49mok[0m]: ZADD LT updates existing elements when new scores are lower - skiplist
[[0;32;49mok[0m]: ZADD GT XX updates existing elements when new scores are greater and skips new elements - skiplist
[[0;32;49mok[0m]: ZADD LT XX updates existing elements when new scores are lower and skips new elements - skiplist
[[0;32;49mok[0m]: ZADD XX and NX are not compatible - skiplist
[[0;32;49mok[0m]: ZADD NX with non existing key - skiplist
[[0;32;49mok[0m]: ZADD NX only add new elements without updating old ones - skiplist
[[0;32;49mok[0m]: ZADD GT and NX are not compatible - skiplist
[[0;32;49mok[0m]: ZADD LT and NX are not compatible - skiplist
[[0;32;49mok[0m]: ZADD LT and GT are not compatible - skiplist
[[0;32;49mok[0m]: ZADD INCR LT/GT replies with nill if score not updated - skiplist
[[0;32;49mok[0m]: ZADD INCR LT/GT with inf - skiplist
[[0;32;49mok[0m]: BRPOP: timeout
[[0;32;49mok[0m]: ZADD INCR works like ZINCRBY - skiplist
[[0;32;49mok[0m]: ZADD INCR works with a single score-elemenet pair - skiplist
[[0;32;49mok[0m]: BRPOP: arguments are empty
[[0;32;49mok[0m]: ZADD CH option changes return value to all changed elements - skiplist
[[0;32;49mok[0m]: BLPOP inside a transaction
[[0;32;49mok[0m]: ZINCRBY calls leading to NaN result in error - skiplist
[[0;32;49mok[0m]: LPUSHX, RPUSHX - generic
[[0;32;49mok[0m]: ZADD - Variadic version base case - $encoding
[[0;32;49mok[0m]: ZADD - Return value is the number of actually added items - $encoding
[[0;32;49mok[0m]: LPUSHX, RPUSHX - linkedlist
[[0;32;49mok[0m]: ZADD - Variadic version does not add nothing on single parsing err - $encoding
[[0;32;49mok[0m]: ZADD - Variadic version will raise error on missing arg - $encoding
[[0;32;49mok[0m]: ZINCRBY does not work variadic even if shares ZADD implementation - $encoding
[[0;32;49mok[0m]: ZCARD basics - skiplist
[[0;32;49mok[0m]: LINSERT - linkedlist
[[0;32;49mok[0m]: ZREM removes key after last element is removed - skiplist
[[0;32;49mok[0m]: LPUSHX, RPUSHX - ziplist
[[0;32;49mok[0m]: ZREM variadic version - skiplist
[[0;32;49mok[0m]: LTRIM stress testing - linkedlist
[[0;32;49mok[0m]: ZREM variadic version -- remove elements after key deletion - skiplist
[[0;32;49mok[0m]: LINSERT - ziplist
[[0;32;49mok[0m]: LINSERT raise error on bad syntax
[[0;32;49mok[0m]: ZRANGE basics - skiplist
[[0;32;49mok[0m]: ZREVRANGE basics - skiplist
[[0;32;49mok[0m]: ZRANK/ZREVRANK basics - skiplist
[[0;32;49mok[0m]: ZRANK - after deletion - skiplist
[[0;32;49mok[0m]: ZINCRBY - can create a new sorted set - skiplist
[[0;32;49mok[0m]: ZINCRBY - increment and decrement - skiplist
[[0;32;49mok[0m]: ZINCRBY return value - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with WITHSCORES - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with non-value min or max - skiplist
[[0;32;49mok[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - skiplist
[[0;32;49mok[0m]: ZLEXCOUNT advanced - skiplist
[[0;32;49mok[0m]: ZRANGEBYSLEX with LIMIT - skiplist
[[0;32;49mok[0m]: ZRANGEBYLEX with invalid lex range specifiers - skiplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE basics - skiplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE with non-value min or max - skiplist
[[0;32;49mok[0m]: ZREMRANGEBYRANK basics - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE against non-existing key doesn't set destination - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF against non-existing key - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with empty set - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with empty set - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE basics - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with integer members - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with weights - skiplist
[[0;32;49mok[0m]: ZUNION with weights - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with a regular set and weights - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: ZINTERSTORE basics - skiplist
[[0;32;49mok[0m]: ZINTER basics - skiplist
[[0;32;49mok[0m]: ZINTER RESP3 - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with weights - skiplist
[[0;32;49mok[0m]: ZINTER with weights - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with a regular set and weights - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: LINDEX consistency test - quicklist
[[0;32;49mok[0m]: ZUNIONSTORE with +inf/-inf scores - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with NaN weights - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with +inf/-inf scores - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with NaN weights - skiplist
[[0;32;49mok[0m]: ZDIFFSTORE basics - skiplist
[[0;32;49mok[0m]: ZDIFF basics - skiplist
[[0;32;49mok[0m]: ZDIFFSTORE with a regular set - skiplist
[[0;32;49mok[0m]: ZDIFF subtracting set from itself - skiplist
[[0;32;49mok[0m]: ZDIFF algorithm 1 - skiplist
[[0;32;49mok[0m]: ZDIFF algorithm 2 - skiplist
[[0;32;49mok[0m]: MULTI propagation of SCRIPT LOAD
[[0;32;49mok[0m]: LINDEX random access - quicklist
[[0;32;49mok[0m]: Check consistency of different data types after a reload
[[0;32;49mok[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist
[[0;32;49mok[0m]: MULTI propagation of SCRIPT LOAD
[[0;32;49mok[0m]: Stress test the hash ziplist -> hashtable encoding conversion
[[0;32;49mok[0m]: Hash ziplist of various encodings
[[0;32;49mok[0m]: Hash ziplist of various encodings - sanitize dump
[[0;32;49mok[0m]: MULTI propagation of XREADGROUP
[10/64 [0;33;49mdone[0m]: unit/type/hash (5 seconds)
[1;37;49mTesting integration/block-repl[0m
[[0;32;49mok[0m]: LINDEX consistency test - quicklist
[[0;32;49mok[0m]: LINDEX random access - quicklist
[11/64 [0;33;49mdone[0m]: unit/multi (4 seconds)
[1;37;49mTesting integration/replication[0m
[[0;32;49mok[0m]: Slave enters handshake
[[0;32;49mok[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist
[[0;32;49mok[0m]: LLEN against non-list value error
[[0;32;49mok[0m]: LLEN against non existing key
[[0;32;49mok[0m]: LINDEX against non-list value error
[[0;32;49mok[0m]: LINDEX against non existing key
[[0;32;49mok[0m]: LPUSH against non-list value error
[[0;32;49mok[0m]: RPUSH against non-list value error
[[0;32;49mok[0m]: GETRANGE fuzzing
[[0;32;49mok[0m]: Extended SET can detect syntax errors
[[0;32;49mok[0m]: Extended SET NX option
[[0;32;49mok[0m]: Extended SET XX option
[[0;32;49mok[0m]: Extended SET GET option
[[0;32;49mok[0m]: Extended SET GET option with no previous value
[[0;32;49mok[0m]: Extended SET GET with NX option should result in syntax err
[[0;32;49mok[0m]: Extended SET GET with incorrect type should result in wrong type error
[[0;32;49mok[0m]: Extended SET EX option
[[0;32;49mok[0m]: Extended SET PX option
[[0;32;49mok[0m]: Extended SET EXAT option
[[0;32;49mok[0m]: Extended SET PXAT option
[[0;32;49mok[0m]: Extended SET using multiple options at once
[[0;32;49mok[0m]: GETRANGE with huge ranges, Github issue #1844
[[0;32;49mok[0m]: STRALGO LCS string output with STRINGS option
[[0;32;49mok[0m]: STRALGO LCS len
[[0;32;49mok[0m]: LCS with KEYS option
[[0;32;49mok[0m]: LCS indexes
[[0;32;49mok[0m]: LCS indexes with match len
[[0;32;49mok[0m]: LCS indexes with match len and minimum match len
[[0;32;49mok[0m]: RPOPLPUSH base case - linkedlist
[[0;32;49mok[0m]: LMOVE left left base case - linkedlist
[[0;32;49mok[0m]: LMOVE left right base case - linkedlist
[[0;32;49mok[0m]: LMOVE right left base case - linkedlist
[[0;32;49mok[0m]: LMOVE right right base case - linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE left left with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE left right with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE right left with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE right right with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE left left with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE left right with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right left with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: SDIFF fuzzing
[[0;32;49mok[0m]: SINTER against non-set should throw error
[[0;32;49mok[0m]: SUNION against non-set should throw error
[[0;32;49mok[0m]: SINTER should handle non existing key as empty
[[0;32;49mok[0m]: LMOVE right right with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: SINTER with same integer elements but different encoding
[[0;32;49mok[0m]: SINTERSTORE against non existing keys should delete dstkey
[[0;32;49mok[0m]: RPOPLPUSH with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: SUNIONSTORE against non existing keys should delete dstkey
[[0;32;49mok[0m]: LMOVE left left with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: SPOP basics - hashtable
[[0;32;49mok[0m]: LMOVE left right with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: SPOP with <count>=1 - hashtable
[[0;32;49mok[0m]: LMOVE right left with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE right right with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: RPOPLPUSH base case - ziplist
[[0;32;49mok[0m]: LMOVE left left base case - ziplist
[[0;32;49mok[0m]: LMOVE left right base case - ziplist
[[0;32;49mok[0m]: LMOVE right left base case - ziplist
[[0;32;49mok[0m]: LMOVE right right base case - ziplist
[[0;32;49mok[0m]: RPOPLPUSH with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE left left with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE left right with the same list as src and dst - ziplist
[[0;32;49mok[0m]: SRANDMEMBER - hashtable
[[0;32;49mok[0m]: LMOVE right left with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE right right with the same list as src and dst - ziplist
[[0;32;49mok[0m]: SPOP basics - intset
[[0;32;49mok[0m]: RPOPLPUSH with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: SPOP with <count>=1 - intset
[[0;32;49mok[0m]: LMOVE left left with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE left right with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right left with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right right with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE left left with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE left right with ziplist source and existing target ziplist
[[0;32;49mok[0m]: SRANDMEMBER - intset
[[0;32;49mok[0m]: LMOVE right left with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE right right with ziplist source and existing target ziplist
[[0;32;49mok[0m]: RPOPLPUSH against non existing key
[[0;32;49mok[0m]: RPOPLPUSH against non list src key
[[0;32;49mok[0m]: RPOPLPUSH against non list dst key
[[0;32;49mok[0m]: RPOPLPUSH against non existing src key
[[0;32;49mok[0m]: SPOP with <count>
[[0;32;49mok[0m]: Basic LPOP/RPOP - linkedlist
[[0;32;49mok[0m]: Basic LPOP/RPOP - ziplist
[[0;32;49mok[0m]: LPOP/RPOP against non list value
[[0;32;49mok[0m]: SPOP with <count>
[[0;32;49mok[0m]: SPOP using integers, testing Knuth's and Floyd's algorithm
[[0;32;49mok[0m]: SPOP using integers with Knuth's algorithm
[[0;32;49mok[0m]: SPOP new implementation: code path #1
[[0;32;49mok[0m]: SPOP new implementation: code path #2
[[0;32;49mok[0m]: SPOP new implementation: code path #3
[[0;32;49mok[0m]: SRANDMEMBER with <count> against non existing key
[[0;32;49mok[0m]: SRANDMEMBER with <count> - hashtable
[[0;32;49mok[0m]: Mass RPOP/LPOP - quicklist
[[0;32;49mok[0m]: SRANDMEMBER with <count> - intset
[12/64 [0;33;49mdone[0m]: unit/type/string (6 seconds)
[1;37;49mTesting integration/replication-2[0m
[[0;32;49mok[0m]: Mass RPOP/LPOP - quicklist
[[0;32;49mok[0m]: LRANGE basics - linkedlist
[[0;32;49mok[0m]: LRANGE inverted indexes - linkedlist
[[0;32;49mok[0m]: LRANGE out of range indexes including the full list - linkedlist
[[0;32;49mok[0m]: LRANGE out of range negative end index - linkedlist
[[0;32;49mok[0m]: LRANGE basics - ziplist
[[0;32;49mok[0m]: LRANGE inverted indexes - ziplist
[[0;32;49mok[0m]: LRANGE out of range indexes including the full list - ziplist
[[0;32;49mok[0m]: LRANGE out of range negative end index - ziplist
[[0;32;49mok[0m]: LRANGE against non existing key
[[0;32;49mok[0m]: LRANGE with start > end yields an empty array for backward compatibility
[[0;32;49mok[0m]: LTRIM basics - linkedlist
[[0;32;49mok[0m]: LTRIM out of range negative end index - linkedlist
[[0;32;49mok[0m]: LTRIM basics - ziplist
[[0;32;49mok[0m]: LTRIM out of range negative end index - ziplist
[[0;32;49mok[0m]: LSET - linkedlist
[[0;32;49mok[0m]: LSET out of range index - linkedlist
[[0;32;49mok[0m]: LSET - ziplist
[[0;32;49mok[0m]: LSET out of range index - ziplist
[[0;32;49mok[0m]: LSET against non existing key
[[0;32;49mok[0m]: LSET against non list value
[[0;32;49mok[0m]: LREM remove all the occurrences - linkedlist
[[0;32;49mok[0m]: LREM remove the first occurrence - linkedlist
[[0;32;49mok[0m]: LREM remove non existing element - linkedlist
[[0;32;49mok[0m]: LREM starting from tail with negative count - linkedlist
[[0;32;49mok[0m]: LREM starting from tail with negative count (2) - linkedlist
[[0;32;49mok[0m]: LREM deleting objects that may be int encoded - linkedlist
[[0;32;49mok[0m]: LREM remove all the occurrences - ziplist
[[0;32;49mok[0m]: LREM remove the first occurrence - ziplist
[[0;32;49mok[0m]: LREM remove non existing element - ziplist
[[0;32;49mok[0m]: LREM starting from tail with negative count - ziplist
[[0;32;49mok[0m]: LREM starting from tail with negative count (2) - ziplist
[[0;32;49mok[0m]: LREM deleting objects that may be int encoded - ziplist
[[0;32;49mok[0m]: SRANDMEMBER histogram distribution - hashtable
[[0;32;49mok[0m]: Empty stream with no lastid can be rewrite into AOF correctly
[[0;32;49mok[0m]: SRANDMEMBER histogram distribution - intset
[[0;32;49mok[0m]: SMOVE basics - from regular set to intset
[[0;32;49mok[0m]: SMOVE basics - from intset to regular set
[[0;32;49mok[0m]: SMOVE non existing key
[[0;32;49mok[0m]: SMOVE non existing src set
[[0;32;49mok[0m]: SMOVE from regular set to non existing destination set
[[0;32;49mok[0m]: SMOVE from intset to non existing destination set
[[0;32;49mok[0m]: SMOVE wrong src key type
[[0;32;49mok[0m]: SMOVE wrong dst key type
[[0;32;49mok[0m]: SMOVE with identical source and destination
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: If min-slaves-to-write is honored, write is accepted
[[0;32;49mok[0m]: No write if min-slaves-to-write is < attached slaves
[[0;32;49mok[0m]: Same dataset digest if saving/reloading as AOF?
[[0;32;49mok[0m]: If min-slaves-to-write is honored, write is accepted (again)
[[0;32;49mok[0m]: XDEL fuzz test
[13/64 [0;33;49mdone[0m]: unit/type/stream-cgroups (6 seconds)
[1;37;49mTesting integration/replication-3[0m
[[0;32;49mok[0m]: EXPIRE precision is now the millisecond
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds
[[0;32;49mok[0m]: client unblock tests
[[0;32;49mok[0m]: List ziplist of various encodings
[[0;32;49mok[0m]: List ziplist of various encodings - sanitize dump
[[0;32;49mok[0m]: PEXPIRE/PSETEX/PEXPIREAT can set sub-second expires
[[0;32;49mok[0m]: TTL returns time to live in seconds
[[0;32;49mok[0m]: PTTL returns time to live in milliseconds
[[0;32;49mok[0m]: TTL / PTTL return -1 if key has no expire
[[0;32;49mok[0m]: TTL / PTTL return -2 if key does not exit
[14/64 [0;33;49mdone[0m]: unit/type/list (7 seconds)
[1;37;49mTesting integration/replication-4[0m
[[0;32;49mok[0m]: EXPIRES after a reload (snapshot + append only file rewrite)
[[0;32;49mok[0m]: Test latency events logging
[[0;32;49mok[0m]: LATENCY HISTORY output is ok
[[0;32;49mok[0m]: LATENCY LATEST output is ok
[[0;32;49mok[0m]: LATENCY HISTORY / RESET with wrong event name is fine
[[0;32;49mok[0m]: LATENCY DOCTOR produces some output
[[0;32;49mok[0m]: LATENCY RESET is able to reset events
[[0;32;49mok[0m]: Big Hash table: SORT BY key
[[0;32;49mok[0m]: Big Hash table: SORT BY key with limit
[[0;32;49mok[0m]: Redis should actively expire keys incrementally
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: Big Hash table: SORT BY hash field
[[0;32;49mok[0m]: SORT GET #
[[0;32;49mok[0m]: SORT GET <const>
[[0;32;49mok[0m]: SORT GET (key and hash) with sanity check
[[0;32;49mok[0m]: SORT BY key STORE
[[0;32;49mok[0m]: SORT BY hash field STORE
[[0;32;49mok[0m]: SORT extracts STORE correctly
[[0;32;49mok[0m]: SORT extracts multiple STORE correctly
[[0;32;49mok[0m]: SORT DESC
[[0;32;49mok[0m]: SORT ALPHA against integer encoded strings
[[0;32;49mok[0m]: SORT sorted set
[[0;32;49mok[0m]: SORT sorted set BY nosort should retain ordering
[[0;32;49mok[0m]: SORT sorted set BY nosort + LIMIT
[[0;32;49mok[0m]: SORT sorted set BY nosort works as expected from scripts
[[0;32;49mok[0m]: SORT sorted set: +inf and -inf handling
[[0;32;49mok[0m]: SORT regression for issue #19, sorting floats
[[0;32;49mok[0m]: SORT with STORE returns zero if result is empty (github issue 224)
[[0;32;49mok[0m]: SORT with STORE does not create empty lists (github issue 224)
[[0;32;49mok[0m]: SORT with STORE removes key if result is empty (github issue 227)
[[0;32;49mok[0m]: SORT with BY <constant> and STORE should still order output
[[0;32;49mok[0m]: SORT will complain with numerical sorting and bad doubles (1)
[[0;32;49mok[0m]: SORT will complain with numerical sorting and bad doubles (2)
[[0;32;49mok[0m]: SORT BY sub-sorts lexicographically if score is the same
[[0;32;49mok[0m]: SORT GET with pattern ending with just -> does not get hash field
[[0;32;49mok[0m]: SORT by nosort retains native order for lists
[[0;32;49mok[0m]: SORT by nosort plus store retains native order for lists
[[0;32;49mok[0m]: SORT by nosort with limit returns based on original list order
[[0;32;49mok[0m]: SORT speed, 100 element list BY key, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list BY hash field, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list directly, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list BY <const>, 100 times
[[0;32;49mok[0m]: intsets implementation stress testing
[15/64 [0;33;49mdone[0m]: unit/sort (9 seconds)
[1;37;49mTesting integration/replication-psync[0m
[16/64 [0;33;49mdone[0m]: unit/type/set (9 seconds)
[1;37;49mTesting integration/aof[0m
[[0;32;49mok[0m]: Redis should lazy expire keys
[[0;32;49mok[0m]: Unfinished MULTI: Server should start if load-truncated is yes
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: No write if min-slaves-max-lag is > of the slave lag
[[0;32;49mok[0m]: min-slaves-to-write is ignored by slaves
[[0;32;49mok[0m]: Short read: Server should start if load-truncated is yes
[[0;32;49mok[0m]: Truncated AOF loaded: we expect foo to be equal to 5
[[0;32;49mok[0m]: Append a new command after loading an incomplete AOF
[[0;32;49mok[0m]: Short read + command: Server should start
[[0;32;49mok[0m]: Truncated AOF loaded: we expect foo to be equal to 6 now
[[0;32;49mok[0m]: Bad format: Server should have logged an error
[[0;32;49mok[0m]: Unfinished MULTI: Server should have logged an error
[[0;32;49mok[0m]: Short read: Server should have logged an error
[[0;32;49mok[0m]: Short read: Utility should confirm the AOF is not valid
[[0;32;49mok[0m]: Short read: Utility should show the abnormal line num in AOF
[[0;32;49mok[0m]: Short read: Utility should be able to fix the AOF
[[0;32;49mok[0m]: EXPIRE should not resurrect keys (issue #1026)
[[0;32;49mok[0m]: 5 keys in, 5 keys out
[[0;32;49mok[0m]: EXPIRE with empty string as TTL should report an error
[[0;32;49mok[0m]: SET with EX with big integer should report an error
[[0;32;49mok[0m]: SET with EX with smallest integer should report an error
[[0;32;49mok[0m]: GETEX with big integer should report an error
[[0;32;49mok[0m]: GETEX with smallest integer should report an error
[[0;32;49mok[0m]: EXPIRE with big integer overflows when converted to milliseconds
[[0;32;49mok[0m]: PEXPIRE with big integer overflow when basetime is added
[[0;32;49mok[0m]: EXPIRE with big negative integer
[[0;32;49mok[0m]: PEXPIREAT with big integer works
[[0;32;49mok[0m]: PEXPIREAT with big negative integer works
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Fixed AOF: Server should have been started
[[0;32;49mok[0m]: Fixed AOF: Keyspace should contain values that were parseable
[[0;32;49mok[0m]: Test replication partial resync: no reconnection, just sync (diskless: no, disabled, reconnect: 0)
[[0;32;49mok[0m]: EXPIRES after AOF reload (without rewrite)
[[0;32;49mok[0m]: AOF+SPOP: Server should have been started
[[0;32;49mok[0m]: AOF+SPOP: Set should have 1 member
[[0;32;49mok[0m]: AOF+SPOP: Server should have been started
[[0;32;49mok[0m]: AOF+SPOP: Set should have 1 member
[[0;32;49mok[0m]: AOF+EXPIRE: Server should have been started
[[0;32;49mok[0m]: AOF+EXPIRE: List should be empty
[[0;32;49mok[0m]: ZDIFF fuzzing - skiplist
[[0;32;49mok[0m]: Basic ZPOP with a single key - skiplist
[[0;32;49mok[0m]: ZPOP with count - skiplist
[[0;32;49mok[0m]: BZPOP with a single existing sorted set - skiplist
[[0;32;49mok[0m]: BZPOP with multiple existing sorted sets - skiplist
[[0;32;49mok[0m]: BZPOP second sorted set has members - skiplist
[[0;32;49mok[0m]: ZINTERSTORE regression with two sets, intset+hashtable
[[0;32;49mok[0m]: ZUNIONSTORE regression, should not create NaN in scores
[[0;32;49mok[0m]: ZINTERSTORE #516 regression, mixed sets and ziplist zsets
[[0;32;49mok[0m]: ZUNIONSTORE result is sorted
[[0;32;49mok[0m]: ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE error if using WITHSCORES 
[[0;32;49mok[0m]: ZMSCORE retrieve
[[0;32;49mok[0m]: ZMSCORE retrieve from empty set
[[0;32;49mok[0m]: ZMSCORE retrieve with missing member
[[0;32;49mok[0m]: ZMSCORE retrieve single member
[[0;32;49mok[0m]: ZMSCORE retrieve requires one or more members
[[0;32;49mok[0m]: ZSET commands don't accept the empty strings as valid score
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: ZSCORE - ziplist
[[0;32;49mok[0m]: Redis should not try to convert DEL into EXPIREAT for EXPIRE -1
[[0;32;49mok[0m]: ZMSCORE - ziplist
[[0;32;49mok[0m]: ZSCORE after a DEBUG RELOAD - ziplist
[[0;32;49mok[0m]: ZSET sorting stresser - ziplist
[[0;32;49mok[0m]: PIPELINING stresser (also a regression for the old epoll bug)
[[0;32;49mok[0m]: APPEND basics
[[0;32;49mok[0m]: APPEND basics, integer encoded values
[[0;32;49mok[0m]: APPEND fuzzing
[[0;32;49mok[0m]: FLUSHDB
[[0;32;49mok[0m]: Perform a final SAVE to leave a clean DB on disk
[[0;32;49mok[0m]: RESET clears client state
[[0;32;49mok[0m]: RESET clears MONITOR state
[[0;32;49mok[0m]: RESET clears and discards MULTI state
[[0;32;49mok[0m]: RESET clears Pub/Sub state
[[0;32;49mok[0m]: RESET clears authenticated state
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: EXPIRE and SET/GETEX EX/PX/EXAT/PXAT option, TTL should not be reset after loadaof
[[0;32;49mok[0m]: EXPIRE relative and absolute propagation to replicas
[[0;32;49mok[0m]: SET command will remove expire
[[0;32;49mok[0m]: SET - use KEEPTTL option, TTL should not be removed
[[0;32;49mok[0m]: Don't rehash if redis has child proecess
[[0;32;49mok[0m]: Process title set as expected
[17/64 [0;33;49mdone[0m]: unit/other (12 seconds)
[1;37;49mTesting integration/rdb[0m
[[0;32;49mok[0m]: LATENCY of expire events are correctly collected
[[0;32;49mok[0m]: LATENCY HELP should not have unexpected options
[[0;32;49mok[0m]: RDB encoding loading test
[18/64 [0;33;49mdone[0m]: unit/latency-monitor (9 seconds)
[1;37;49mTesting integration/corrupt-dump[0m
[[0;32;49mok[0m]: corrupt payload: #7445 - with sanitize
[[0;32;49mok[0m]: Server started empty with non-existing RDB file
[[0;32;49mok[0m]: corrupt payload: #7445 - without sanitize - 1
[[0;32;49mok[0m]: corrupt payload: #7445 - without sanitize - 2
[[0;32;49mok[0m]: Server started empty with empty RDB file
[[0;32;49mok[0m]: corrupt payload: hash with valid zip list header, invalid entry len
[[0;32;49mok[0m]: Test replication with parallel clients writing in different DBs
[[0;32;49mok[0m]: corrupt payload: invalid zlbytes header
[[0;32;49mok[0m]: LTRIM stress testing - ziplist
[[0;32;49mok[0m]: corrupt payload: valid zipped hash header, dup records
[[0;32;49mok[0m]: Test RDB stream encoding
[[0;32;49mok[0m]: Test RDB stream encoding - sanitize dump
[19/64 [0;33;49mdone[0m]: unit/type/list-2 (14 seconds)
[1;37;49mTesting integration/corrupt-dump-fuzzer[0m
[[0;32;49mok[0m]: corrupt payload: quicklist big ziplist prev len
[[0;32;49mok[0m]: SET - use KEEPTTL option, TTL should not be removed after loadaof
[[0;32;49mok[0m]: GETEX use of PERSIST option should remove TTL
[[0;32;49mok[0m]: Server should not start if RDB is corrupted
[[0;32;49mok[0m]: corrupt payload: quicklist small ziplist prev len
[[0;32;49mok[0m]: Test FLUSHALL aborts bgsave
[[0;32;49mok[0m]: corrupt payload: quicklist ziplist wrong count
[[0;32;49mok[0m]: bgsave resets the change counter
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: With min-slaves-to-write (1,3): master should be writable
[[0;32;49mok[0m]: With min-slaves-to-write (2,3): master should not be writable
[[0;32;49mok[0m]: corrupt payload: #3080 - quicklist
[[0;32;49mok[0m]: ZRANGEBYSCORE fuzzy test, 100 ranges in 128 element sorted set - ziplist
[[0;32;49mok[0m]: corrupt payload: #3080 - ziplist
[[0;32;49mok[0m]: ZRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist
[[0;32;49mok[0m]: corrupt payload: load corrupted rdb with no CRC - #3505
[[0;32;49mok[0m]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist
[[0;32;49mok[0m]: corrupt payload: listpack invalid size header
[[0;32;49mok[0m]: ZSETs skiplist implementation backlink consistency test - ziplist
[[0;32;49mok[0m]: corrupt payload: listpack too long entry len
[[0;32;49mok[0m]: corrupt payload: listpack very long entry len
[[0;32;49mok[0m]: ziplist implementation: encoding stress testing
[[0;32;49mok[0m]: corrupt payload: listpack too long entry prev len
[20/64 [0;33;49mdone[0m]: unit/type/list-3 (16 seconds)
[1;37;49mTesting integration/convert-zipmap-hash-on-load[0m
[[0;32;49mok[0m]: Slave is able to detect timeout during handshake
[[0;32;49mok[0m]: MASTER and SLAVE consistency with expire
[[0;32;49mok[0m]: RDB load zipmap hash: converts to ziplist
[[0;32;49mok[0m]: corrupt payload: hash ziplist with duplicate records
[[0;32;49mok[0m]: GETEX use of PERSIST option should remove TTL after loadaof
[[0;32;49mok[0m]: MIGRATE cached connections are released after some time
[[0;32;49mok[0m]: ZSETs ZRANK augmented skip list stress testing - ziplist
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN with same key multiple times should work
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BZPOPMIN
[[0;32;49mok[0m]: BZPOPMIN with variadic ZADD
[[0;32;49mok[0m]: GETEX propagate as to replica as PERSIST, DEL, or nothing
[[0;32;49mok[0m]: corrupt payload: hash ziplist uneven record count
[[0;32;49mok[0m]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-entries is exceeded
[21/64 [0;33;49mdone[0m]: unit/expire (15 seconds)
[1;37;49mTesting integration/logging[0m
[22/64 [0;33;49mdone[0m]: integration/logging (0 seconds)
[1;37;49mTesting integration/psync2[0m
[[0;32;49mok[0m]: MIGRATE is able to migrate a key between two instances
[[0;32;49mok[0m]: Set instance A as slave of B
[[0;32;49mok[0m]: XRANGE fuzzing
[[0;32;49mok[0m]: XREVRANGE regression test for issue #5006
[[0;32;49mok[0m]: XREAD streamID edge (no-blocking)
[[0;32;49mok[0m]: XREAD streamID edge (blocking)
[[0;32;49mok[0m]: XADD streamID edge
[[0;32;49mok[0m]: corrupt payload: hash dupliacte records
[[0;32;49mok[0m]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-value is exceeded
[[0;32;49mok[0m]: XTRIM with MAXLEN option basic test
[[0;32;49mok[0m]: XADD with LIMIT consecutive calls
[[0;32;49mok[0m]: XTRIM with ~ is limited
[[0;32;49mok[0m]: XTRIM without ~ is not limited
[[0;32;49mok[0m]: XTRIM without ~ and with LIMIT
[[0;32;49mok[0m]: MIGRATE is able to copy a key between two instances
[23/64 [0;33;49mdone[0m]: integration/convert-zipmap-hash-on-load (0 seconds)
[1;37;49mTesting integration/psync2-reg[0m
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - NPD in streamIteratorGetID
[[0;32;49mok[0m]: AOF fsync always barrier issue
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - listpack NPD on invalid stream
[[0;32;49mok[0m]: XADD with MAXLEN > xlen can propagate correctly
[[0;32;49mok[0m]: MASTER and SLAVE dataset should be identical after complex ops
[[0;32;49mok[0m]: MIGRATE will not overwrite existing keys, unless REPLACE is used
[[0;32;49mok[0m]: BZPOPMIN with zero timeout should block indefinitely
[24/64 [0;33;49mdone[0m]: integration/replication-2 (11 seconds)
[1;37;49mTesting integration/psync2-pingoff[0m
[[0;32;49mok[0m]: ZSCORE - skiplist
[[0;32;49mok[0m]: XADD with MINID > lastid can propagate correctly
[[0;32;49mok[0m]: ZMSCORE - skiplist
[[0;32;49mok[0m]: With min-slaves-to-write: master not writable with lagged slave
[[0;32;49mok[0m]: ZSCORE after a DEBUG RELOAD - skiplist
[[0;32;49mok[0m]: ZSET sorting stresser - skiplist
[[0;32;49mok[0m]: MIGRATE propagates TTL correctly
[[0;32;49mok[0m]: INCRBYFLOAT replication, should not remove expire
[[0;32;49mok[0m]: GETSET replication
[[0;32;49mok[0m]: BRPOPLPUSH replication, when blocking against empty list
[[0;32;49mok[0m]: XADD with ~ MAXLEN can propagate correctly
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: XADD with ~ MAXLEN and LIMIT can propagate correctly
[[0;32;49mok[0m]: PSYNC2 #3899 regression: setup
[[0;32;49mok[0m]: XADD with ~ MINID can propagate correctly
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 1 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #3 as master
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #3
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #2
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #3
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #2
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - NPD in quicklistIndex
[[0;32;49mok[0m]: GETEX should not append to AOF
[[0;32;49mok[0m]: XADD with ~ MINID and LIMIT can propagate correctly
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - invalid read in ziplistFind
[[0;32;49mok[0m]: BRPOPLPUSH replication, list exists
[[0;32;49mok[0m]: BLMOVE (left, left) replication, when blocking against empty list
[25/64 [0;33;49mdone[0m]: integration/aof (9 seconds)
[1;37;49mTesting integration/failover[0m
[[0;32;49mok[0m]: PSYNC2 pingoff: setup
[[0;32;49mok[0m]: PSYNC2 pingoff: write and wait replication
[[0;32;49mok[0m]: XTRIM with ~ MAXLEN can propagate correctly
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - invalid ziplist encoding
[[0;32;49mok[0m]: Test replication partial resync: ok psync (diskless: no, disabled, reconnect: 1)
[[0;32;49mok[0m]: XADD can CREATE an empty stream
[[0;32;49mok[0m]: XSETID can set a specific ID
[[0;32;49mok[0m]: XSETID cannot SETID with smaller ID
[[0;32;49mok[0m]: XSETID cannot SETID on non-existent key
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - hash crash
[[0;32;49mok[0m]: ZRANGEBYSCORE fuzzy test, 100 ranges in 100 element sorted set - skiplist
[[0;32;49mok[0m]: failover command fails without connected replica
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - uneven entry count in hash
[[0;32;49mok[0m]: ZRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist
[[0;32;49mok[0m]: AOF rewrite during write load: RDB preamble=yes
[[0;32;49mok[0m]: setup replication for following tests
[[0;32;49mok[0m]: failover command fails with invalid host
[[0;32;49mok[0m]: failover command fails with invalid port
[[0;32;49mok[0m]: failover command fails with just force and timeout
[[0;32;49mok[0m]: failover command fails when sent to a replica
[[0;32;49mok[0m]: failover command fails with force without timeout
[[0;32;49mok[0m]: BLMOVE (left, left) replication, list exists
[[0;32;49mok[0m]: BLMOVE (left, right) replication, when blocking against empty list
[[0;32;49mok[0m]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - invalid read in lzf_decompress
[[0;32;49mok[0m]: ZSETs skiplist implementation backlink consistency test - skiplist
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - leak in rdbloading due to dup entry in set
[[0;32;49mok[0m]: failover command to specific replica works
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - empty intset div by zero
[[0;32;49mok[0m]: Empty stream can be rewrite into AOF correctly
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - valgrind ziplist - crash report prints freed memory
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - valgrind ziplist prevlen reaches outside the ziplist
[[0;32;49mok[0m]: BLMOVE (left, right) replication, list exists
[[0;32;49mok[0m]: BLMOVE (right, left) replication, when blocking against empty list
[[0;32;49mok[0m]: failover command to any replica works
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - valgrind - bad rdbLoadDoubleValue
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - valgrind ziplist prev too big
[[0;32;49mok[0m]: ZSETs ZRANK augmented skip list stress testing - skiplist
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN, ZADD + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: BZPOPMIN with same key multiple times should work
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BZPOPMIN
[[0;32;49mok[0m]: BZPOPMIN with variadic ZADD
[[0;32;49mok[0m]: Stream can be rewrite into AOF correctly after XDEL lastid
[[0;32;49mok[0m]: failover to a replica with force works
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - lzf decompression fails, avoid valgrind invalid read
[[0;32;49mok[0m]: XGROUP HELP should not have unexpected options
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - stream bad lp_count
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - stream bad lp_count - unsanitized
[26/64 [0;33;49mdone[0m]: unit/type/stream (21 seconds)
[1;37;49mTesting integration/redis-cli[0m
[[0;32;49mok[0m]: BLMOVE (right, left) replication, list exists
[[0;32;49mok[0m]: BLMOVE (right, right) replication, when blocking against empty list
[[0;32;49mok[0m]: Interactive CLI: INFO response should be printed raw
[[0;32;49mok[0m]: Interactive CLI: Status reply
[[0;32;49mok[0m]: Interactive CLI: Integer reply
[[0;32;49mok[0m]: Interactive CLI: Bulk reply
[[0;32;49mok[0m]: Interactive CLI: Multi-bulk reply
[[0;32;49mok[0m]: failover with timeout aborts if replica never catches up
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - stream integrity check issue
[[0;32;49mok[0m]: failovers can be aborted
[[0;32;49mok[0m]: Interactive CLI: Parsing quotes
[[0;32;49mok[0m]: Non-interactive TTY CLI: Status reply
[[0;32;49mok[0m]: Non-interactive TTY CLI: Integer reply
[[0;32;49mok[0m]: Non-interactive TTY CLI: Bulk reply
[[0;32;49mok[0m]: Non-interactive TTY CLI: Multi-bulk reply
[[0;32;49mok[0m]: BZPOPMIN with zero timeout should block indefinitely
[[0;32;49mok[0m]: Non-interactive TTY CLI: Read last argument from pipe
[[0;32;49mok[0m]: Non-interactive TTY CLI: Read last argument from file
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Status reply
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Integer reply
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Bulk reply
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Multi-bulk reply
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Quoted input arguments
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - infinite loop
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: No accidental unquoting of input arguments
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Invalid quoted input arguments
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Read last argument from pipe
[[0;32;49mok[0m]: Non-interactive non-TTY CLI: Read last argument from file
[[0;32;49mok[0m]: Slave is able to evict keys created in writable slaves
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - hash convert asserts on RESTORE with shallow sanitization
[[0;32;49mok[0m]: BLMOVE (right, right) replication, list exists
[[0;32;49mok[0m]: corrupt payload: OOM in rdbGenericLoadStringObject
[[0;32;49mok[0m]: BLPOP followed by role change, issue #2473
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - OOM in dictExpand
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - invalid tail offset after removal
[[0;32;49mok[0m]: failover aborts if target rejects sync request
[[0;32;49mok[0m]: Second server should have role master at first
[[0;32;49mok[0m]: SLAVEOF should start with link status "down"
[[0;32;49mok[0m]: The role should immediately be changed to "replica"
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - negative reply length
[[0;32;49mok[0m]: PSYNC2 pingoff: pause replica and promote it
[[0;32;49mok[0m]: Sync should have transferred keys from master
[[0;32;49mok[0m]: The link status should be up
[[0;32;49mok[0m]: SET on the master should immediately propagate
[[0;32;49mok[0m]: FLUSHALL should replicate
[[0;32;49mok[0m]: ROLE in master reports master with a slave
[[0;32;49mok[0m]: ROLE in slave reports slave in connected state
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - valgrind negative malloc
[27/64 [0;33;49mdone[0m]: integration/failover (6 seconds)
[1;37;49mTesting integration/redis-benchmark[0m
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - valgrind invalid read
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - HRANDFIELD on bad ziplist
[[0;32;49mok[0m]: corrupt payload: fuzzer findings - stream with no records
[28/64 [0;33;49mdone[0m]: integration/corrupt-dump (11 seconds)
[1;37;49mTesting unit/pubsub[0m
[[0;32;49mok[0m]: Fuzzer corrupt restore payloads - sanitize_dump: no
[[0;32;49mok[0m]: benchmark: set,get
[[0;32;49mok[0m]: Pub/Sub PING
[[0;32;49mok[0m]: PUBLISH/SUBSCRIBE basics
[[0;32;49mok[0m]: PUBLISH/SUBSCRIBE with two clients
[[0;32;49mok[0m]: PUBLISH/SUBSCRIBE after UNSUBSCRIBE without arguments
[[0;32;49mok[0m]: SUBSCRIBE to one channel more than once
[[0;32;49mok[0m]: UNSUBSCRIBE from non-subscribed channels
[[0;32;49mok[0m]: PUBLISH/PSUBSCRIBE basics
[[0;32;49mok[0m]: PUBLISH/PSUBSCRIBE with two clients
[[0;32;49mok[0m]: PUBLISH/PSUBSCRIBE after PUNSUBSCRIBE without arguments
[[0;32;49mok[0m]: PUNSUBSCRIBE from non-subscribed channels
[[0;32;49mok[0m]: NUMSUB returns numbers, not strings (#1561)
[[0;32;49mok[0m]: Mix SUBSCRIBE and PSUBSCRIBE
[[0;32;49mok[0m]: PUNSUBSCRIBE and UNSUBSCRIBE should always reply
[[0;32;49mok[0m]: Keyspace notifications: we receive keyspace notifications
[[0;32;49mok[0m]: Keyspace notifications: we receive keyevent notifications
[[0;32;49mok[0m]: Keyspace notifications: we can receive both kind of events
[[0;32;49mok[0m]: Keyspace notifications: we are able to mask events
[[0;32;49mok[0m]: Keyspace notifications: general events test
[[0;32;49mok[0m]: Keyspace notifications: list events test
[[0;32;49mok[0m]: Keyspace notifications: set events test
[[0;32;49mok[0m]: Keyspace notifications: zset events test
[[0;32;49mok[0m]: Keyspace notifications: hash events test
[[0;32;49mok[0m]: Make the old master a replica of the new one and check conditions
[[0;32;49mok[0m]: Keyspace notifications: expired events (triggered expire)
[[0;32;49mok[0m]: ZSET skiplist order consistency when elements are moved
[[0;32;49mok[0m]: ZRANGESTORE basic
[[0;32;49mok[0m]: ZRANGESTORE RESP3
[[0;32;49mok[0m]: ZRANGESTORE range
[[0;32;49mok[0m]: ZRANGESTORE BYLEX
[[0;32;49mok[0m]: ZRANGESTORE BYSCORE
[[0;32;49mok[0m]: ZRANGESTORE BYSCORE LIMIT
[[0;32;49mok[0m]: ZRANGESTORE BYSCORE REV LIMIT
[[0;32;49mok[0m]: ZRANGE BYSCORE REV LIMIT
[[0;32;49mok[0m]: ZRANGESTORE - empty range
[[0;32;49mok[0m]: ZRANGESTORE BYLEX - empty range
[[0;32;49mok[0m]: ZRANGESTORE BYSCORE - empty range
[[0;32;49mok[0m]: ZRANGE BYLEX
[[0;32;49mok[0m]: ZRANGESTORE invalid syntax
[[0;32;49mok[0m]: ZRANGE invalid syntax
[[0;32;49mok[0m]: ZRANDMEMBER - ziplist
[[0;32;49mok[0m]: ZRANDMEMBER - skiplist
[[0;32;49mok[0m]: ZRANDMEMBER with RESP3
[[0;32;49mok[0m]: ZRANDMEMBER count of 0 is handled correctly
[[0;32;49mok[0m]: ZRANDMEMBER with <count> against non existing key
[[0;32;49mok[0m]: Keyspace notifications: expired events (background expire)
[[0;32;49mok[0m]: Keyspace notifications: evicted events
[[0;32;49mok[0m]: Keyspace notifications: test CONFIG GET/SET of event flags
[[0;32;49mok[0m]: benchmark: full test suite
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: ZRANDMEMBER with <count> - skiplist
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[29/64 [0;33;49mdone[0m]: unit/pubsub (1 seconds)
[1;37;49mTesting unit/slowlog[0m
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 32080)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: SLOWLOG - check that it starts with an empty log
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: benchmark: multi-thread set,get
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 2 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #1 as master
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #1
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #1
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #1
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #0
[[0;32;49mok[0m]: ZRANDMEMBER with <count> - ziplist
[[0;32;49mok[0m]: Dumping an RDB
[[0;32;49mok[0m]: SLOWLOG - only logs commands taking more time than specified
[[0;32;49mok[0m]: SLOWLOG - max entries is correctly handled
[[0;32;49mok[0m]: SLOWLOG - GET optional argument to limit output len works
[[0;32;49mok[0m]: SLOWLOG - RESET subcommand works
[30/64 [0;33;49mdone[0m]: unit/type/zset (25 seconds)
[1;37;49mTesting unit/scripting[0m
[[0;32;49mok[0m]: EVAL - Does Lua interpreter replies to our requests?
[[0;32;49mok[0m]: EVAL - Lua integer -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua string -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua true boolean -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua false boolean -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua status code reply -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua error reply -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Lua table -> Redis protocol type conversion
[[0;32;49mok[0m]: EVAL - Are the KEYS and ARGV arrays populated correctly?
[[0;32;49mok[0m]: EVAL - is Lua able to call Redis API?
[[0;32;49mok[0m]: EVALSHA - Can we call a SHA1 if already defined?
[[0;32;49mok[0m]: EVALSHA - Can we call a SHA1 in uppercase?
[[0;32;49mok[0m]: EVALSHA - Do we get an error on invalid SHA1?
[[0;32;49mok[0m]: EVALSHA - Do we get an error on non defined SHA1?
[[0;32;49mok[0m]: EVAL - Redis integer -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis bulk -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis multi bulk -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis status reply -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis error reply -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Redis nil bulk reply -> Lua type conversion
[[0;32;49mok[0m]: EVAL - Is the Lua client using the currently selected DB?
[[0;32;49mok[0m]: EVAL - SELECT inside Lua should not affect the caller
[[0;32;49mok[0m]: EVAL - Scripts can't run blpop command
[[0;32;49mok[0m]: EVAL - Scripts can't run brpop command
[[0;32;49mok[0m]: EVAL - Scripts can't run brpoplpush command
[[0;32;49mok[0m]: EVAL - Scripts can't run blmove command
[[0;32;49mok[0m]: EVAL - Scripts can't run bzpopmin command
[[0;32;49mok[0m]: EVAL - Scripts can't run bzpopmax command
[[0;32;49mok[0m]: EVAL - Scripts can't run XREAD and XREADGROUP with BLOCK option
[[0;32;49mok[0m]: EVAL - Scripts can't run certain commands
[[0;32;49mok[0m]: EVAL - No arguments to redis.call/pcall is considered an error
[[0;32;49mok[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[[0;32;49mok[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[[0;32;49mok[0m]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[[0;32;49mok[0m]: EVAL - JSON numeric decoding
[[0;32;49mok[0m]: EVAL - JSON string decoding
[[0;32;49mok[0m]: EVAL - cmsgpack can pack double?
[[0;32;49mok[0m]: EVAL - cmsgpack can pack negative int64?
[[0;32;49mok[0m]: EVAL - cmsgpack can pack and unpack circular references?
[[0;32;49mok[0m]: EVAL - Numerical sanity check from bitop
[[0;32;49mok[0m]: EVAL - Verify minimal bitop functionality
[[0;32;49mok[0m]: EVAL - Able to parse trailing comments
[[0;32;49mok[0m]: SCRIPTING FLUSH - is able to clear the scripts cache?
[[0;32;49mok[0m]: benchmark: pipelined full set,get
[[0;32;49mok[0m]: SCRIPTING FLUSH ASYNC
[[0;32;49mok[0m]: SCRIPT EXISTS - can detect already defined scripts?
[[0;32;49mok[0m]: SCRIPT LOAD - is able to register scripts in the scripting cache
[[0;32;49mok[0m]: In the context of Lua the output of random commands gets ordered
[[0;32;49mok[0m]: SORT is normally not alpha re-ordered for the scripting engine
[[0;32;49mok[0m]: SORT BY <constant> output gets ordered for scripting
[[0;32;49mok[0m]: SORT BY <constant> with GET gets ordered for scripting
[[0;32;49mok[0m]: redis.sha1hex() implementation
[[0;32;49mok[0m]: Globals protection reading an undeclared global variable
[[0;32;49mok[0m]: Globals protection setting an undeclared global*
[[0;32;49mok[0m]: Test an example script DECR_IF_GT
[[0;32;49mok[0m]: Scripting engine resets PRNG at every script execution
[[0;32;49mok[0m]: Scripting engine PRNG can be seeded correctly
[[0;32;49mok[0m]: benchmark: arbitrary command
[[0;32;49mok[0m]: benchmark: keyspace length
[[0;32;49mok[0m]: SLOWLOG - logged entry sanity check
[[0;32;49mok[0m]: SLOWLOG - Certain commands are omitted that contain sensitive information
[[0;32;49mok[0m]: SLOWLOG - Some commands can redact sensitive fields
[[0;32;49mok[0m]: SLOWLOG - Rewritten commands are logged as their original command
[[0;32;49mok[0m]: SLOWLOG - commands with too many arguments are trimmed
[[0;32;49mok[0m]: SLOWLOG - too long arguments are trimmed
[[0;32;49mok[0m]: Scan mode
[[0;32;49mok[0m]: SLOWLOG - EXEC is not logged, just executed commands
[[0;32;49mok[0m]: EVAL does not leak in the Lua stack
[31/64 [0;33;49mdone[0m]: integration/redis-benchmark (2 seconds)
[1;37;49mTesting unit/maxmemory[0m
[[0;32;49mok[0m]: Without maxmemory small integers are shared
[[0;32;49mok[0m]: With maxmemory and non-LRU policy integers are still shared
[[0;32;49mok[0m]: With maxmemory and LRU policy integers are not shared
[[0;32;49mok[0m]: SLOWLOG - can clean older entries
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: EVAL processes writes from AOF in read-only slaves
[[0;32;49mok[0m]: SLOWLOG - can be disabled
[32/64 [0;33;49mdone[0m]: unit/slowlog (2 seconds)
[1;37;49mTesting unit/introspection[0m
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: CLIENT LIST
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy allkeys-random)
[[0;32;49mok[0m]: CLIENT LIST with IDs
[[0;32;49mok[0m]: CLIENT INFO
[[0;32;49mok[0m]: MONITOR can log executed commands
[[0;32;49mok[0m]: MONITOR can log commands issued by the scripting engine
[[0;32;49mok[0m]: MONITOR supports redacting command arguments
[[0;32;49mok[0m]: MONITOR correctly handles multi-exec cases
[[0;32;49mok[0m]: CLIENT GETNAME should return NIL if name is not assigned
[[0;32;49mok[0m]: CLIENT LIST shows empty fields for unassigned names
[[0;32;49mok[0m]: CLIENT SETNAME does not accept spaces
[[0;32;49mok[0m]: CLIENT SETNAME can assign a name to this connection
[[0;32;49mok[0m]: CLIENT SETNAME can change the name of an existing connection
[[0;32;49mok[0m]: Connecting as a replica
[[0;32;49mok[0m]: After CLIENT SETNAME, connection can still be closed
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy allkeys-lru)
[[0;32;49mok[0m]: CONFIG save params special case handled properly
[[0;32;49mok[0m]: CONFIG sanity
[[0;32;49mok[0m]: Piping raw protocol
[[0;32;49mok[0m]: Test replication partial resync: no backlog (diskless: no, disabled, reconnect: 1)
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy allkeys-lfu)
[33/64 [0;33;49mdone[0m]: integration/redis-cli (7 seconds)
[1;37;49mTesting unit/introspection-2[0m
[[0;32;49mok[0m]: CONFIG REWRITE sanity
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: MIGRATE can correctly transfer large values
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-lru)
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: MIGRATE can correctly transfer hashes
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-lfu)
[[0;32;49mok[0m]: test various edge cases of repl topology changes with missing pings at the end
[[0;32;49mok[0m]: CONFIG REWRITE handles save properly
[[0;32;49mok[0m]: MIGRATE timeout actually works
[34/64 [0;33;49mdone[0m]: unit/introspection (3 seconds)
[1;37;49mTesting unit/limits[0m
[[0;32;49mok[0m]: MIGRATE can migrate multiple keys at once
[[0;32;49mok[0m]: MIGRATE with multiple keys must have empty key arg
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: MIGRATE with multiple keys migrate just existing ones
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-random)
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: Check if maxclients works refusing connections
[[0;32;49mok[0m]: MIGRATE with multiple keys: stress command rewriting
[35/64 [0;33;49mdone[0m]: unit/limits (1 seconds)
[1;37;49mTesting unit/obuf-limits[0m
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 51041)
[[0;32;49mok[0m]: Test replication with blocking lists and sorted sets operations
[[0;32;49mok[0m]: EVAL timeout from AOF
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: We can call scripts rewriting client->argv from Lua
[[0;32;49mok[0m]: Call Redis command with many args from Lua (issue #1764)
[[0;32;49mok[0m]: Number conversion precision test (issue #1118)
[[0;32;49mok[0m]: String containing number precision test (regression of issue #1118)
[[0;32;49mok[0m]: Verify negative arg count is error instead of crash (issue #1842)
[[0;32;49mok[0m]: Correct handling of reused argv (issue #1939)
[[0;32;49mok[0m]: Functions in the Redis namespace are able to report errors
[[0;32;49mok[0m]: Script with RESP3 map
[[0;32;49mok[0m]: MIGRATE with multiple keys: delete just ack keys
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 3 ---
[[0;32;49mok[0m]: TTL, TYPE and EXISTS do not alter the last access time of a key
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #0 as master
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #2
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: maxmemory - is the memory limit honoured? (policy volatile-ttl)
[36/64 [0;33;49mdone[0m]: integration/block-repl (27 seconds)
[1;37;49mTesting unit/bitops[0m
[[0;32;49mok[0m]: MIGRATE AUTH: correct and wrong password cases
[[0;32;49mok[0m]: Replication: commands with many arguments (issue #1221)
[37/64 [0;33;49mdone[0m]: unit/dump (32 seconds)
[1;37;49mTesting unit/bitfield[0m
[[0;32;49mok[0m]: BITCOUNT returns 0 against non existing key
[[0;32;49mok[0m]: BITCOUNT returns 0 with out of range indexes
[[0;32;49mok[0m]: BITCOUNT returns 0 with negative indexes where start > end
[[0;32;49mok[0m]: BITCOUNT against test vector #1
[[0;32;49mok[0m]: BITFIELD signed SET and GET basics
[[0;32;49mok[0m]: BITFIELD unsigned SET and GET basics
[[0;32;49mok[0m]: BITFIELD #<idx> form
[[0;32;49mok[0m]: BITFIELD basic INCRBY form
[[0;32;49mok[0m]: BITFIELD chaining of multiple commands
[[0;32;49mok[0m]: BITFIELD unsigned overflow wrap
[[0;32;49mok[0m]: BITFIELD unsigned overflow sat
[[0;32;49mok[0m]: BITFIELD signed overflow wrap
[[0;32;49mok[0m]: BITFIELD signed overflow sat
[[0;32;49mok[0m]: BITCOUNT against test vector #2
[[0;32;49mok[0m]: BITCOUNT against test vector #3
[[0;32;49mok[0m]: BITCOUNT against test vector #4
[[0;32;49mok[0m]: BITCOUNT against test vector #5
[[0;32;49mok[0m]: Timedout read-only scripts can be killed by SCRIPT KILL
[[0;32;49mok[0m]: Timedout read-only scripts can be killed by SCRIPT KILL even when use pcall
[[0;32;49mok[0m]: Timedout script does not cause a false dead client
[[0;32;49mok[0m]: Replication of SPOP command -- alsoPropagate() API
[[0;32;49mok[0m]: Timedout script link is still usable after Lua returns
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-random)
[[0;32;49mok[0m]: BITCOUNT fuzzing without start/end
[[0;32;49mok[0m]: Timedout scripts that modified data can't be killed by SCRIPT KILL
[[0;32;49mok[0m]: SHUTDOWN NOSAVE can kill a timedout script anyway
[[0;32;49mok[0m]: BITFIELD overflow detection fuzzing
[[0;32;49mok[0m]: BITCOUNT fuzzing with start/end
[[0;32;49mok[0m]: BITCOUNT with start, end
[[0;32;49mok[0m]: BITCOUNT syntax error #1
[[0;32;49mok[0m]: BITCOUNT regression test for github issue #582
[[0;32;49mok[0m]: BITCOUNT misaligned prefix
[[0;32;49mok[0m]: BITCOUNT misaligned prefix + full words + remainder
[[0;32;49mok[0m]: BITOP NOT (empty string)
[[0;32;49mok[0m]: BITOP NOT (known string)
[[0;32;49mok[0m]: BITOP where dest and target are the same key
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[[0;32;49mok[0m]: BITOP AND|OR|XOR don't change the string with single input key
[[0;32;49mok[0m]: BITOP missing key is considered a stream of zero
[[0;32;49mok[0m]: BITOP shorter keys are zero-padded to the key with max length
[38/64 [0;33;49mdone[0m]: integration/replication-4 (26 seconds)
[1;37;49mTesting unit/geo[0m
[[0;32;49mok[0m]: GEOADD create
[[0;32;49mok[0m]: GEOADD update
[[0;32;49mok[0m]: GEOADD update with CH option
[[0;32;49mok[0m]: GEOADD update with NX option
[[0;32;49mok[0m]: GEOADD update with XX option
[[0;32;49mok[0m]: GEOADD update with CH NX option
[[0;32;49mok[0m]: GEOADD update with CH XX option
[[0;32;49mok[0m]: GEOADD update with XX NX option will return syntax error
[[0;32;49mok[0m]: GEOADD update with invalid option
[[0;32;49mok[0m]: GEOADD invalid coordinates
[[0;32;49mok[0m]: Before the replica connects we issue two EVAL commands (scripts replication)
[[0;32;49mok[0m]: GEOADD multi add
[[0;32;49mok[0m]: Check geoset values
[[0;32;49mok[0m]: GEORADIUS simple (sorted)
[[0;32;49mok[0m]: GEOSEARCH simple (sorted)
[[0;32;49mok[0m]: GEOSEARCH FROMLONLAT and FROMMEMBER cannot exist at the same time
[[0;32;49mok[0m]: GEOSEARCH FROMLONLAT and FROMMEMBER one must exist
[[0;32;49mok[0m]: GEOSEARCH BYRADIUS and BYBOX cannot exist at the same time
[[0;32;49mok[0m]: GEOSEARCH BYRADIUS and BYBOX one must exist
[[0;32;49mok[0m]: GEOSEARCH with STOREDIST option
[[0;32;49mok[0m]: GEORADIUS withdist (sorted)
[[0;32;49mok[0m]: GEOSEARCH withdist (sorted)
[[0;32;49mok[0m]: GEORADIUS with COUNT
[[0;32;49mok[0m]: GEORADIUS with ANY not sorted by default
[[0;32;49mok[0m]: GEORADIUS with ANY sorted by ASC
[[0;32;49mok[0m]: GEORADIUS with ANY but no COUNT
[[0;32;49mok[0m]: GEORADIUS with COUNT but missing integer argument
[[0;32;49mok[0m]: GEORADIUS with COUNT DESC
[[0;32;49mok[0m]: GEORADIUS HUGE, issue #2767
[[0;32;49mok[0m]: GEORADIUSBYMEMBER simple (sorted)
[[0;32;49mok[0m]: GEOSEARCH FROMMEMBER simple (sorted)
[[0;32;49mok[0m]: GEOSEARCH vs GEORADIUS
[[0;32;49mok[0m]: GEOSEARCH non square, long and narrow
[[0;32;49mok[0m]: GEOSEARCH corner point test
[[0;32;49mok[0m]: GEORADIUSBYMEMBER withdist (sorted)
[[0;32;49mok[0m]: GEOHASH is able to return geohash strings
[[0;32;49mok[0m]: GEOPOS simple
[[0;32;49mok[0m]: GEOPOS missing element
[[0;32;49mok[0m]: GEODIST simple & unit
[[0;32;49mok[0m]: GEODIST missing elements
[[0;32;49mok[0m]: GEORADIUS STORE option: syntax error
[[0;32;49mok[0m]: GEOSEARCHSTORE STORE option: syntax error
[[0;32;49mok[0m]: GEORANGE STORE option: incompatible options
[[0;32;49mok[0m]: GEORANGE STORE option: plain usage
[[0;32;49mok[0m]: GEOSEARCHSTORE STORE option: plain usage
[[0;32;49mok[0m]: GEORANGE STOREDIST option: plain usage
[[0;32;49mok[0m]: GEOSEARCHSTORE STOREDIST option: plain usage
[[0;32;49mok[0m]: GEORANGE STOREDIST option: COUNT ASC and DESC
[[0;32;49mok[0m]: GEOSEARCH the box spans -180° or 180°
[[0;32;49mok[0m]: Connect a replica to the master instance (scripts replication)
[[0;32;49mok[0m]: Now use EVALSHA against the master, with both SHAs (scripts replication)
[[0;32;49mok[0m]: If EVALSHA was replicated as EVAL, 'x' should be '4' (scripts replication)
[[0;32;49mok[0m]: Replication of script multiple pushes to list with BLPOP (scripts replication)
[[0;32;49mok[0m]: EVALSHA replication when first call is readonly (scripts replication)
[[0;32;49mok[0m]: Lua scripts using SELECT are replicated correctly (scripts replication)
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-lru)
[[0;32;49mok[0m]: BITFIELD overflow wrap fuzzing
[[0;32;49mok[0m]: BITFIELD regression for #3221
[[0;32;49mok[0m]: BITFIELD regression for #3564
[[0;32;49mok[0m]: BITOP and fuzzing
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill first replica
[[0;32;49mok[0m]: Chained replicas disconnect when replica re-connect with the same master
[[0;32;49mok[0m]: Before the replica connects we issue two EVAL commands (commands replication)
[[0;32;49mok[0m]: BITOP or fuzzing
[[0;32;49mok[0m]: Connect a replica to the master instance (commands replication)
[[0;32;49mok[0m]: Client output buffer hard limit is enforced
[[0;32;49mok[0m]: Now use EVALSHA against the master, with both SHAs (commands replication)
[[0;32;49mok[0m]: If EVALSHA was replicated as EVAL, 'x' should be '4' (commands replication)
[[0;32;49mok[0m]: Replication of script multiple pushes to list with BLPOP (commands replication)
[[0;32;49mok[0m]: EVALSHA replication when first call is readonly (commands replication)
[[0;32;49mok[0m]: Lua scripts using SELECT are replicated correctly (commands replication)
[[0;32;49mok[0m]: TOUCH alters the last access time of a key
[[0;32;49mok[0m]: TOUCH returns the number of existing keys specified
[[0;32;49mok[0m]: command stats for GEOADD
[[0;32;49mok[0m]: command stats for EXPIRE
[[0;32;49mok[0m]: command stats for BRPOP
[[0;32;49mok[0m]: command stats for MULTI
[[0;32;49mok[0m]: command stats for scripts
[[0;32;49mok[0m]: PSYNC2 #3899 regression: kill chained replica
[39/64 [0;33;49mdone[0m]: integration/psync2-pingoff (18 seconds)
[1;37;49mTesting unit/memefficiency[0m
[[0;32;49mok[0m]: BITFIELD: setup slave
[[0;32;49mok[0m]: BITFIELD: write on master, read on slave
[[0;32;49mok[0m]: BITFIELD_RO fails when write option is used
[[0;32;49mok[0m]: BITOP xor fuzzing
[40/64 [0;33;49mdone[0m]: unit/introspection-2 (7 seconds)
[1;37;49mTesting unit/hyperloglog[0m
[41/64 [0;33;49mdone[0m]: unit/bitfield (3 seconds)
[1;37;49mTesting unit/lazyfree[0m
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-lru)
[[0;32;49mok[0m]: BITOP NOT fuzzing
[[0;32;49mok[0m]: BITOP with integer encoded source objects
[[0;32;49mok[0m]: BITOP with non string source key
[[0;32;49mok[0m]: BITOP with empty string after non empty string (issue #529)
[[0;32;49mok[0m]: BITPOS bit=0 with empty key returns 0
[[0;32;49mok[0m]: BITPOS bit=1 with empty key returns -1
[[0;32;49mok[0m]: BITPOS bit=0 with string less than 1 word works
[[0;32;49mok[0m]: BITPOS bit=1 with string less than 1 word works
[[0;32;49mok[0m]: BITPOS bit=0 starting at unaligned address
[[0;32;49mok[0m]: BITPOS bit=1 starting at unaligned address
[[0;32;49mok[0m]: BITPOS bit=0 unaligned+full word+reminder
[[0;32;49mok[0m]: BITPOS bit=1 unaligned+full word+reminder
[[0;32;49mok[0m]: BITPOS bit=1 returns -1 if string is all 0 bits
[[0;32;49mok[0m]: BITPOS bit=0 works with intervals
[[0;32;49mok[0m]: BITPOS bit=1 works with intervals
[[0;32;49mok[0m]: BITPOS bit=0 changes behavior if end is given
[[0;32;49mok[0m]: Fuzzer corrupt restore payloads - sanitize_dump: yes
[42/64 [0;33;49mdone[0m]: integration/corrupt-dump-fuzzer (21 seconds)
[1;37;49mTesting unit/wait[0m
[[0;32;49mok[0m]: BITPOS bit=1 fuzzy testing using SETBIT
[[0;32;49mok[0m]: Connect a replica to the master instance
[[0;32;49mok[0m]: Redis.replicate_commands() must be issued before any write
[[0;32;49mok[0m]: Redis.replicate_commands() must be issued before any write (2)
[[0;32;49mok[0m]: Redis.set_repl() must be issued after replicate_commands()
[[0;32;49mok[0m]: Redis.set_repl() don't accept invalid values
[[0;32;49mok[0m]: Test selective replication of certain Redis commands from Lua
[[0;32;49mok[0m]: PRNG is seeded randomly for command replication
[[0;32;49mok[0m]: Using side effects is not a problem with command replication
[[0;32;49mok[0m]: UNLINK can reclaim memory in background
[[0;32;49mok[0m]: Memory efficiency with values in range 32
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-random)
[[0;32;49mok[0m]: HyperLogLog self test passes
[[0;32;49mok[0m]: PFADD without arguments creates an HLL value
[[0;32;49mok[0m]: Approximated cardinality after creation is zero
[[0;32;49mok[0m]: PFADD returns 1 when at least 1 reg was modified
[[0;32;49mok[0m]: PFADD returns 0 when no reg was modified
[[0;32;49mok[0m]: PFADD works with empty string (regression)
[[0;32;49mok[0m]: PFCOUNT returns approximated cardinality of set
[[0;32;49mok[0m]: BITPOS bit=0 fuzzy testing using SETBIT
[[0;32;49mok[0m]: Memory efficiency with values in range 64
[[0;32;49mok[0m]: FLUSHDB ASYNC can reclaim memory in background
[43/64 [0;33;49mdone[0m]: unit/bitops (4 seconds)
[1;37;49mTesting unit/pendingquerybuf[0m
[44/64 [0;33;49mdone[0m]: unit/lazyfree (1 seconds)
[1;37;49mTesting unit/tls[0m
[[0;32;49mok[0m]: Memory efficiency with values in range 128
[45/64 [0;33;49mdone[0m]: unit/scripting (11 seconds)
[1;37;49mTesting unit/tracking[0m
[[0;32;49mok[0m]: Setup slave
[[0;32;49mok[0m]: WAIT should acknowledge 1 additional copy of the data
[46/64 [0;33;49mdone[0m]: unit/tls (0 seconds)
[1;37;49mTesting unit/oom-score-adj[0m
[47/64 [0;33;49mdone[0m]: unit/oom-score-adj (0 seconds)
[1;37;49mTesting unit/shutdown[0m
[[0;32;49mok[0m]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-ttl)
[[0;32;49mok[0m]: Clients are able to enable tracking and redirect it
[[0;32;49mok[0m]: Memory efficiency with values in range 1024
[[0;32;49mok[0m]: The other connection is able to get invalidations
[[0;32;49mok[0m]: The client is now able to disable tracking
[[0;32;49mok[0m]: Clients can enable the BCAST mode with the empty prefix
[[0;32;49mok[0m]: The connection gets invalidation messages about all the keys
[[0;32;49mok[0m]: Clients can enable the BCAST mode with prefixes
[[0;32;49mok[0m]: Adding prefixes to BCAST mode works
[[0;32;49mok[0m]: Tracking NOLOOP mode in standard mode works
[[0;32;49mok[0m]: Tracking NOLOOP mode in BCAST mode works
[[0;32;49mok[0m]: Temp rdb will be deleted if we use bg_unlink when shutdown
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 72657)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 4 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #2 as master
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #2
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #3
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #3
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #3
[[0;32;49mok[0m]: HyperLogLogs are promote from sparse to dense
[[0;32;49mok[0m]: Temp rdb will be deleted in signal handle
[48/64 [0;33;49mdone[0m]: unit/shutdown (1 seconds)
[1;37;49mTesting unit/networking[0m
[[0;32;49mok[0m]: maxmemory - policy volatile-lru should only remove volatile keys.
[[0;32;49mok[0m]: WAIT should not acknowledge 2 additional copies of the data
[[0;32;49mok[0m]: CONFIG SET port number
[[0;32;49mok[0m]: Tracking gets notification of expired keys
[[0;32;49mok[0m]: HELLO 3 reply is correct
[[0;32;49mok[0m]: HELLO without protover
[[0;32;49mok[0m]: RESP3 based basic invalidation
[[0;32;49mok[0m]: RESP3 tracking redirection
[[0;32;49mok[0m]: Invalidations of previous keys can be redirected after switching to RESP3
[[0;32;49mok[0m]: Invalidations of new keys can be redirected after switching to RESP3
[[0;32;49mok[0m]: RESP3 Client gets tracking-redir-broken push message after cached key changed when rediretion client is terminated
[[0;32;49mok[0m]: Different clients can redirect to the same connection
[[0;32;49mok[0m]: Different clients using different protocols can track the same key
[[0;32;49mok[0m]: No invalidation message when using OPTIN option
[[0;32;49mok[0m]: Invalidation message sent when using OPTIN option with CLIENT CACHING yes
[[0;32;49mok[0m]: Invalidation message sent when using OPTOUT option
[[0;32;49mok[0m]: No invalidation message when using OPTOUT option with CLIENT CACHING no
[[0;32;49mok[0m]: Able to redirect to a RESP3 client
[[0;32;49mok[0m]: After switching from normal tracking to BCAST mode, no invalidation message is produced for pre-BCAST keys
[[0;32;49mok[0m]: BCAST with prefix collisions throw errors
[[0;32;49mok[0m]: Tracking gets notification on tracking table key eviction
[[0;32;49mok[0m]: Invalidation message received for flushall
[[0;32;49mok[0m]: Invalidation message received for flushdb
[[0;32;49mok[0m]: Test ASYNC flushall
[[0;32;49mok[0m]: Server is able to evacuate enough keys when num of keys surpasses limit by more than defined initial effort
[[0;32;49mok[0m]: Tracking info is correct
[[0;32;49mok[0m]: CLIENT GETREDIR provides correct client id
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking off
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking on
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking on with options
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking optin
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking optout
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking bcast mode
[[0;32;49mok[0m]: CLIENT TRACKINGINFO provides reasonable results when tracking redir broken
[[0;32;49mok[0m]: CONFIG SET bind address
[49/64 [0;33;49mdone[0m]: unit/networking (1 seconds)
[50/64 [0;33;49mdone[0m]: unit/tracking (2 seconds)
[[0;32;49mok[0m]: Memory efficiency with values in range 16384
[[0;32;49mok[0m]: PSYNC2 #3899 regression: verify consistency
[51/64 [0;33;49mdone[0m]: unit/memefficiency (3 seconds)
[[0;32;49mok[0m]: maxmemory - policy volatile-lfu should only remove volatile keys.
[[0;32;49mok[0m]: HyperLogLog sparse encoding stress test
[[0;32;49mok[0m]: Corrupted sparse HyperLogLogs are detected: Additional at tail
[[0;32;49mok[0m]: Corrupted sparse HyperLogLogs are detected: Broken magic
[[0;32;49mok[0m]: Corrupted sparse HyperLogLogs are detected: Invalid encoding
[[0;32;49mok[0m]: Corrupted dense HyperLogLogs are detected: Wrong length
[52/64 [0;33;49mdone[0m]: integration/psync2-reg (22 seconds)
[[0;32;49mok[0m]: WAIT should not acknowledge 1 additional copy if slave is blocked
[[0;32;49mok[0m]: maxmemory - policy volatile-random should only remove volatile keys.
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: Client output buffer soft limit is enforced if time is overreached
[[0;32;49mok[0m]: maxmemory - policy volatile-ttl should only remove volatile keys.
[[0;32;49mok[0m]: WAIT implicitly blocks on client pause since ACKs aren't sent
[[0;32;49mok[0m]: Test replication partial resync: ok after delay (diskless: no, disabled, reconnect: 1)
[53/64 [0;33;49mdone[0m]: unit/wait (6 seconds)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: pending querybuf: check size of pending_querybuf after set a big value
[54/64 [0;33;49mdone[0m]: unit/pendingquerybuf (5 seconds)
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Client output buffer soft limit is not enforced too early and is enforced when no traffic
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 132769)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 5 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #0 as master
[[0;32;49mok[0m]: PSYNC2: Set #4 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #3
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: No response for single command if client output buffer hard limit is enforced
[[0;32;49mok[0m]: No response for multi commands in pipeline if client output buffer limit is enforced
[[0;32;49mok[0m]: Execute transactions completely even if client output buffer limit is enforced
[55/64 [0;33;49mdone[0m]: unit/obuf-limits (14 seconds)
[[0;32;49mok[0m]: MASTER and SLAVE consistency with EVALSHA replication
[[0;32;49mok[0m]: Connect multiple replicas at the same time (issue #141), master diskless=no, replica diskless=disabled
[[0;32;49mok[0m]: Fuzzing dense/sparse encoding: Redis should always detect errors
[[0;32;49mok[0m]: PFADD, PFCOUNT, PFMERGE type checking works
[[0;32;49mok[0m]: PFMERGE results on the cardinality of union of sets
[[0;32;49mok[0m]: SLAVE can reload "lua" AUX RDB fields of duplicated scripts
[56/64 [0;33;49mdone[0m]: integration/replication-3 (41 seconds)
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 197733)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 6 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #4 as master
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: client freed during loading
[57/64 [0;33;49mdone[0m]: integration/rdb (37 seconds)
[[0;32;49mok[0m]: slave buffer are counted correctly
[[0;32;49mok[0m]: Test replication partial resync: backlog expired (diskless: no, disabled, reconnect: 1)
[[0;32;49mok[0m]: PFCOUNT multiple-keys merge returns cardinality of union #1
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: AOF rewrite during write load: RDB preamble=no
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: no reconnection, just sync (diskless: no, swapdb, reconnect: 0)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 244655)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: PSYNC2: --- CYCLE 7 ---
[[0;32;49mok[0m]: PSYNC2: [NEW LAYOUT] Set #4 as master
[[0;32;49mok[0m]: PSYNC2: Set #1 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: Set #0 to replicate from #4
[[0;32;49mok[0m]: PSYNC2: Set #2 to replicate from #0
[[0;32;49mok[0m]: PSYNC2: Set #3 to replicate from #2
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after failover
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: PFCOUNT multiple-keys merge returns cardinality of union #2
[[0;32;49mok[0m]: PFDEBUG GETREG returns the HyperLogLog raw registers
[[0;32;49mok[0m]: PFADD / PFCOUNT cache invalidation works
[[0;32;49mok[0m]: GEOSEARCH fuzzy test - byradius
[[0;32;49mok[0m]: Turning off AOF kills the background writing child if any
[58/64 [0;33;49mdone[0m]: unit/hyperloglog (21 seconds)
[[0;32;49mok[0m]: AOF rewrite of list with quicklist encoding, string data
[[0;32;49mok[0m]: AOF rewrite of list with quicklist encoding, int data
[[0;32;49mok[0m]: PSYNC2: generate load while killing replication links
[[0;32;49mok[0m]: PSYNC2: cluster is consistent after load (x = 306710)
[[0;32;49mok[0m]: PSYNC2: total sum of full synchronizations is exactly 4
[[0;32;49mok[0m]: replica buffer don't induce eviction
[[0;32;49mok[0m]: AOF rewrite of set with intset encoding, string data
[[0;32;49mok[0m]: Don't rehash if used memory exceeds maxmemory after rehash
[[0;32;49mok[0m]: PSYNC2: Bring the master back again for next test
[[0;32;49mok[0m]: PSYNC2: Partial resync after restart using RDB aux fields
[[0;32;49mok[0m]: AOF rewrite of set with hashtable encoding, string data
[[0;32;49mok[0m]: Test replication partial resync: ok psync (diskless: no, swapdb, reconnect: 1)
[[0;32;49mok[0m]: client tracking don't cause eviction feedback loop
[[0;32;49mok[0m]: PSYNC2: Replica RDB restart with EVALSHA in backlog issue #4483
[59/64 [0;33;49mdone[0m]: unit/maxmemory (35 seconds)
[[0;32;49mok[0m]: AOF rewrite of set with intset encoding, int data
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[60/64 [0;33;49mdone[0m]: integration/psync2 (46 seconds)
[[0;32;49mok[0m]: AOF rewrite of set with hashtable encoding, int data
[[0;32;49mok[0m]: AOF rewrite of hash with ziplist encoding, string data
[[0;32;49mok[0m]: AOF rewrite of hash with hashtable encoding, string data
[[0;32;49mok[0m]: AOF rewrite of hash with ziplist encoding, int data
[[0;32;49mok[0m]: AOF rewrite of hash with hashtable encoding, int data
[[0;32;49mok[0m]: AOF rewrite of zset with ziplist encoding, string data
[[0;32;49mok[0m]: GEOSEARCH fuzzy test - bybox
[[0;32;49mok[0m]: Connect multiple replicas at the same time (issue #141), master diskless=no, replica diskless=swapdb
[[0;32;49mok[0m]: GEOSEARCH box edges fuzzy test
[61/64 [0;33;49mdone[0m]: north (36 seconds)
[[0;32;49mok[0m]: AOF rewrite of zset with skiplist encoding, string data
[[0;32;49mok[0m]: AOF rewrite of zset with ziplist encoding, int data
[[0;32;49mok[0m]: Test replication partial resync: no backlog (diskless: no, swapdb, reconnect: 1)
[[0;32;49mok[0m]: AOF rewrite of zset with skiplist encoding, int data
[[0;32;49mok[0m]: BGREWRITEAOF is delayed if BGSAVE is in progress
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: BGREWRITEAOF is refused if already in progress
[62/64 [0;33;49mdone[0m]: unit/aofrw (68 seconds)
[[0;32;49mok[0m]: Test replication partial resync: ok after delay (diskless: no, swapdb, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: backlog expired (diskless: no, swapdb, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: no reconnection, just sync (diskless: yes, disabled, reconnect: 0)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Connect multiple replicas at the same time (issue #141), master diskless=yes, replica diskless=disabled
[[0;32;49mok[0m]: Test replication partial resync: ok psync (diskless: yes, disabled, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: no backlog (diskless: yes, disabled, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: ok after delay (diskless: yes, disabled, reconnect: 1)
[[0;32;49mok[0m]: Connect multiple replicas at the same time (issue #141), master diskless=yes, replica diskless=swapdb
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: backlog expired (diskless: yes, disabled, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: no reconnection, just sync (diskless: yes, swapdb, reconnect: 0)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: ok psync (diskless: yes, swapdb, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Master stream is correctly processed while the replica has a script in -BUSY state
[[0;32;49mok[0m]: slave fails full sync and diskless load swapdb recovers it
[[0;32;49mok[0m]: Test replication partial resync: no backlog (diskless: yes, swapdb, reconnect: 1)
[[0;32;49mok[0m]: diskless loading short read
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: ok after delay (diskless: yes, swapdb, reconnect: 1)
[[0;32;49mok[0m]: Slave should be able to synchronize with the master
[[0;32;49mok[0m]: Detect write load to master
[[0;32;49mok[0m]: Test replication partial resync: backlog expired (diskless: yes, swapdb, reconnect: 1)
[63/64 [0;33;49mdone[0m]: integration/replication-psync (173 seconds)
[[0;32;49mok[0m]: diskless no replicas drop during rdb pipe
[[0;32;49mok[0m]: diskless slow replicas drop during rdb pipe
[[0;31;49merr[0m]: diskless fast replicas drop during rdb pipe in tests/integration/replication.tcl
rdb child didn't terminate
[[0;31;49merr[0m]: diskless all replicas drop during rdb pipe in tests/integration/replication.tcl
log message of '"*Loading DB in memory*"' not found in ./tests/tmp/server.15671.79/stdout after line: 29 till line: 36
[[0;31;49merr[0m]: diskless timeout replicas drop during rdb pipe in tests/integration/replication.tcl
log message of '"*Loading DB in memory*"' not found in ./tests/tmp/server.15671.83/stdout after line: 29 till line: 36
[[0;32;49mok[0m]: diskless replication child being killed is collected
[[0;32;49mok[0m]: diskless replication read pipe cleanup
[[0;32;49mok[0m]: replicaof right after disconnection
[[0;32;49mok[0m]: Kill rdb child process if its dumping RDB is not useful
[64/64 [0;33;49mdone[0m]: integration/replication (265 seconds)
[1;37;49mTesting solo test[0m
[64/64 [0;33;49mdone[0m]: defrag (0 seconds)

                   The End

Execution time of different units:
  0 seconds - unit/printver
  0 seconds - unit/type/incr
  1 seconds - unit/keyspace
  1 seconds - unit/protocol
  1 seconds - unit/info
  2 seconds - unit/auth
  1 seconds - unit/quit
  3 seconds - unit/scan
  1 seconds - unit/acl
  5 seconds - unit/type/hash
  4 seconds - unit/multi
  6 seconds - unit/type/string
  6 seconds - unit/type/stream-cgroups
  7 seconds - unit/type/list
  9 seconds - unit/sort
  9 seconds - unit/type/set
  12 seconds - unit/other
  9 seconds - unit/latency-monitor
  14 seconds - unit/type/list-2
  16 seconds - unit/type/list-3
  15 seconds - unit/expire
  0 seconds - integration/logging
  0 seconds - integration/convert-zipmap-hash-on-load
  11 seconds - integration/replication-2
  9 seconds - integration/aof
  21 seconds - unit/type/stream
  6 seconds - integration/failover
  11 seconds - integration/corrupt-dump
  1 seconds - unit/pubsub
  25 seconds - unit/type/zset
  2 seconds - integration/redis-benchmark
  2 seconds - unit/slowlog
  7 seconds - integration/redis-cli
  3 seconds - unit/introspection
  1 seconds - unit/limits
  27 seconds - integration/block-repl
  32 seconds - unit/dump
  26 seconds - integration/replication-4
  18 seconds - integration/psync2-pingoff
  7 seconds - unit/introspection-2
  3 seconds - unit/bitfield
  21 seconds - integration/corrupt-dump-fuzzer
  4 seconds - unit/bitops
  1 seconds - unit/lazyfree
  11 seconds - unit/scripting
  0 seconds - unit/tls
  0 seconds - unit/oom-score-adj
  1 seconds - unit/shutdown
  1 seconds - unit/networking
  2 seconds - unit/tracking
  3 seconds - unit/memefficiency
  22 seconds - integration/psync2-reg
  6 seconds - unit/wait
  5 seconds - unit/pendingquerybuf
  14 seconds - unit/obuf-limits
  41 seconds - integration/replication-3
  37 seconds - integration/rdb
  21 seconds - unit/hyperloglog
  35 seconds - unit/maxmemory
  46 seconds - integration/psync2
  36 seconds - north
  68 seconds - unit/aofrw
  173 seconds - integration/replication-psync
  265 seconds - integration/replication
  0 seconds - defrag

[1;31;49m!!! WARNING[0m The following tests failed:

*** [[0;31;49merr[0m]: diskless fast replicas drop during rdb pipe in tests/integration/replication.tcl
rdb child didn't terminate
*** [[0;31;49merr[0m]: diskless all replicas drop during rdb pipe in tests/integration/replication.tcl
log message of '"*Loading DB in memory*"' not found in ./tests/tmp/server.15671.79/stdout after line: 29 till line: 36
*** [[0;31;49merr[0m]: diskless timeout replicas drop during rdb pipe in tests/integration/replication.tcl
log message of '"*Loading DB in memory*"' not found in ./tests/tmp/server.15671.83/stdout after line: 29 till line: 36
Cleanup: may take some time... OK
make[2]: *** [Makefile:383: test] Error 1
make[2]: Leaving directory '$(@D)/src'
make[1]: *** [Makefile:6: check] Error 2
make[1]: Leaving directory '$(@D)'
