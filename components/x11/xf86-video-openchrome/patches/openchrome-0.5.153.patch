diff -ruN xf86-video-openchrome-0.5.0/src/Makefile.am xf86-video-openchrome/src/Makefile.am
--- xf86-video-openchrome-0.5.0/src/Makefile.am	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/Makefile.am	2016-09-09 20:39:48.254174758 +0300
@@ -40,6 +40,7 @@
          via_3d.c \
          via_3d.h \
          via_3d_reg.h \
+         via_analog.c \
          via_rop.h \
          via_exa.c \
          via_exa_h2.c \
@@ -62,6 +63,10 @@
          via_mode.h \
          via_priv.h \
          via_regs.h \
+         via_sii164.c \
+         via_sii164.h \
+         via_tmds.c \
+         via_tv.c \
          via_xv_overlay.c \
          via_xv_overlay.h \
          via_ums.c \
diff -ruN xf86-video-openchrome-0.5.0/src/Makefile.in xf86-video-openchrome/src/Makefile.in
--- xf86-video-openchrome-0.5.0/src/Makefile.in	2016-07-06 19:22:04.000000000 +0300
+++ xf86-video-openchrome/src/Makefile.in	2016-09-09 20:50:14.423183457 +0300
@@ -177,21 +177,23 @@
 LTLIBRARIES = $(openchrome_drv_la_LTLIBRARIES)
 openchrome_drv_la_LIBADD =
 am__openchrome_drv_la_SOURCES_DIST = compat-api.h via_eng_regs.h \
-	via_3d.c via_3d.h via_3d_reg.h via_rop.h via_exa.c \
-	via_exa_h2.c via_exa_h6.c via_bandwidth.c via_ums.h \
+	via_3d.c via_3d.h via_3d_reg.h via_analog.c via_rop.h \
+	via_exa.c via_exa_h2.c via_exa_h6.c via_bandwidth.c via_ums.h \
 	via_ch7xxx.c via_ch7xxx.h via_display.c via_dmabuffer.h \
 	via_driver.c via_driver.h via_i2c.c via_id.c via_lvds.c \
 	via_memcpy.c via_memmgr.h via_memmgr.c via_outputs.c \
-	via_mode.h via_priv.h via_regs.h via_xv_overlay.c \
-	via_xv_overlay.h via_ums.c via_vgahw.c via_vgahw.h via_xv.c \
-	via_xv.h via_vt162x.c via_vt162x.h via_vt1632.c via_vt1632.h \
+	via_mode.h via_priv.h via_regs.h via_sii164.c via_sii164.h \
+	via_tmds.c via_tv.c via_xv_overlay.c via_xv_overlay.h \
+	via_ums.c via_vgahw.c via_vgahw.h via_xv.c via_xv.h \
+	via_vt162x.c via_vt162x.h via_vt1632.c via_vt1632.h \
 	via_xvpriv.h via_dri.c via_dri.h via_drm.h via_drmclient.h \
 	via_kms.h via_kms.c via_xvmc.c via_xvmc.h drm_fourcc.h
 @DRI_TRUE@am__objects_1 = via_dri.lo via_kms.lo via_xvmc.lo
-am_openchrome_drv_la_OBJECTS = via_3d.lo via_exa.lo via_exa_h2.lo \
-	via_exa_h6.lo via_bandwidth.lo via_ch7xxx.lo via_display.lo \
-	via_driver.lo via_i2c.lo via_id.lo via_lvds.lo via_memcpy.lo \
-	via_memmgr.lo via_outputs.lo via_xv_overlay.lo via_ums.lo \
+am_openchrome_drv_la_OBJECTS = via_3d.lo via_analog.lo via_exa.lo \
+	via_exa_h2.lo via_exa_h6.lo via_bandwidth.lo via_ch7xxx.lo \
+	via_display.lo via_driver.lo via_i2c.lo via_id.lo via_lvds.lo \
+	via_memcpy.lo via_memmgr.lo via_outputs.lo via_sii164.lo \
+	via_tmds.lo via_tv.lo via_xv_overlay.lo via_ums.lo \
 	via_vgahw.lo via_xv.lo via_vt162x.lo via_vt1632.lo \
 	$(am__objects_1)
 openchrome_drv_la_OBJECTS = $(am_openchrome_drv_la_OBJECTS)
@@ -361,7 +363,6 @@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
-LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
@@ -463,15 +464,16 @@
 openchrome_drv_la_LDFLAGS = -module -avoid-version @LIBUDEV_LIBS@
 openchrome_drv_ladir = @moduledir@/drivers
 openchrome_drv_la_SOURCES = compat-api.h via_eng_regs.h via_3d.c \
-	via_3d.h via_3d_reg.h via_rop.h via_exa.c via_exa_h2.c \
-	via_exa_h6.c via_bandwidth.c via_ums.h via_ch7xxx.c \
-	via_ch7xxx.h via_display.c via_dmabuffer.h via_driver.c \
-	via_driver.h via_i2c.c via_id.c via_lvds.c via_memcpy.c \
-	via_memmgr.h via_memmgr.c via_outputs.c via_mode.h via_priv.h \
-	via_regs.h via_xv_overlay.c via_xv_overlay.h via_ums.c \
-	via_vgahw.c via_vgahw.h via_xv.c via_xv.h via_vt162x.c \
-	via_vt162x.h via_vt1632.c via_vt1632.h via_xvpriv.h \
-	$(am__append_1)
+	via_3d.h via_3d_reg.h via_analog.c via_rop.h via_exa.c \
+	via_exa_h2.c via_exa_h6.c via_bandwidth.c via_ums.h \
+	via_ch7xxx.c via_ch7xxx.h via_display.c via_dmabuffer.h \
+	via_driver.c via_driver.h via_i2c.c via_id.c via_lvds.c \
+	via_memcpy.c via_memmgr.h via_memmgr.c via_outputs.c \
+	via_mode.h via_priv.h via_regs.h via_sii164.c via_sii164.h \
+	via_tmds.c via_tv.c via_xv_overlay.c via_xv_overlay.h \
+	via_ums.c via_vgahw.c via_vgahw.h via_xv.c via_xv.h \
+	via_vt162x.c via_vt162x.h via_vt1632.c via_vt1632.h \
+	via_xvpriv.h $(am__append_1)
 all: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
@@ -552,6 +554,7 @@
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_3d.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_analog.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_bandwidth.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_ch7xxx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_display.Plo@am__quote@
@@ -567,6 +570,9 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_memcpy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_memmgr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_outputs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_sii164.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_tmds.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_tv.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_ums.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_vgahw.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/via_vt162x.Plo@am__quote@
diff -ruN xf86-video-openchrome-0.5.0/src/openchrome.man xf86-video-openchrome/src/openchrome.man
--- xf86-video-openchrome-0.5.0/src/openchrome.man	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/openchrome.man	2016-09-09 20:39:48.254735416 +0300
@@ -0,0 +1,248 @@
+.\" Shorthand for double quote that works everywhere,
+.\" also within other double quotes:
+.ds q \N'34'
+.TH OPENCHROME __drivermansuffix__ __vendorversion__
+.SH NAME
+openchrome \- video driver for VIA Unichromes
+.SH SYNOPSIS
+.nf
+.B "Section \*qDevice\*q"
+.BI "  Identifier \*q" devname \*q
+.B  "  Driver \*qopenchrome\*q"
+\ \ ...
+.B EndSection
+.fi
+
+.SH DESCRIPTION
+.B openchrome
+is an __xservername__ driver for VIA chipsets that have an integrated
+Unichrome graphics engine.
+.PP
+The
+.B openchrome
+driver supports the following chipsets: CLE266, KM400/KN400/KM400A/P4M800,
+CN400/PM800/PN800/PM880, K8M800, CN700/VM800/P4M800Pro, CX700, P4M890, K8M890,
+P4M900/VN896/CN896, VX800, VX855 and VX900.
+The driver includes 2D acceleration and Xv video overlay extensions.
+Flat panel, TV, and VGA outputs are supported, depending on the hardware
+configuration.
+.PP
+3D direct rendering is available using experimental drivers from Mesa
+(www.mesa3d.org).  There is also an XvMC client library for hardware
+acceleration of MPEG1/MPEG2 decoding (not available on the KM/N400)
+that uses the Direct Rendering Infrastructure (DRI).
+The XvMC client library implements a non-standard
+"VLD" extension to the XvMC standard.  The current Direct Rendering
+Manager (DRM) kernel module is available at dri.sourceforge.net.
+.PP
+The driver supports free modes for Unichrome Pros (K8M800/K8N800, PM800/PN800,
+and CN400).  For plain Unichromes (CLE266, KM400/KN400), it currently supports
+only a limited number of dotclocks, so if you are using X modelines you
+must make sure that the dotclock is one of those supported.  Supported
+dotclocks on plain Unichromes are currently (in MHz): 25.2, 25.312,
+26.591, 31.5, 31.704, 32.663, 33.750, 35.5, 36.0, 39.822, 40.0, 41.164,
+46.981, 49.5, 50.0, 56.3, 57.284, 64.995, 65.0, 65.028, 74.480,
+75.0, 78.8, 81.613, 94.5, 108.0, 108.28, 122.0, 122.726, 135.0,
+148.5, 155.8, 157.5, 161.793, 162.0, 175.5, 189.0, 202.5, 204.8,
+218.3, 229.5.  On top of this, bandwidth restrictions apply for both
+Unichromes and Unichrome Pros.
+.PP
+.SH CONFIGURATION DETAILS
+Please refer to __xconfigfile__(__filemansuffix__) for general configuration
+details.  This section only covers configuration details specific to this
+driver.
+.PP
+The following driver
+.B options
+are supported:
+.TP
+.BI "Option \*qAccelMethod\*q  \*q" string \*q
+The driver supports "XAA" and "EXA" acceleration methods.  The default
+method is XAA, since EXA is still experimental.  Contrary to XAA, EXA
+implements acceleration for screen uploads and downloads (if DRI is
+enabled) and for the Render/Composite extension.
+.TP
+.BI "Option \*qActiveDevice\*q  \*q" string \*q
+Specifies the active device combination.  Any string containing "CRT",
+"LCD", "DFP", "TV" should be possible. "CRT" represents anything that
+is connected to the VGA port, "LCD" is for laptop panels (not TFT screens
+attached to the VGA port), "DFP" is for screens connected to the DVI port,
+"TV" is self-explanatory.
+The default is to use what is detected.  The driver is currently unable
+to use LCD and TV simultaneously, and will favour the LCD.  The DVI port is
+not properly probed and needs to be enabled with this option.
+.TP
+.BI "Option \*qAGPMem\*q  \*q" integer \*q
+Sets the amount of AGP memory that is allocated at X server startup.
+The allocated memory will be "integer" kB.  This AGP memory is used for
+the AGP command buffer (if the option "EnableAGPDMA" is set to "true"), for
+DRI textures, and for the EXA scratch area.  The driver will allocate at
+least one system page of AGP memory, or \-\- if the AGP command buffer is
+used \-\- at least 2 MB plus one system page.  If there is no room for the
+EXA scratch area in AGP space, it will be allocated from VRAM.  If there is
+no room for DRI textures, they will be allocated from the DRI part of
+VRAM (see the option "MaxDRIMem").  The default amount of AGP is
+32768 kB.  Note that the AGP aperture set in the BIOS must be able
+to accommodate the amount of AGP memory specified here.  Otherwise no
+AGP memory will be available.  It is safe to set a very large AGP
+aperture in the BIOS.
+.TP
+.BI "Option \*qCenter\*q  \*q" boolean \*q
+Enables image centering on DVI displays.  The default is disabled.
+.TP
+.BI "Option \*qDisableIRQ\*q  \*q" boolean \*q
+Disables the vertical blank IRQ.  This is a workaround for some mainboards
+that have problems with IRQs coming from the Unichrome engine.  With IRQs
+disabled, DRI clients have no way to synchronize their drawing to Vblank.
+(IRQ is disabled by default on the KM400 and K8M800 chipsets.)
+.TP
+.BI "Option \*qDisableVQ\*q  \*q" boolean \*q
+Disables the use of the virtual command queue.  The queue is enabled
+by default.
+.TP
+.BI "Option \*qEnableAGPDMA\*q  \*q" boolean \*q
+Enables the AGP DMA functionality in DRM.  This requires that DRI is enabled
+and will force 2D and 3D acceleration to use AGP DMA.  The XvMC DRI
+client will also make use of this on the CLE266 to consume much less CPU.
+(This option is enabled by default, except on the K8M890 and P4M900.) 
+.TP
+.BI "Option \*qExaNoComposite\*q  \*q" boolean \*q
+If EXA is enabled (using the option "AccelMethod"), this option enables
+acceleration of compositing.  Since EXA, and in particular its composite
+acceleration, is still experimental, this is a way to disable a misbehaving
+composite acceleration.
+.TP
+.BI "Option \*qExaScratchSize\*q  \*q" integer \*q
+Sets the size of the EXA scratch area to "integer" kB.  This area is
+used by EXA as a last place to look for available space for pixmaps.
+Too little space will slow compositing down.  This option should be set
+to the size of the largest pixmap used.  If you have a screen width of
+over 1024 pixels and use 24 bpp, set this to 8192.  Otherwise you can
+leave this at the default 4096.  The space will be allocated from AGP
+memory if available, otherwise from VRAM.
+.TP
+.BI "Option \*qLCDDualEdge\*q  \*q" boolean \*q
+Enables the use of dual-edge mode to set the LCD.  The default is disabled.
+.TP
+.BI "Option \*qMaxDRIMem\*q  \*q" integer \*q
+Sets the maximum amount of VRAM memory allocated for DRI clients to
+"integer" kB.  Normally DRI clients  get half the available VRAM size,
+but in some cases it may make sense to limit this amount.  For example,
+if you are using a composite manager and you want to give as much memory
+as possible to the EXA pixmap storage area.
+.TP
+.BI "Option \*qMigrationHeuristic\*q  \*q" string \*q
+Sets the heuristic for EXA pixmap migration.  This is an EXA core
+option, and starting from __xservername__ server version 1.3.0 this defaults to
+"always".  The openchrome driver performs best with "greedy", so you
+should really add this option to your configuration file.  The third
+possibility is "smart".
+.TP
+.BI "Option \*qNoAccel\*q  \*q" boolean \*q
+Disables the use of hardware acceleration.  Acceleration is enabled
+by default.
+.TP
+.BI "Option \*qNoAGPFor2D\*q  \*q" boolean \*q
+Disables the use of AGP DMA for 2D acceleration, even when AGP DMA is
+enabled.  The default is enabled.
+.TP
+.BI "Option \*qNoXVDMA\*q  \*q" boolean \*q
+If DRI is enabled, Xv normally uses PCI DMA to transfer video images
+from system to frame-buffer memory.  This is somewhat slower than
+direct copies due to the limitations of the PCI bus, but on the other
+hand it decreases CPU usage significantly, particularly on computers
+with fast processors.  Some video players are buggy and will display
+rendering artifacts when PCI DMA is used.  If you experience this,
+or don't want your PCI bus to be stressed with Xv images, set this
+option to "true".  This option has no effect when DRI is not enabled.
+.TP
+.BI "Option \*qPanelSize\*q  \*q" string \*q
+Specifies the size (width x height) of the LCD panel attached to the
+system.  The sizes 640x480, 800x600, 1024x768, 1280x1024, and 1400x1050
+are supported.
+.TP
+.BI "Option \*qRotationType\*q  \*q" string \*q
+Enabled rotation by using RandR. The driver only support unaccelerated
+RandR rotations "SWRandR". Hardware rotations "HWRandR" is currently 
+unimplemented.
+.TP
+.BI "Option \*qRotate\*q  \*q" string \*q
+Rotates the display either clockwise ("CW"), counterclockwise ("CCW") and
+upside-down ("UD"). Rotation is only supported unaccelerated.  Adding 
+option "Rotate", enables RandR rotation feature.  The RandR allows 
+clients to dynamically change X screens.
+.TP
+.BI "Option \*qShadowFB\*q  \*q" boolean \*q
+Enables the use of a shadow frame buffer.  This is required when
+rotating the display, but otherwise defaults to disabled.
+.TP
+.BI "Option \*qSWCursor\*q  \*q" boolean \*q
+Enables the use of a software cursor.  The default is disabled:
+the hardware cursor is used.
+.TP
+.BI "Option \*qTVDeflicker\*q  \*q" integer \*q
+Specifies the deflicker setting for TV output.  Valid values are "0", "1",
+and "2".  Here 0 means no deflicker, 1 means 1:1:1 deflicker, and 2 means
+1:2:1 deflicker.
+.TP
+.BI "Option \*qTVDotCrawl\*q  \*q" boolean \*q
+Enables dot-crawl suppression.  The default is disabled.
+.TP
+.BI "Option \*qTVOutput\*q  \*q" string \*q
+Specifies which TV output to use.  The driver supports "S-Video",
+"Composite", "SC", "RGB", and "YCbCr" outputs.  Note that on some
+EPIA boards the composite-video port is shared with audio-out and
+is selected via a jumper.
+.TP
+.BI "Option \*qTVPort\*q  \*q" string \*q
+Specifies TV port.  The driver currently supports "DVP0", "DVP1", 
+"DFPHigh" and "DFPLow" ports.
+.TP
+.BI "Option \*qTVType\*q  \*q" string \*q
+Specifies TV output format.  The driver currently supports "NTSC" and
+"PAL" timings only.
+.TP
+.BI "Option \*qVBEModes\*q  \*q" boolean \*q
+Enables the use of VBE BIOS calls for setting the display mode.  This mimics
+the behaviour of the vesa driver but still provides acceleration and
+other features.  This option may be used if your hardware works with
+the vesa driver but not with the openchrome driver.  It may not work
+on 64-bit systems.  Using "VBEModes" may speed up driver acceleration
+significantly due to a more aggressive hardware setting, particularly
+on systems with low memory bandwidth.  Your refresh rate may be limited
+to 60 Hz on some systems.
+.TP
+.BI "Option \*qVBESaveRestore\*q  \*q" boolean \*q
+Enables the use of VBE BIOS calls for saving and restoring the display state
+when the X server is launched.  This can be extremely slow on some hardware,
+and the system may appear to have locked for 10 seconds or so.  The default
+is to use the driver builtin function.  This option only works if option
+"VBEModes" is enabled.
+.TP
+.BI "Option \*qVideoRAM\*q  \*q" integer \*q
+Overrides the VideoRAM autodetection.  This should never be needed.
+.PP 
+.SH "TV ENCODERS"
+Unichromes tend to be paired with several different TV encoders.
+.TP
+.BI "VIA Technologies VT1621"
+Still untested, as no combination with a Unichrome is known or available.
+Supports the following normal modes: "640x480" and "800x600".  Use
+"640x480Over" and "800x600Over" for vertical overscan.  These modes
+are made available by the driver; modelines provided in __xconfigfile__
+will be ignored.
+.TP
+.BI "VIA Technologies VT1622, VT1622A, VT1623"
+Supports the following modes: "640x480", "800x600", "1024x768",
+"848x480", "720x480" (NTSC only) and "720x576" (PAL only).  Use
+"640x480Over", "800x600Over", "1024x768Over", "848x480Over",
+"720x480Over" (NTSC) and "720x576Over" (PAL) for vertical overscan.
+The modes "720x480Noscale" (NTSC) and "720x576Noscale" (PAL) (available
+on VT1622 only) provide cleaner TV output (unscaled with only minimal
+overscan).  These modes are made available by the driver; modelines
+provided in __xconfigfile__ will be ignored.
+
+.SH "SEE ALSO"
+__xservername__(__appmansuffix__), __xconfigfile__(__filemansuffix__), Xserver(__appmansuffix__), X(__miscmansuffix__), EXA(__filemansuffix__), Xv(__filemansuffix__)
+.SH AUTHORS
+Authors include: ...
diff -ruN xf86-video-openchrome-0.5.0/src/version.h xf86-video-openchrome/src/version.h
--- xf86-video-openchrome-0.5.0/src/version.h	2016-07-06 19:22:40.000000000 +0300
+++ xf86-video-openchrome/src/version.h	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-#define BUILDCOMMENT "(openchrome 0.5.0 release)"
diff -ruN xf86-video-openchrome-0.5.0/src/via_analog.c xf86-video-openchrome/src/via_analog.c
--- xf86-video-openchrome-0.5.0/src/via_analog.c	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/via_analog.c	2016-09-09 20:39:48.256221300 +0300
@@ -0,0 +1,394 @@
+/*
+ * Copyright 2005-2016 The OpenChrome Project
+ *                     [http://www.freedesktop.org/wiki/Openchrome]
+ * Copyright 2004-2005 The Unichrome Project  [unichrome.sf.net]
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * via_analog.c
+ *
+ * Handles the initialization and management of analog VGA related
+ * resources.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "via_driver.h"
+#include <unistd.h>
+
+
+/*
+ * Enables or disables analog VGA output by controlling DAC
+ * (Digital to Analog Converter) output state.
+ */
+static void
+viaAnalogOutput(ScrnInfoPtr pScrn, Bool outputState)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaAnalogOutput.\n"));
+
+    /* This register controls analog VGA DAC output state. */
+    /* 3X5.47[2] - DACOFF Backdoor Register
+     *             0: DAC on
+     *             1: DAC off */
+    ViaCrtcMask(hwp, 0x47, outputState ? 0x00 : 0x04, 0x04);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Analog VGA Output: %s\n",
+                outputState ? "On" : "Off");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaAnalogOutput.\n"));
+}
+
+/*
+ * Specifies IGA1 or IGA2 for analog VGA DAC source.
+ */
+static void
+viaAnalogSource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 value = displaySource;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaAnalogSource.\n"));
+
+    ViaSeqMask(hwp, 0x16, value << 6, 0x40);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Analog VGA Output Source: IGA%d\n",
+                (value & 0x01) + 1);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaAnalogSource.\n"));
+}
+
+/*
+ * Intializes analog VGA related registers.
+ */
+static void
+viaAnalogInit(ScrnInfoPtr pScrn)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaAnalogInit.\n"));
+
+    /* 3X5.37[7]   - DAC Power Save Control 1
+     *               0: Depend on Rx3X5.37[5:4] setting
+     *               1: DAC always goes into power save mode
+     * 3X5.37[6]   - DAC Power Down Control
+     *               0: Depend on Rx3X5.47[2] setting
+     *               1: DAC never goes to power down mode
+     * 3X5.37[5:4] - DAC Power Save Control 2
+     *               00: DAC never goes to power save mode
+     *               01: DAC goes to power save mode by line
+     *               10: DAC goes to power save mode by frame
+     *               11: DAC goes to power save mode by line and frame
+     * 3X5.37[3]   - DAC PEDESTAL Control
+     * 3X5.37[2:0] - DAC Factor
+     *               (Default: 100) */
+    ViaCrtcMask(hwp, 0x37, 0x04, 0xFF);
+
+    switch (pVia->Chipset) {
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.5E[0] - CRT DACOFF Setting
+         *             1: CRT DACOFF controlled by 3C5.01[5] */
+        ViaSeqMask(hwp, 0x5E, 0x01, 0x01);
+        break;
+    default:
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaAnalogInit.\n"));
+}
+
+static void
+via_analog_create_resources(xf86OutputPtr output)
+{
+}
+
+static void
+via_analog_dpms(xf86OutputPtr output, int mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_analog_dpms.\n"));
+
+    switch (mode) {
+    case DPMSModeOn:
+        viaAnalogOutput(pScrn, TRUE);
+        break;
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+    case DPMSModeOff:
+        viaAnalogOutput(pScrn, FALSE);
+        break;
+    default:
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_analog_dpms.\n"));
+}
+
+static void
+via_analog_save(xf86OutputPtr output)
+{
+}
+
+static void
+via_analog_restore(xf86OutputPtr output)
+{
+}
+
+static int
+via_analog_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    if (!ViaModeDotClockTranslate(pScrn, pMode))
+        return MODE_NOCLOCK;
+    return MODE_OK;
+}
+
+static Bool
+via_analog_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
+                      DisplayModePtr adjusted_mode)
+{
+    return TRUE;
+}
+
+static void
+via_analog_prepare(xf86OutputPtr output)
+{
+    via_analog_dpms(output, DPMSModeOff);
+}
+
+static void
+via_analog_commit(xf86OutputPtr output)
+{
+    via_analog_dpms(output, DPMSModeOn);
+}
+
+static void
+via_analog_mode_set(xf86OutputPtr output, DisplayModePtr mode,
+                    DisplayModePtr adjusted_mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_analog_mode_set.\n"));
+
+    viaAnalogInit(pScrn);
+
+    if (output->crtc) {
+        viaAnalogSource(pScrn, iga->index ? 0x01 : 0x00);
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_analog_mode_set.\n"));
+}
+
+static xf86OutputStatus
+via_analog_detect(xf86OutputPtr output)
+{
+    xf86OutputStatus status = XF86OutputStatusDisconnected;
+    ScrnInfoPtr pScrn = output->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+    xf86MonPtr mon;
+
+    /* Probe I2C Bus 1 to see if a VGA monitor is connected. */
+    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                "Probing for a VGA monitor on I2C Bus 1.\n");
+    mon = xf86OutputGetEDID(output, pVia->pI2CBus1);
+    if (mon && (!mon->features.input_type)) {
+        xf86OutputSetEDID(output, mon);
+        status = XF86OutputStatusConnected;
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "Detected a VGA monitor on I2C Bus 1.\n");
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "Did not detect a VGA monitor on I2C Bus 1.\n");
+
+        /* Probe I2C Bus 2 to see if a VGA monitor is connected. */
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "Probing for a VGA monitor on I2C Bus 2.\n");
+        mon = xf86OutputGetEDID(output, pVia->pI2CBus2);
+        if (mon && (!mon->features.input_type)) {
+            xf86OutputSetEDID(output, mon);
+            status = XF86OutputStatusConnected;
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Detected a VGA monitor on I2C Bus 2.\n");
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Did not detect a VGA monitor on I2C Bus 2.\n");
+
+            /* Perform manual detection of a VGA monitor since */
+            /* it was not detected via I2C buses. */
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Now perform manual detection of a VGA "
+                        "monitor.\n");
+            vgaHWPtr hwp = VGAHWPTR(pScrn);
+            CARD8 SR01 = hwp->readSeq(hwp, 0x01);
+            CARD8 SR40 = hwp->readSeq(hwp, 0x40);
+            CARD8 CR36 = hwp->readCrtc(hwp, 0x36);
+
+            /* We have to power on the display to detect it */
+            ViaSeqMask(hwp, 0x01, 0x00, 0x20);
+            ViaCrtcMask(hwp, 0x36, 0x00, 0xF0);
+
+            /* Wait for vblank */
+            usleep(16);
+
+            /* Detect the load on pins */
+            ViaSeqMask(hwp, 0x40, 0x80, 0x80);
+
+            if ((VIA_CX700 == pVia->Chipset) ||
+                (VIA_VX800 == pVia->Chipset) ||
+                (VIA_VX855 == pVia->Chipset) ||
+                (VIA_VX900 == pVia->Chipset))
+                ViaSeqMask(hwp, 0x40, 0x00, 0x80);
+
+            if (ViaVgahwIn(hwp, 0x3C2) & 0x20) {
+                status = XF86OutputStatusConnected;
+                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                            "Detected a VGA monitor using manual "
+                            "detection method.\n");
+            }
+
+            if ((VIA_CX700 == pVia->Chipset) ||
+                (VIA_VX800 == pVia->Chipset) ||
+                (VIA_VX855 == pVia->Chipset) ||
+                (VIA_VX900 == pVia->Chipset))
+                ViaSeqMask(hwp, 0x40, 0x00, 0x80);
+
+            /* Restore previous state */
+            hwp->writeSeq(hwp, 0x40, SR40);
+            hwp->writeSeq(hwp, 0x01, SR01);
+            hwp->writeCrtc(hwp, 0x36, CR36);
+        }
+    }
+
+    return status;
+}
+
+#ifdef RANDR_12_INTERFACE
+static Bool
+via_analog_set_property(xf86OutputPtr output, Atom property,
+                        RRPropertyValuePtr value)
+{
+    return TRUE;
+}
+#endif
+
+#ifdef RANDR_13_INTERFACE
+static Bool
+via_analog_get_property(xf86OutputPtr output, Atom property)
+{
+    return FALSE;
+}
+#endif
+
+static void
+via_analog_destroy(xf86OutputPtr output)
+{
+}
+
+static const xf86OutputFuncsRec via_analog_funcs = {
+    .create_resources   = via_analog_create_resources,
+    .dpms               = via_analog_dpms,
+    .save               = via_analog_save,
+    .restore            = via_analog_restore,
+    .mode_valid         = via_analog_mode_valid,
+    .mode_fixup         = via_analog_mode_fixup,
+    .prepare            = via_analog_prepare,
+    .commit             = via_analog_commit,
+    .mode_set           = via_analog_mode_set,
+    .detect             = via_analog_detect,
+    .get_modes          = xf86OutputGetEDIDModes,
+#ifdef RANDR_12_INTERFACE
+    .set_property       = via_analog_set_property,
+#endif
+#ifdef RANDR_13_INTERFACE
+    .get_property       = via_analog_get_property,
+#endif
+    .destroy            = via_analog_destroy,
+};
+
+void
+via_analog_init(ScrnInfoPtr pScrn)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
+    xf86OutputPtr output = NULL;
+    char outputNameBuffer[32];
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_analog_init.\n"));
+
+    if (!pVia->pI2CBus1 || !pVia->pI2CBus2) {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "I2C Bus 1 or I2C Bus 2 does not exist.\n");
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Exiting via_analog_init.\n"));
+        return;
+    }
+
+    /* The code to dynamically designate the output name for
+     * xrandr was borrowed from xf86-video-r128 DDX. */
+    sprintf(outputNameBuffer, "VGA-%d", (pVia->numberVGA + 1));
+    output = xf86OutputCreate(pScrn, &via_analog_funcs, outputNameBuffer);
+
+    /* While there are two (2) display controllers registered with the
+     * X.Org Server, it is often desirable to fix the analog VGA output
+     * to IGA1 since LVDS FP (Flat Panel) typically prefers IGA2. (While
+     * it is not used at this point, only IGA2 contains panel resolution
+     * scaling functionality. IGA1 does not have this.)
+     * With this arrangement, DVI should end up getting assigned to IGA2
+     * since DVI can go to either display controller without limitations.
+     * This should be the case for TV as well. */
+    output->possible_crtcs = (1 << 0);
+
+    output->possible_clones = 0;
+    output->interlaceAllowed = TRUE;
+    output->doubleScanAllowed = FALSE;
+    pBIOSInfo->analog = output;
+
+    /* Increment the number of analog VGA connectors. */
+    pVia->numberVGA++;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_analog_init.\n"));
+}
diff -ruN xf86-video-openchrome-0.5.0/src/via_display.c xf86-video-openchrome/src/via_display.c
--- xf86-video-openchrome-0.5.0/src/via_display.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_display.c	2016-09-10 02:42:52.035873476 +0300
@@ -31,6 +31,41 @@
 
 #include "via_driver.h"
 
+
+static void
+ViaPrintMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
+{
+    xf86PrintModeline(pScrn->scrnIndex, mode);
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHDisplay: 0x%x\n",
+               mode->CrtcHDisplay);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHBlankStart: 0x%x\n",
+               mode->CrtcHBlankStart);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHSyncStart: 0x%x\n",
+               mode->CrtcHSyncStart);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHSyncEnd: 0x%x\n",
+               mode->CrtcHSyncEnd);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHBlankEnd: 0x%x\n",
+               mode->CrtcHBlankEnd);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHTotal: 0x%x\n",
+               mode->CrtcHTotal);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHSkew: 0x%x\n",
+               mode->CrtcHSkew);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVDisplay: 0x%x\n",
+               mode->CrtcVDisplay);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVBlankStart: 0x%x\n",
+               mode->CrtcVBlankStart);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVSyncStart: 0x%x\n",
+               mode->CrtcVSyncStart);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVSyncEnd: 0x%x\n",
+               mode->CrtcVSyncEnd);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVBlankEnd: 0x%x\n",
+               mode->CrtcVBlankEnd);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVTotal: 0x%x\n",
+               mode->CrtcVTotal);
+
+}
+
 /*
  * Controls IGA1 DPMS State.
  */
@@ -53,6 +88,141 @@
                         "Exiting viaIGA1DPMSControl.\n"));
 }
 
+static void
+viaIGA1InitHI(ScrnInfoPtr pScrn)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaIGA1InitHI.\n"));
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        VIASETREG(PRIM_HI_TRANSCOLOR, 0x00000000);
+        VIASETREG(PRIM_HI_INVTCOLOR, 0x00FFFFFF);
+
+        /* Not setting up V327_HI_INVTCOLOR register contributes to
+         * an X Server boot time crash. */
+        VIASETREG(V327_HI_INVTCOLOR, 0x00FFFFFF);
+        VIASETREG(PRIM_HI_FIFO, 0x0D000D0F);
+        VIASETREG(PRIM_HI_CTRL, 0x36000004);
+        break;
+    default:
+        VIASETREG(HI_TRANSPARENT_COLOR, 0x00000000);
+        VIASETREG(HI_INVTCOLOR, 0x00FFFFFF);
+        VIASETREG(ALPHA_V3_PREFIFO_CONTROL, 0x000E0000);
+        VIASETREG(ALPHA_V3_FIFO_CONTROL, 0xE0F0000);
+        VIASETREG(HI_CONTROL, 0x76000004);
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaIGA1InitHI.\n"));
+}
+
+static void
+viaIGA1SetHIStartingAddress(xf86CrtcPtr crtc)
+{
+
+    drmmode_crtc_private_ptr iga = crtc->driver_private;
+    ScrnInfoPtr pScrn = crtc->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaIGA1SetHIStartingAddress.\n"));
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        VIASETREG(PRIM_HI_FBOFFSET, iga->cursor_bo->offset);
+        break;
+    default:
+        /* Mono Cursor Display Path [bit31]: Primary */
+        VIASETREG(HI_FBOFFSET, iga->cursor_bo->offset);
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaIGA1SetHIStartingAddress.\n"));
+}
+
+/*
+ * This function displays or hides IGA1 hardware icon (HI).
+ */
+static void
+viaIGA1DisplayHI(ScrnInfoPtr pScrn, Bool HI_Status)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD32 temp;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaIGA1DisplayHI.\n"));
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        temp = VIAGETREG(PRIM_HI_CTRL);
+        temp &= 0xFFFFFFFE;
+        temp |= HI_Status ? 0x00000001 : 0x00000000;
+
+        /* PRIM_HI_CTRL[0] - Hardware Icon (HI) Enable */
+        VIASETREG(PRIM_HI_CTRL, temp);
+        break;
+    default:
+        temp = VIAGETREG(HI_CONTROL);
+        temp &= 0xFFFFFFFE;
+        temp |= HI_Status ? 0x00000001 : 0x00000000;
+
+        /* HI_CONTROL[0] - Hardware Icon (HI) Enable */
+        VIASETREG(HI_CONTROL, temp);
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaIGA1DisplayHI.\n"));
+}
+
+static void
+viaIGA1SetHIDisplayLocation(ScrnInfoPtr pScrn,
+                            int x, unsigned int xoff,
+                            int y, unsigned int yoff)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        VIASETREG(PRIM_HI_POSSTART,     ((x    << 16) | (y    & 0x07ff)));
+        VIASETREG(PRIM_HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07ff)));
+        break;
+    default:
+        VIASETREG(HI_POSSTART,     ((x    << 16) | (y    & 0x07ff)));
+        VIASETREG(HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07ff)));
+        break;
+    }
+}
+
 /*
  * Controls IGA2 display output on or off state.
  */
@@ -101,6 +271,123 @@
                         "Exiting viaIGA2DisplayChannel.\n"));
 }
 
+static void
+viaIGA2InitHI(ScrnInfoPtr pScrn)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaIGA2InitHI.\n"));
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        VIASETREG(HI_TRANSPARENT_COLOR, 0x00000000);
+        VIASETREG(HI_INVTCOLOR, 0x00FFFFFF);
+        VIASETREG(ALPHA_V3_PREFIFO_CONTROL, 0x000E0000);
+        VIASETREG(ALPHA_V3_FIFO_CONTROL, 0x0E0F0000);
+        VIASETREG(HI_CONTROL, 0xB6000004);
+        break;
+    default:
+        VIASETREG(HI_TRANSPARENT_COLOR, 0x00000000);
+        VIASETREG(HI_INVTCOLOR, 0X00FFFFFF);
+        VIASETREG(ALPHA_V3_PREFIFO_CONTROL, 0x000E0000);
+        VIASETREG(ALPHA_V3_FIFO_CONTROL, 0xE0F0000);
+        VIASETREG(HI_CONTROL, 0xF6000004);
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaIGA2InitHI.\n"));
+}
+
+static void
+viaIGA2SetHIStartingAddress(xf86CrtcPtr crtc)
+{
+    drmmode_crtc_private_ptr iga = crtc->driver_private;
+    ScrnInfoPtr pScrn = crtc->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaIGA2SetHIStartingAddress.\n"));
+
+    VIASETREG(HI_FBOFFSET, iga->cursor_bo->offset);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaIGA2SetHIStartingAddress.\n"));
+}
+
+/*
+ * This function displays or hides IGA2 hardware icon (HI).
+ */
+static void
+viaIGA2DisplayHI(ScrnInfoPtr pScrn, Bool HI_Status)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD32 temp;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaIGA2DisplayHI.\n"));
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        temp = VIAGETREG(HI_CONTROL);
+        temp &= 0xFFFFFFFE;
+        temp |= HI_Status ? 0x00000001 : 0x00000000;
+
+        /* HI_CONTROL[0] - Hardware Icon (HI) Enable */
+        VIASETREG(HI_CONTROL, temp);
+        break;
+    default:
+        temp = VIAGETREG(HI_CONTROL);
+        temp &= 0xFFFFFFFE;
+        temp |= HI_Status ? 0x00000001 : 0x00000000;
+
+        /* HI_CONTROL[0] - Hardware Icon (HI) Enable */
+        VIASETREG(HI_CONTROL, temp);
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaIGA2DisplayHI.\n"));
+}
+
+static void
+viaIGA2SetHIDisplayLocation(ScrnInfoPtr pScrn,
+                            int x, unsigned int xoff,
+                            int y, unsigned int yoff)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    switch(pVia->Chipset) {
+    case VIA_PM800:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_P4M900:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        VIASETREG(HI_POSSTART,     ((x    << 16) | (y    & 0x07FF)));
+        VIASETREG(HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07FF)));
+        break;
+    default:
+        VIASETREG(HI_POSSTART,     ((x    << 16) | (y    & 0x07FF)));
+        VIASETREG(HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07FF)));
+        break;
+    }
+}
+
 /*
  * Initial settings for displays.
  */
@@ -288,6 +575,23 @@
      *             1: Enable */
     ViaSeqMask(hwp, 0x10, 0x01, 0x01);
 
+    temp = hwp->readEnable(hwp);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Enable Register: 0x%02X\n", temp));
+    hwp->writeEnable(hwp, temp | 0x01);
+
+    temp = hwp->readMiscOut(hwp);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Misc. Register: 0x%02X\n", temp));
+    hwp->writeMiscOut(hwp, temp | 0x2E);
+
+    temp = hwp->readEnable(hwp);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Enable Register: 0x%02X\n", temp));
+    temp = hwp->readMiscOut(hwp);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Misc. Register: 0x%02X\n", temp));
+
     ViaCRTCSetGraphicsRegisters(pScrn);
     ViaCRTCSetAttributeRegisters(pScrn);
 
@@ -449,7 +753,7 @@
      * 3C5.1E[0]   - On/Off ROC ECK
      *               0: Off
      *               1: On */
-    ViaSeqMask(hwp, 0x1E, 0xF4, 0xF4);
+    ViaSeqMask(hwp, 0x1E, 0xF5, 0xFD);
 
     /* Set DVP0 data drive strength to 0b11 (highest). */
     /* Set DVP0 clock drive strength to 0b11 (highest). */
@@ -563,9 +867,19 @@
      *               1: Enable */
     ViaCrtcMask(hwp, 0x36, 0x01, 0x01);
 
-    /* For UniChrome Pro and Chrome9. */
-    if ((pVia->Chipset != VIA_CLE266)
-        && (pVia->Chipset != VIA_KM400)) {
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+    case VIA_KM400:
+        ViaCrtcMask(hwp, 0x47, 0x00, 0x23);
+        break;
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+    case VIA_CX700:
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+    case VIA_VX800:
         /* 3X5.47[7] - IGA1 Timing Plus 2 VCK
          * 3X5.47[6] - IGA1 Timing Plus 4 VCK
          * 3X5.47[5] - Peep at the PCI-bus
@@ -577,10 +891,27 @@
          * 3X5.47[1] - LCD Simultaneous Mode Backdoor Register for
          *             8/9 Dot Clocks
          * 3X5.47[0] - LCD Simultaneous Mode Backdoor Register for
-         *             Clock Select and CRTC Register Protect
-         *
-         */
+         *             Clock Select and CRTC Register Protect */
         ViaCrtcMask(hwp, 0x47, 0x00, 0x23);
+        break;
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3X5.47[7] - IGA1 Timing Plus 2 VCK
+         * 3X5.47[6] - IGA1 Timing Plus 4 VCK
+         * 3X5.47[5] - Peep at the PCI-bus
+         *             0: Disable
+         *             1: Enable
+         * 3X5.47[4] - CRT Timing Register Protect
+         * 3X5.47[3] - IGA1 Timing Plus 6 VCK
+         * 3X5.47[2] - DACOFF Backdoor Register
+         * 3X5.47[1] - LCD Simultaneous Mode Backdoor Register for
+         *             8/9 Dot Clocks
+         * 3X5.47[0] - LCD Simultaneous Mode Backdoor Register for
+         *             Clock Select */
+        ViaCrtcMask(hwp, 0x47, 0x00, 0x33);
+        break;
+    default:
+        break;
     }
 
     /* 3X5.6B[3] - Simultaneous Display Enable
@@ -868,18 +1199,24 @@
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                 "IGA1 Requested Screen Mode: %s\n", mode->name);
 
-    ViaCrtcMask(hwp, 0x11, 0x00, 0x80); /* modify starting address */
-    ViaCrtcMask(hwp, 0x03, 0x80, 0x80); /* enable vertical retrace access */
-
-    /* Set Misc Register */
-    temp = 0x23;
-    if (mode->Flags & V_NHSYNC)
+    /* Set certain bits of miscellaneous output register
+     * meant for IGA1. */
+    temp = hwp->readMiscOut(hwp);
+    if (mode->Flags & V_NHSYNC) {
         temp |= 0x40;
-    if (mode->Flags & V_NVSYNC)
+    } else {
+        temp &= (~0x40);
+    }
+
+    if (mode->Flags & V_NVSYNC) {
         temp |= 0x80;
-    temp |= 0x0C; /* Undefined/external clock */
+    } else {
+        temp &= (~0x80);
+    }
+
     hwp->writeMiscOut(hwp, temp);
 
+
     /* Sequence registers */
     hwp->writeSeq(hwp, 0x00, 0x00);
 
@@ -894,11 +1231,13 @@
     hwp->writeSeq(hwp, 0x03, 0x00);
     hwp->writeSeq(hwp, 0x04, 0x0E);
 
+    ViaCrtcMask(hwp, 0x03, 0x80, 0x80); /* enable vertical retrace access */
 
     /* Setting maximum scan line to 0. */
     /* 3X5.09[4:0] - Maximum Scan Line */
     ViaCrtcMask(hwp, 0x09, 0x00, 0x1F);
 
+    ViaCrtcMask(hwp, 0x11, 0x00, 0x80); /* modify starting address */
 
     /* 3X5.14[6]   - Double Word Mode
      *               Allows normal addressing or double-word addressing.
@@ -1016,12 +1355,14 @@
      *               111: Shift to early time by 2 characters */
     ViaCrtcMask(hwp, 0x33, 0x05, 0x4F);
 
-    /* Set IGA1 to linear mode */
-    /* 3X5.43[2]  - IGA1 Address Mode Selection
-     *              0: Linear
-     *              1: Tile */
-    ViaCrtcMask(hwp, 0x43, 0x00, 0x04);
-
+    /* UniChrome Pro or later */
+    if ((pVia->Chipset != VIA_CLE266) && (pVia->Chipset != VIA_KM400)) {
+        /* Set IGA1 to linear mode. */
+        /* 3X5.43[2]  - IGA1 Address Mode Selection
+         *              0: Linear
+         *              1: Tile */
+        ViaCrtcMask(hwp, 0x43, 0x00, 0x04);
+    }
 
     /* Set IGA1 horizontal total.*/
     /* Due to IGA1 horizontal total being only 9 bits wide,
@@ -1041,9 +1382,9 @@
 
 
     /* Set IGA1 horizontal display end. */
-    /* Due to IGA1 horizontal display end being only 8 bits wide,
-     * the adjusted horizontal display end needs to be shifted by
-     * 3 bit positions to the right.
+    /* Due to IGA1 horizontal display end being only 8 bits
+     * or 9 bits (for VX900 chipset) wide, the adjusted horizontal
+     * display end needs to be shifted by 3 bit positions to the right.
      * In addition to that, this particular register requires the
      * value to be 1 less than the actual value being written. */
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -1053,11 +1394,17 @@
     /* 3X5.01[7:0] - Horizontal Display End Bits [7:0] */
     hwp->writeCrtc(hwp, 0x01, temp & 0xFF);
 
+    if (pVia->Chipset == VIA_VX900) {
+        /* 3X5.45[1] - Horizontal Display End Bit [8] */
+        ViaCrtcMask(hwp, 0x45, temp >> 7, 0x02);
+    }
+
 
     /* Set IGA1 horizontal blank start. */
-    /* Due to IGA1 horizontal blank start being only 8 bits wide,
-     * the adjusted horizontal blank start needs to be shifted by
-     * 3 bit positions to the right. */
+    /* Due to IGA1 horizontal blank start being only 8 bits or
+     * 9 bits (for VX900 chipset) wide, the adjusted horizontal
+     * blank start needs to be shifted by 3 bit positions to the
+     * right. */
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "IGA1 CrtcHBlankStart: %d\n", mode->CrtcHBlankStart));
     temp = mode->CrtcHBlankStart >> 3;
@@ -1065,6 +1412,11 @@
     /* 3X5.02[7:0] - Horizontal Blanking Start Bits [7:0] */
      hwp->writeCrtc(hwp, 0x02, temp & 0xFF);
 
+     if (pVia->Chipset == VIA_VX900) {
+         /* 3X5.45[2] - Horizontal Blanking Start Bit [8] */
+         ViaCrtcMask(hwp, 0x45, temp >> 6, 0x04);
+     }
+
 
     /* Set IGA1 horizontal blank end. */
     /* After shifting horizontal blank end by 3 bit positions to the
@@ -1263,6 +1615,8 @@
 static ModeStatus
 viaIGA1ModeValid(ScrnInfoPtr pScrn, DisplayModePtr mode)
 {
+    VIAPtr pVia = VIAPTR(pScrn);
+
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered viaIGA1ModeValid.\n"));
 
@@ -1279,10 +1633,16 @@
     if (mode->CrtcHTotal > (4096 + ((1 << 3) * (5 - 1))))
         return MODE_BAD_HVALUE;
 
-    if (mode->CrtcHDisplay > 2048)
+    if (((pVia->Chipset != VIA_VX900)
+            && (mode->CrtcHDisplay > 2048))
+        || ((pVia->Chipset == VIA_VX900)
+            && (mode->CrtcHDisplay > 4096)))
         return MODE_BAD_HVALUE;
 
-    if (mode->CrtcHBlankStart > 2048)
+    if (((pVia->Chipset != VIA_VX900)
+            && (mode->CrtcHBlankStart > 2048))
+        || ((pVia->Chipset == VIA_VX900)
+            && (mode->CrtcHBlankStart > 4096)))
         return MODE_BAD_HVALUE;
 
     if ((mode->CrtcHBlankEnd - mode->CrtcHBlankStart) > 1025)
@@ -1745,7 +2105,7 @@
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Restoring IGA1 registers.\n"));
 
-/* UniChrome Pro or later */
+/*  later */
     switch (pVia->Chipset) {
     case VIA_PM800:
     case VIA_K8M800:
@@ -2007,24 +2367,6 @@
      *             1: Enable */
     ViaCrtcMask(hwp, 0x79, 0x00, 0x01);
 
-    /* Set DVP0 (Digital Video Port 0) source to IGA2. */
-    /* 3X5.96[7]   - DVP0 ALPHA Enable
-     *               0: Disable
-     *               1: Enable
-     * 3X5.96[6]   - DVP0 VSYNC Polarity
-     *               0: Positive
-     *               1: Negative
-     * 3X5.96[5]   - DVP0 HSYNC Polarity
-     *               0: Positive
-     *               1: Negative
-     * 3X5.96[4]   - DVP0 Data Source Selection 0
-     *               0: Primary Display
-     *               1: Secondary Display
-     * 3X5.96[3]   - DVP0 Clock Polarity
-     * 3X5.96[2:0] - DVP0 Clock Adjust
-     *               Valid Value: 0 through 7 */
-    ViaCrtcMask(hwp, 0x96, 0x10, 0x10);
-
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting viaIGA2Init.\n"));
 }
@@ -2127,20 +2469,20 @@
      * (Power Management Status). */
     ViaSeqMask(hwp, 0x2A, 0x0F, 0x0F);
 
-    /* 3X5.99[3:0] appears to be a register to adjust an LCD panel
-     * (the official name of the register is unknown). */
-    if (pVia->Chipset == VIA_P4M900) {
-        ViaCrtcMask(hwp, 0x99, 0x08, 0x0F);
+    /* UniChrome Pro or later */
+    if ((pVia->Chipset != VIA_CLE266) && (pVia->Chipset != VIA_KM400)) {
+        /* Set IGA2 to linear mode. */
+        /* 3X5.62[0] - IGA2 Address Mode Selection
+         *             0: Linear
+         *             1: Tile */
+        ViaCrtcMask(hwp, 0x62, 0x00, 0x01);
     }
 
-    /* IGA2 for DFP Low. */
-    ViaCrtcMask(hwp, 0x99, 0x10, 0x10);
-
-    /* Use IGA2 for DVP1 Data Source Selection 0. */
-    ViaCrtcMask(hwp, 0x9B, 0x10, 0x10);
-
-    /* Linear Mode */
-    ViaCrtcMask(hwp, 0x62, 0x00, 0x01);
+    /* Keep interlace mode off. */
+    /* 3X5.67[5] - Second Display Interlace Mode
+     *             0: Off
+     *             1: On */
+    ViaCrtcMask(hwp, 0x67, 0x00, 0x20);
 
 
     /* Set IGA2 horizontal total pixels.*/
@@ -2168,12 +2510,20 @@
     /* 3X5.55[6:4] - Horizontal Active Data Period Bits [10:8] */
     ViaCrtcMask(hwp, 0x55, temp >> 4, 0x70);
 
+    if (pVia->Chipset == VIA_VX900) {
+        /* 3X5.55[7] - Horizontal Active Data Period Bits [11] */
+        ViaCrtcMask(hwp, 0x55, temp >> 4, 0x80);
+    }
+
 
     /* Set IGA2 horizontal blank start. */
-    /* Horizontal Blanking Start: 2048 - 1 (max) */
+    /* Subtracting 1 from CrtcHBlankStart appears to suppress some
+     * monitors from reporting horizontal resolution that is 1 more
+     * than the desired horizontal
+     * resolution. (i.e., 1601 rather than 1600) */
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "IGA2 CrtcHBlankStart: %d\n", mode->CrtcHBlankStart));
-    temp = mode->CrtcHBlankStart;
+    temp = mode->CrtcHBlankStart - 1;
 
     /* 3X5.52[7:0] - Horizontal Blanking Start Bits [7:0] */
     hwp->writeCrtc(hwp, 0x52, temp & 0xFF);
@@ -2181,6 +2531,11 @@
     /* 3X5.54[2:0] - Horizontal Blanking Start Bits [10:8] */
     ViaCrtcMask(hwp, 0x54, temp >> 8, 0x07);
 
+    if (pVia->Chipset == VIA_VX900) {
+        /* 3X5.6B[0] - Horizontal Blanking Start Bit [11] */
+        ViaCrtcMask(hwp, 0x6B, temp >> 11, 0x01);
+    }
+
 
     /* Set IGA2 horizontal blank end. */
     /* Horizontal Blanking End: 4096 - 1 (max) */
@@ -2263,10 +2618,13 @@
 
 
     /* Set IGA2 vertical blank start. */
-    /* Vertical Blanking Start: 2048 - 1 (max) */
+    /* Subtracting 1 from CrtcVBlankStart appears to suppress some
+     * monitors from reporting vertical resolution that is 1 more
+     * than the desired vertical resolution. (i.e., 1201 rather
+     * than 1200) */
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "IGA2 CrtcVBlankStart: %d\n", mode->CrtcVBlankStart));
-    temp = mode->CrtcVBlankStart;
+    temp = mode->CrtcVBlankStart - 1;
 
     /* 3X5.5A[7:0] - Vertical Blanking Start Bits [7:0] */
     hwp->writeCrtc(hwp, 0x5A, temp & 0xFF);
@@ -2359,10 +2717,16 @@
     if (mode->CrtcHTotal > 4096)
         return MODE_BAD_HVALUE;
 
-    if (mode->CrtcHDisplay > 2048)
+    if (((pVia->Chipset != VIA_VX900)
+            && (mode->CrtcHDisplay > 2048))
+        || ((pVia->Chipset == VIA_VX900)
+            && (mode->CrtcHDisplay > 4096)))
         return MODE_BAD_HVALUE;
 
-    if (mode->CrtcHBlankStart > 2048)
+    if (((pVia->Chipset != VIA_VX900)
+            && (mode->CrtcHBlankStart > 2048))
+        || ((pVia->Chipset == VIA_VX900)
+            && (mode->CrtcHBlankStart > 4096)))
         return MODE_BAD_HVALUE;
 
     if (mode->CrtcHBlankEnd > 4096)
@@ -2737,8 +3101,6 @@
 iga1_crtc_dpms(xf86CrtcPtr crtc, int mode)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga1_crtc_dpms.\n"));
@@ -2776,25 +3138,16 @@
 {
     ScrnInfoPtr pScrn = crtc->scrn;
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    VIAPtr pVia = VIAPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga1_crtc_save.\n"));
 
-    vgaHWProtect(pScrn, TRUE);
-
-    /* Save the standard VGA registers. */
-    if (xf86IsPrimaryPci(pVia->PciInfo)) {
-        vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_ALL);
-    } else {
-        vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE);
-    }
-
-    viaIGA1Save(pScrn);
-
     vgaHWProtect(pScrn, FALSE);
     vgaHWUnlock(hwp);
 
+    vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_ALL);
+    viaIGA1Save(pScrn);
+
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting iga1_crtc_save.\n"));
 }
@@ -2804,33 +3157,27 @@
 {
     ScrnInfoPtr pScrn = crtc->scrn;
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    VIAPtr pVia = VIAPTR(pScrn);
-    CARD8 tmp;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga1_crtc_restore.\n"));
 
-    vgaHWProtect(pScrn, TRUE);
-
-    /* Restore the standard VGA registers. */
-    if (xf86IsPrimaryPci(pVia->PciInfo)) {
-        vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_ALL);
-    } else {
-        vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE);
-    }
-
     /* Gamma must be disabled before restoring palette. */
     ViaGammaDisable(pScrn);
 
+    vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_ALL);
     viaIGA1Restore(pScrn);
 
     ViaDisablePrimaryFIFO(pScrn);
 
-    vgaHWProtect(pScrn, FALSE);
     vgaHWLock(hwp);
+    vgaHWProtect(pScrn, FALSE);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting iga1_crtc_restore.\n"));
+
+
+
+
 }
 
 static Bool
@@ -2889,7 +3236,6 @@
 iga1_crtc_set_origin(xf86CrtcPtr crtc, int x, int y)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga1_crtc_set_origin.\n"));
@@ -2935,6 +3281,7 @@
     /* Disable IGA1 */
     ViaSeqMask(hwp, 0x59, 0x00, 0x80);
 
+    ViaPrintMode(pScrn, adjusted_mode);
     viaIGA1SetDisplayRegister(pScrn, adjusted_mode);
     ViaSetPrimaryFIFO(pScrn, adjusted_mode);
 
@@ -2969,7 +3316,6 @@
     ScrnInfoPtr pScrn = crtc->scrn;
     vgaHWPtr hwp = VGAHWPTR(pScrn);
     VIAPtr pVia = VIAPTR(pScrn);
-    int SR1A, SR1B, CR67, CR6A;
     LOCO colors[size];
     int i;
 
@@ -2994,12 +3340,6 @@
         VIALoadRgbLut(pScrn, 0, size, colors);
 
     } else {
-
-        SR1A = hwp->readSeq(hwp, 0x1A);
-        SR1B = hwp->readSeq(hwp, 0x1B);
-        CR67 = hwp->readCrtc(hwp, 0x67);
-        CR6A = hwp->readCrtc(hwp, 0x6A);
-
         for (i = 0; i < size; i++) {
             hwp->writeDacWriteAddr(hwp, i);
             hwp->writeDacData(hwp, colors[i].red);
@@ -3033,12 +3373,10 @@
     and in all other bpps the fg and bg are in 8-8-8 RGB format.
 */
 static void
-iga1_crtc_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg)
+iga1_crtc_set_cursor_colors(xf86CrtcPtr crtc, int bg, int fg)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-    VIAPtr pVia = VIAPTR(pScrn);
-    CARD32 temp;
 
     if (xf86_config->cursor_fg)
         return;
@@ -3047,33 +3385,16 @@
     if (fg == xf86_config->cursor_fg && bg == xf86_config->cursor_bg)
         return;
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        temp = VIAGETREG(PRIM_HI_CTRL);
-        VIASETREG(PRIM_HI_CTRL, temp & 0xFFFFFFFE);
-        break;
-
-    default:
-        temp = VIAGETREG(HI_CONTROL);
-        VIASETREG(HI_CONTROL, temp & 0xFFFFFFFE);
-        break;
-    }
+    viaIGA1DisplayHI(pScrn, FALSE);
 
     xf86_config->cursor_fg = fg;
     xf86_config->cursor_bg = bg;
 }
 
 static void
-iga1_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
+iga1_crtc_set_cursor_position(xf86CrtcPtr crtc, int x, int y)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
     unsigned xoff, yoff;
 
     if (x < 0) {
@@ -3090,90 +3411,57 @@
         yoff = 0;
     }
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        VIASETREG(PRIM_HI_POSSTART,    ((x    << 16) | (y    & 0x07ff)));
-        VIASETREG(PRIM_HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07ff)));
-        break;
-
-    default:
-        VIASETREG(HI_POSSTART,    ((x    << 16) | (y    & 0x07ff)));
-        VIASETREG(HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07ff)));
-        break;
-    }
+    viaIGA1SetHIDisplayLocation(pScrn, x, xoff, y, yoff);
 }
 
 static void
-iga1_crtc_show_cursor (xf86CrtcPtr crtc)
+iga1_crtc_show_cursor(xf86CrtcPtr crtc)
 {
-    drmmode_crtc_private_ptr iga = crtc->driver_private;
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        VIASETREG(PRIM_HI_FBOFFSET, iga->cursor_bo->offset);
-        VIASETREG(PRIM_HI_CTRL, 0x36000005);
-        break;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered iga1_crtc_show_cursor.\n"));
 
-    default:
-        /* Mono Cursor Display Path [bit31]: Primary */
-        VIASETREG(HI_FBOFFSET, iga->cursor_bo->offset);
-        VIASETREG(HI_CONTROL, 0x76000005);
-        break;
-    }
+    viaIGA1DisplayHI(pScrn, TRUE);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting iga1_crtc_show_cursor.\n"));
 }
 
 static void
-iga1_crtc_hide_cursor (xf86CrtcPtr crtc)
+iga1_crtc_hide_cursor(xf86CrtcPtr crtc)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    CARD32 temp;
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        temp = VIAGETREG(PRIM_HI_CTRL);
-        VIASETREG(PRIM_HI_CTRL, temp & 0xFFFFFFFA);
-        break;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered iga1_crtc_hide_cursor.\n"));
 
-    default:
-        temp = VIAGETREG(HI_CONTROL);
-        /* Hardware cursor disable [bit0] */
-        VIASETREG(HI_CONTROL, temp & 0xFFFFFFFA);
-        break;
-    }
+    viaIGA1DisplayHI(pScrn, FALSE);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting iga1_crtc_hide_cursor.\n"));
 }
 
 static void
-iga_crtc_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *image)
+iga1_crtc_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *image)
 {
     drmmode_crtc_private_ptr iga = crtc->driver_private;
     ScrnInfoPtr pScrn = crtc->scrn;
     void *dst;
 
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered iga1_crtc_load_cursor_argb.\n"));
+
     dst = drm_bo_map(pScrn, iga->cursor_bo);
     memset(dst, 0x00, iga->cursor_bo->size);
     memcpy(dst, image, iga->cursor_bo->size);
     drm_bo_unmap(pScrn, iga->cursor_bo);
+
+    viaIGA1InitHI(pScrn);
+    viaIGA1SetHIStartingAddress(crtc);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting iga1_crtc_load_cursor_argb.\n"));
 }
 
 static void
@@ -3211,7 +3499,7 @@
     .set_cursor_position    = iga1_crtc_set_cursor_position,
     .show_cursor            = iga1_crtc_show_cursor,
     .hide_cursor            = iga1_crtc_hide_cursor,
-    .load_cursor_argb       = iga_crtc_load_cursor_argb,
+    .load_cursor_argb       = iga1_crtc_load_cursor_argb,
 #if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) > 2
     .set_origin             = iga1_crtc_set_origin,
 #endif
@@ -3222,8 +3510,6 @@
 iga2_crtc_dpms(xf86CrtcPtr crtc, int mode)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga2_crtc_dpms.\n"));
@@ -3254,8 +3540,6 @@
 iga2_crtc_save(xf86CrtcPtr crtc)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    vgaHWPtr hwp = VGAHWPTR(pScrn);
-    VIAPtr pVia = VIAPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga2_crtc_save.\n"));
@@ -3270,9 +3554,6 @@
 iga2_crtc_restore(xf86CrtcPtr crtc)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    vgaHWPtr hwp = VGAHWPTR(pScrn);
-    VIAPtr pVia = VIAPTR(pScrn);
-    CARD8 tmp;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga2_crtc_restore.\n"));
@@ -3339,7 +3620,6 @@
 iga2_crtc_set_origin(xf86CrtcPtr crtc, int x, int y)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered iga2_crtc_set_origin.\n"));
@@ -3378,6 +3658,7 @@
     viaIGA2Init(pScrn);
     ViaCRTCInit(pScrn);
 
+    ViaPrintMode(pScrn, adjusted_mode);
     viaIGA2SetDisplayRegister(pScrn, adjusted_mode);
     ViaSetSecondaryFIFO(pScrn, adjusted_mode);
     pBIOSInfo->Clock = ViaModeDotClockTranslate(pScrn, adjusted_mode);
@@ -3499,8 +3780,7 @@
     ScrnInfoPtr pScrn = crtc->scrn;
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
     int height = 64, width = 64, i;
-    VIAPtr pVia = VIAPTR(pScrn);
-    CARD32 pixel, temp, *dst;
+    CARD32 pixel, *dst;
 
     if (xf86_config->cursor_fg)
         return;
@@ -3512,24 +3792,7 @@
     if (fg == xf86_config->cursor_fg && bg == xf86_config->cursor_bg)
         return;
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        temp = VIAGETREG(HI_CONTROL);
-        VIASETREG(HI_CONTROL, temp & 0xFFFFFFFE);
-        break;
-
-    default:
-        temp = VIAGETREG(HI_CONTROL);
-        VIASETREG(HI_CONTROL, temp & 0xFFFFFFFE);
-        height = width = 32;
-        break;
-    }
+    viaIGA2DisplayHI(pScrn, FALSE);
 
     dst = drm_bo_map(pScrn, iga->cursor_bo);
     for (i = 0; i < width * height; i++, dst++)
@@ -3545,7 +3808,6 @@
 iga2_crtc_set_cursor_position(xf86CrtcPtr crtc, int x, int y)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
     unsigned xoff, yoff;
 
     if (x < 0) {
@@ -3562,78 +3824,58 @@
         yoff = 0;
     }
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        VIASETREG(HI_POSSTART,    ((x    << 16) | (y    & 0x07ff)));
-        VIASETREG(HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07ff)));
-        break;
-
-    default:
-        VIASETREG(HI_POSSTART,    ((x    << 16) | (y    & 0x07ff)));
-        VIASETREG(HI_CENTEROFFSET, ((xoff << 16) | (yoff & 0x07ff)));
-        break;
-    }
+    viaIGA2SetHIDisplayLocation(pScrn, x, xoff, y, yoff);
 }
 
 static void
 iga2_crtc_show_cursor(xf86CrtcPtr crtc)
 {
-    drmmode_crtc_private_ptr iga = crtc->driver_private;
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        VIASETREG(HI_FBOFFSET, iga->cursor_bo->offset);
-        VIASETREG(HI_CONTROL, 0xB6000005);
-        break;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered iga2_crtc_show_cursor.\n"));
+
+    viaIGA2DisplayHI(pScrn, TRUE);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting iga2_crtc_show_cursor.\n"));
 
-    default:
-        /* Mono Cursor Display Path [bit31]: Secondary */
-        /* FIXME For CLE266 and KM400 try to enable 32x32 cursor size [bit1] */
-        VIASETREG(HI_FBOFFSET, iga->cursor_bo->offset);
-        VIASETREG(HI_CONTROL, 0xF6000005);
-        break;
-    }
 }
 
 static void
 iga2_crtc_hide_cursor(xf86CrtcPtr crtc)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    CARD32 temp;
 
-    switch(pVia->Chipset) {
-    case VIA_PM800:
-    case VIA_CX700:
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-	    temp = VIAGETREG(HI_CONTROL);
-        VIASETREG(HI_CONTROL, temp & 0xFFFFFFFA);
-        break;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered iga2_crtc_hide_cursor.\n"));
 
-    default:
-        temp = VIAGETREG(HI_CONTROL);
-        /* Hardware cursor disable [bit0] */
-        VIASETREG(HI_CONTROL, temp & 0xFFFFFFFA);
-        break;
-	}
+    viaIGA2DisplayHI(pScrn, FALSE);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting iga2_crtc_hide_cursor.\n"));
+}
+
+static void
+iga2_crtc_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *image)
+{
+    drmmode_crtc_private_ptr iga = crtc->driver_private;
+    ScrnInfoPtr pScrn = crtc->scrn;
+    void *dst;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered iga2_crtc_load_cursor_argb.\n"));
+
+    dst = drm_bo_map(pScrn, iga->cursor_bo);
+    memset(dst, 0x00, iga->cursor_bo->size);
+    memcpy(dst, image, iga->cursor_bo->size);
+    drm_bo_unmap(pScrn, iga->cursor_bo);
+
+    viaIGA2InitHI(pScrn);
+    viaIGA2SetHIStartingAddress(crtc);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting iga2_crtc_load_cursor_argb.\n"));
 }
 
 const xf86CrtcFuncsRec iga2_crtc_funcs = {
@@ -3654,7 +3896,7 @@
     .set_cursor_position    = iga2_crtc_set_cursor_position,
     .show_cursor            = iga2_crtc_show_cursor,
     .hide_cursor            = iga2_crtc_hide_cursor,
-    .load_cursor_argb       = iga_crtc_load_cursor_argb,
+    .load_cursor_argb       = iga2_crtc_load_cursor_argb,
 #if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) > 2
     .set_origin             = iga2_crtc_set_origin,
 #endif
diff -ruN xf86-video-openchrome-0.5.0/src/via_driver.c xf86-video-openchrome/src/via_driver.c
--- xf86-video-openchrome-0.5.0/src/via_driver.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_driver.c	2016-09-09 20:39:48.261187092 +0300
@@ -179,7 +179,6 @@
     OPTION_TVDOTCRAWL,
     OPTION_TVTYPE,
     OPTION_TVOUTPUT,
-    OPTION_TVDIPORT,
     OPTION_DISABLEVQ,
     OPTION_DISABLEIRQ,
     OPTION_TVDEFLICKER,
@@ -209,7 +208,6 @@
     {OPTION_TVDEFLICKER,         "TVDeflicker",      OPTV_INTEGER, {0}, FALSE},
     {OPTION_TVTYPE,              "TVType",           OPTV_ANYSTR,  {0}, FALSE},
     {OPTION_TVOUTPUT,            "TVOutput",         OPTV_ANYSTR,  {0}, FALSE},
-    {OPTION_TVDIPORT,            "TVPort",           OPTV_ANYSTR,  {0}, FALSE},
     {OPTION_DISABLEVQ,           "DisableVQ",        OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_DISABLEIRQ,          "DisableIRQ",       OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_AGP_DMA,             "EnableAGPDMA",     OPTV_BOOLEAN, {0}, FALSE},
@@ -660,17 +658,13 @@
     pVia->swov.maxWInterp = 800;
     pVia->swov.maxHInterp = 600;
 
-    pBIOSInfo->TVDIPort = VIA_DI_PORT_DVP1;
-
     switch (pVia->Chipset) {
         case VIA_CLE266:
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DVP0;
             break;
         case VIA_KM400:
             /* IRQ is not broken on KM400A, but testing (pVia->ChipRev < 0x80)
              * is not enough to make sure we have an older, broken KM400. */
             pVia->DRIIrqEnable = FALSE;
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DVP0;
             break;
         case VIA_K8M800:
             pVia->DRIIrqEnable = FALSE;
@@ -699,7 +693,6 @@
             pVia->agpEnable = FALSE;
             /* FIXME: this needs to be tested */
             pVia->dmaXV = FALSE;
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DVP0;
             break;
         case VIA_VX800:
         case VIA_VX855:
@@ -1450,30 +1443,6 @@
                    "No default TV output signal type is set.\n");
     }
 
-    /* TV DI Port */
-    if ((s = xf86GetOptValString(VIAOptions, OPTION_TVDIPORT))) {
-        if (!xf86NameCmp(s, "DVP0")) {
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DVP0;
-            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-                       "TV Output Port is DVP0.\n");
-        } else if (!xf86NameCmp(s, "DVP1")) {
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DVP1;
-            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-                       "TV Output Port is DVP1.\n");
-        } else if (!xf86NameCmp(s, "DFPHigh")) {
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DFPHIGH;
-            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-                       "TV Output Port is DFPHigh.\n");
-        } else if (!xf86NameCmp(s, "DFPLow")) {
-            pBIOSInfo->TVDIPort = VIA_DI_PORT_DFPLOW;
-            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-                       "TV Output Port is DFPLow.\n");
-        }
-    } else {
-        xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT,
-                   "No default TV output port is set.\n");
-    }
-
     VIAVidHWDiffInit(pScrn);
 
 #ifdef HAVE_DEBUG
diff -ruN xf86-video-openchrome-0.5.0/src/via_driver.h xf86-video-openchrome/src/via_driver.h
--- xf86-video-openchrome-0.5.0/src/via_driver.h	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_driver.h	2016-09-09 20:39:48.261515928 +0300
@@ -376,6 +376,15 @@
 #endif /* HAVE_DEBUG */
 
     video_via_regs*     VideoRegs;
+
+    /* Keeping track of the number of analog VGA connectors. */
+    unsigned int        numberVGA;
+
+    /* Keeping track of the number of DVI connectors. */
+    unsigned int        numberDVI;
+
+    /* Keeping track of the number of FP (Flat Panel) connectors. */
+    unsigned int        numberFP;
 } VIARec, *VIAPtr;
 
 #define VIAPTR(p) ((VIAPtr)((p)->driverPrivate))
@@ -498,6 +507,8 @@
 
 /* via_i2c.c */
 void ViaI2CInit(ScrnInfoPtr pScrn);
+Bool xf86I2CMaskByte(I2CDevPtr d, I2CByte subaddr,
+                        I2CByte value, I2CByte mask);
 
 #ifdef HAVE_DRI
 Bool VIADRI1ScreenInit(ScreenPtr pScreen);
diff -ruN xf86-video-openchrome-0.5.0/src/via_exa_h2.c xf86-video-openchrome/src/via_exa_h2.c
--- xf86-video-openchrome-0.5.0/src/via_exa_h2.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_exa_h2.c	2016-09-09 20:39:48.264702886 +0300
@@ -170,8 +170,6 @@
     VIAPtr pVia = VIAPTR(pScrn);
     ViaTwodContext *tdc = &pVia->td;
 
-    RING_VARS;
-
     if (exaGetPixmapPitch(pPixmap) & 7)
         return FALSE;
 
@@ -227,8 +225,6 @@
     VIAPtr pVia = VIAPTR(pScrn);
     ViaTwodContext *tdc = &pVia->td;
 
-    RING_VARS;
-
     if (pSrcPixmap->drawable.bitsPerPixel != pDstPixmap->drawable.bitsPerPixel)
         return FALSE;
 
diff -ruN xf86-video-openchrome-0.5.0/src/via_exa_h6.c xf86-video-openchrome/src/via_exa_h6.c
--- xf86-video-openchrome-0.5.0/src/via_exa_h6.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_exa_h6.c	2016-09-09 20:39:48.265048251 +0300
@@ -171,8 +171,6 @@
     VIAPtr pVia = VIAPTR(pScrn);
     ViaTwodContext *tdc = &pVia->td;
 
-    RING_VARS;
-
     if (exaGetPixmapPitch(pPixmap) & 7)
         return FALSE;
 
@@ -228,8 +226,6 @@
     VIAPtr pVia = VIAPTR(pScrn);
     ViaTwodContext *tdc = &pVia->td;
 
-    RING_VARS;
-
     if (pSrcPixmap->drawable.bitsPerPixel != pDstPixmap->drawable.bitsPerPixel)
         return FALSE;
 
diff -ruN xf86-video-openchrome-0.5.0/src/via_i2c.c xf86-video-openchrome/src/via_i2c.c
--- xf86-video-openchrome-0.5.0/src/via_i2c.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_i2c.c	2016-09-09 20:39:48.265291183 +0300
@@ -1,4 +1,5 @@
 /*
+ * Copyright 2009 Luc Verhaegen.
  * Copyright 2004 The Unichrome Project  [unichrome.sf.net]
  * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
  * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
@@ -478,3 +479,24 @@
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting ViaI2CInit.\n"));
 }
+
+/*
+ * The code originated from Luc Verhaegen's xf86-video-unichrome DDX.
+ *
+ * Sure, it is polluting namespace, but this one is quite useful.
+ */
+Bool
+xf86I2CMaskByte(I2CDevPtr d, I2CByte subaddr, I2CByte value, I2CByte mask)
+{
+    I2CByte tmp;
+    Bool ret;
+
+    ret = xf86I2CReadByte(d, subaddr, &tmp);
+    if (!ret)
+        return FALSE;
+
+    tmp &= ~mask;
+    tmp |= (value & mask);
+
+    return xf86I2CWriteByte(d, subaddr, tmp);
+}
diff -ruN xf86-video-openchrome-0.5.0/src/via_lvds.c xf86-video-openchrome/src/via_lvds.c
--- xf86-video-openchrome-0.5.0/src/via_lvds.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_lvds.c	2016-09-09 20:39:48.266510704 +0300
@@ -49,28 +49,34 @@
     {-1,                NULL,           OPTV_NONE,      {0},    FALSE}
 };
 
+/* These table values were copied from lcd.c of VIA Frame 
+ * Buffer device driver. */
+/* {int Width, int Height, bool useDualEdge, bool useDithering}; */
 static ViaPanelModeRec ViaPanelNativeModes[] = {
-    {640, 480},
-    {800, 600},
-    {1024, 768},
-    {1280, 768},
-    {1280, 1024},
-    {1400, 1050},
-    {1600, 1200},   /* 0x6 */
-    {1280, 800},    /* 0x7 Resolution 1280x800 (Samsung NC20) */
-    {800, 480},     /* 0x8 For Quanta 800x480 */
-    {1024, 600},    /* 0x9 Resolution 1024x600 (for HP 2133) */
-    {1368, 768},    /* 0xA Resolution 1366x768 */
-    {1920, 1080},
-    {1920, 1200},
-    {1280, 1024},   /* 0xD */
-    {1440, 900},    /* 0xE */
-    {1280, 720},    /* 0xF 480x640 */
-    {1200, 900},   /* 0x10 For OLPC 1.5 */
-    {1360, 768},   /* 0x11 Resolution 1360X768 */
-    {1024, 768},   /* 0x12 Resolution 1024x768 */
-    {800, 480}     /* 0x13 General 8x4 panel use this setting */
-};
+    { 640,  480, FALSE,  TRUE},
+    { 800,  600, FALSE,  TRUE},
+    {1024,  768, FALSE,  TRUE},
+    {1280,  768, FALSE,  TRUE},
+    {1280, 1024,  TRUE,  TRUE},
+    {1400, 1050,  TRUE,  TRUE},
+    {1600, 1200,  TRUE,  TRUE},
+    {1280,  800, FALSE,  TRUE},
+    { 800,  480, FALSE,  TRUE},
+    {1024,  768,  TRUE,  TRUE},
+    {1024,  768, FALSE, FALSE},
+    {1024,  768,  TRUE, FALSE},
+    {1280,  768, FALSE, FALSE},
+    {1280, 1024,  TRUE, FALSE},
+    {1400, 1050,  TRUE, FALSE},
+    {1600, 1200,  TRUE, FALSE},
+    {1366,  768, FALSE, FALSE},
+    {1024,  600, FALSE,  TRUE},
+    {1280,  768,  TRUE,  TRUE},
+    {1280,  800, FALSE,  TRUE},
+    {1360,  768, FALSE, FALSE},
+    {1280,  768,  TRUE, FALSE},
+    { 480,  640, FALSE,  TRUE},
+    {1200,  900, FALSE, FALSE}};
 
 #define MODEPREFIX(name) NULL, NULL, name, 0, M_T_DRIVER | M_T_DEFAULT
 #define MODESUFFIX 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,FALSE,FALSE,0,NULL,0,0.0,0.0
@@ -99,6 +105,204 @@
 #define TD2 0
 #define TD3 25
 
+/*
+ * Sets IGA1 or IGA2 as the display output source for VIA Technologies
+ * Chrome IGP LVDS1 integrated LVDS transmitter.
+ */
+static void
+viaLVDS1SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 temp = displaySource;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaLVDS1SetDisplaySource.\n"));
+
+    /* Set LVDS1 integrated LVDS transmitter display output source. */
+    /* 3X5.99[4] - LVDS Channel 1 Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x99, temp << 4, 0x10);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "LVDS1 Integrated LVDS Transmitter Display Output "
+                "Source: IGA%d\n",
+                (temp & 0x01) + 1);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaLVDS1SetDisplaySource.\n"));
+}
+
+/*
+ * Sets IGA1 or IGA2 as the display output source for VIA Technologies
+ * Chrome IGP LVDS2 integrated LVDS transmitter.
+ */
+static void
+viaLVDS2SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 temp = displaySource;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaLVDS2SetDisplaySource.\n"));
+
+    /* Set LVDS2 integrated LVDS transmitter display output source. */
+    /* 3X5.97[4] - LVDS Channel 2 Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x97, temp << 4, 0x10);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "LVDS2 Integrated LVDS Transmitter Display Output "
+                "Source: IGA%d\n",
+                (temp & 0x01) + 1);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaLVDS2SetDisplaySource.\n"));
+}
+
+/*
+ * Sets LVDS2 (LVDS Channel 2) integrated LVDS transmitter delay tap.
+ */
+static void
+viaLVDS2SetDelayTap(ScrnInfoPtr pScrn, CARD8 delayTap)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaLVDS2SetDelayTap.\n"));
+
+    /* Set LVDS2 delay tap. */
+    /* 3X5.97[3:0] - LVDS2 Delay Tap */
+    ViaCrtcMask(hwp, 0x97, delayTap, 0x0F);
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "LVDS2 Delay Tap: %d\n",
+                (delayTap & 0x0F));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaLVDS2SetDelayTap.\n"));
+}
+
+/*
+ * Sets IGA1 or IGA2 as the display output source for VIA Technologies
+ * Chrome IGP DFP (Digital Flat Panel) High interface.
+ */
+static void
+viaDFPHighSetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 temp = displaySource;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaDFPHighSetDisplaySource.\n"));
+
+    /* Set DFP High display output source. */
+    /* 3X5.97[4] - DFP High Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x97, temp << 4, 0x10);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DFP High Display Output Source: IGA%d\n",
+                (temp & 0x01) + 1);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaDFPHighSetDisplaySource.\n"));
+}
+
+/*
+ * Sets DFP (Digital Flat Panel) Low interface delay tap.
+ */
+static void
+viaDFPLowSetDelayTap(ScrnInfoPtr pScrn, CARD8 delayTap)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaDFPLowSetDelayTap.\n"));
+
+    /* Set DFP Low interface delay tap. */
+    /* 3X5.99[3:0] - DFP Low Delay Tap */
+    ViaCrtcMask(hwp, 0x99, delayTap, 0x0F);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DFP Low Delay Tap: %d\n",
+                (delayTap & 0x0F));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaDFPLowSetDelayTap.\n"));
+}
+
+/*
+ * Sets DFP (Digital Flat Panel) High interface delay tap.
+ */
+static void
+viaDFPHighSetDelayTap(ScrnInfoPtr pScrn, CARD8 delayTap)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaDFPHighSetDelayTap.\n"));
+
+    /* Set DFP High interface delay tap. */
+    /* 3X5.97[3:0] - DFP High Delay Tap */
+    ViaCrtcMask(hwp, 0x97, delayTap, 0x0F);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DFP High Delay Tap: %d\n",
+                (delayTap & 0x0F));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaDFPHighSetDelayTap.\n"));
+}
+
+/*
+ * Turns LVDS2 output color dithering on or off. (18-bit color display vs.
+ * 24-bit color display)
+ */
+static void
+viaLVDS2SetDithering(ScrnInfoPtr pScrn, CARD8 ditheringStatus)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaLVDS2SetDithering.\n"));
+
+    /* Set LVDS2 output color dithering bit. */
+    /* 3X5.D4[6] - LVDS Channel 2 Output Bits
+     *             0: 24 bits (dithering off)
+     *             1: 18 bits (dithering on) */
+    ViaCrtcMask(hwp, 0xD4, ditheringStatus ? 0x40 : 0x00, 0x40);
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "LVDS2 Output Color Dithering: %s\n",
+                ditheringStatus ? "On (18-bit)" : "Off (24-bit)");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaLVDS2SetDithering.\n"));
+}
+
+/*
+ * Sets output format of LVDS2 to rotation or sequential mode.
+ */
+static void
+viaLVDS2SetOutputFormat(ScrnInfoPtr pScrn, CARD8 outputFormat)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaLVDS2SetOutputFormat.\n"));
+
+    /* Set LVDS2 output format. */
+    /* 3X5.D4[7] - LVDS Channel 2 Output Format
+     *             0: Rotation
+     *             1: Sequential */
+    ViaCrtcMask(hwp, 0xD4, outputFormat ? 0x80 : 0x00, 0x80);
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "LVDS2 Output Format: %s\n",
+                outputFormat ? "Sequential" : "Rotation");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaLVDS2SetOutputFormat.\n"));
+}
+
 static void
 ViaLVDSSoftwarePowerFirstSequence(ScrnInfoPtr pScrn, Bool on)
 {
@@ -255,20 +459,48 @@
 static void
 ViaLVDSPower(ScrnInfoPtr pScrn, Bool Power_On)
 {
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
     VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 crd2;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered ViaLVDSPower.\n"));
+
     /*
      * VX800, CX700 have HW issue, so we'd better use SW power sequence
      * Fix Ticket #308
      */
     switch (pVia->Chipset) {
-    case VIA_VX800:
     case VIA_CX700:
-        ViaLVDSSoftwarePowerFirstSequence(pScrn, Power_On);
+    case VIA_VX800:
+
+        /* Is the integrated TMDS transmitter (DVI) not in use? */
+        crd2 = hwp->readCrtc(hwp, 0xD2);
+        if (((pVia->Chipset == VIA_CX700)
+                || (pVia->Chipset == VIA_VX800)
+                || (pVia->Chipset == VIA_VX855)
+                || (pVia->Chipset == VIA_VX900))
+            && (!(crd2 & 0x10))) {
+            ViaLVDSSoftwarePowerFirstSequence(pScrn, Power_On);
+        }
+
         ViaLVDSSoftwarePowerSecondSequence(pScrn, Power_On);
         break;
+
+    case VIA_VX855:
+    case VIA_VX900:
+        /* Is the integrated TMDS transmitter (DVI) not in use? */
+        crd2 = hwp->readCrtc(hwp, 0xD2);
+        if (((pVia->Chipset == VIA_CX700)
+                || (pVia->Chipset == VIA_VX800)
+                || (pVia->Chipset == VIA_VX855)
+                || (pVia->Chipset == VIA_VX900))
+            && (!(crd2 & 0x10))) {
+            ViaLVDSHardwarePowerFirstSequence(pScrn, Power_On);
+        }
+
+        ViaLVDSHardwarePowerSecondSequence(pScrn, Power_On);
+        break;
     default:
         ViaLVDSHardwarePowerFirstSequence(pScrn, Power_On);
         ViaLVDSHardwarePowerSecondSequence(pScrn, Power_On);
@@ -286,26 +518,6 @@
 }
 
 static void
-via_lvds_create_resources(xf86OutputPtr output)
-{
-}
-
-#ifdef RANDR_12_INTERFACE
-static Bool
-via_lvds_set_property(xf86OutputPtr output, Atom property,
-						RRPropertyValuePtr value)
-{
-    return FALSE;
-}
-
-static Bool
-via_lvds_get_property(xf86OutputPtr output, Atom property)
-{
-    return FALSE;
-}
-#endif
-
-static void
 ViaLCDPowerSequence(vgaHWPtr hwp, VIALCDPowerSeqRec Sequence)
 {
     int i;
@@ -369,54 +581,6 @@
                         "Exiting ViaLCDPower.\n"));
 }
 
-static void
-via_lvds_dpms(xf86OutputPtr output, int mode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-
-    switch (mode) {
-    case DPMSModeOn:
-        switch (pVia->Chipset) {
-        case VIA_P4M900:
-        case VIA_CX700:
-        case VIA_VX800:
-        case VIA_VX855:
-        case VIA_VX900:
-            ViaLVDSPower(pScrn, TRUE);
-            break;
-        }
-        ViaLCDPower(output, TRUE);
-        break;
-
-    case DPMSModeStandby:
-    case DPMSModeSuspend:
-    case DPMSModeOff:
-        switch (pVia->Chipset) {
-        case VIA_P4M900:
-        case VIA_CX700:
-        case VIA_VX800:
-        case VIA_VX855:
-        case VIA_VX900:
-            ViaLVDSPower(pScrn, FALSE);
-            break;
-        }
-        ViaLCDPower(output, FALSE);
-        break;
-    }
-}
-
-static void
-via_lvds_save(xf86OutputPtr output)
-{
-}
-
-static void
-via_lvds_restore(xf86OutputPtr output)
-{
-    ViaLCDPower(output, TRUE);
-}
-
 /*
  * Try to interpret EDID ourselves.
  */
@@ -527,73 +691,44 @@
     return TRUE;
 }
 
-static Bool
-ViaGetResolutionIndex(ScrnInfoPtr pScrn, ViaPanelInfoPtr Panel,
-                      DisplayModePtr mode)
-{
-    int i;
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                     "ViaGetResolutionIndex: Looking for %dx%d\n",
-                     mode->CrtcHDisplay, mode->CrtcVDisplay));
-    for (i = 0; ViaResolutionTable[i].Index != VIA_RES_INVALID; i++) {
-        if ((ViaResolutionTable[i].X == mode->CrtcHDisplay)
-            && (ViaResolutionTable[i].Y == mode->CrtcVDisplay)) {
-            Panel->ResolutionIndex = ViaResolutionTable[i].Index;
-            DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaGetResolutionIndex:"
-                             " %d\n", Panel->ResolutionIndex));
-            return TRUE;
-        }
-    }
-
-    Panel->ResolutionIndex = VIA_RES_INVALID;
-    return FALSE;
-}
-
 /*
  * Gets the native panel resolution from scratch pad registers.
  */
 static void
-ViaPanelGetNativeModeFromScratchPad(xf86OutputPtr output)
+viaLVDSGetFPInfoFromScratchPad(xf86OutputPtr output)
 {
-    ViaPanelInfoPtr panel = output->driver_private;
     ScrnInfoPtr pScrn = output->scrn;
     vgaHWPtr hwp = VGAHWPTR(pScrn);
+    ViaPanelInfoPtr panel = output->driver_private;
     CARD8 index;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                     "ViaPanelGetNativeModeFromScratchPad\n"));
+                     "Entered viaLVDSGetFPInfoFromScratchPad.\n"));
 
     index = hwp->readCrtc(hwp, 0x3F) & 0x0F;
 
     panel->NativeModeIndex = index;
     panel->NativeWidth = ViaPanelNativeModes[index].Width;
     panel->NativeHeight = ViaPanelNativeModes[index].Height;
+    panel->useDualEdge = ViaPanelNativeModes[index].useDualEdge;
+    panel->useDithering = ViaPanelNativeModes[index].useDithering;
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+               "VIA Technologies VGA BIOS Scratch Pad Register "
+               "Flat Panel Index: %d\n",
+               panel->NativeModeIndex);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-               "Native Panel Resolution is %dx%d\n",
+               "Flat Panel Native Resolution: %dx%d\n",
                panel->NativeWidth, panel->NativeHeight);
-}
-
-static int
-via_lvds_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-
-    ViaPanelInfoPtr Panel = output->driver_private;
-
-    if (Panel->NativeWidth < pMode->HDisplay ||
-        Panel->NativeHeight < pMode->VDisplay)
-        return MODE_PANEL;
-
-    if (!Panel->Scale && Panel->NativeHeight != pMode->VDisplay &&
-         Panel->NativeWidth != pMode->HDisplay)
-        return MODE_PANEL;
-
-    if (!ViaModeDotClockTranslate(pScrn, pMode))
-        return MODE_NOCLOCK;
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+               "Flat Panel Dual Edge Transfer: %s\n",
+               panel->useDualEdge ? "On" : "Off");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+               "Flat Panel Output Color Dithering: %s\n",
+               panel->useDithering ? "On (18-bit)" : "Off (24-bit)");
 
-    return MODE_OK;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                     "Exiting viaLVDSGetFPInfoFromScratchPad.\n"));
 }
 
 static void
@@ -627,47 +762,6 @@
     adjusted_mode->CrtcVSyncEnd = adjusted_mode->VSyncEnd;
 }
 
-static Bool
-via_lvds_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
-					DisplayModePtr adjusted_mode)
-{
-    ViaPanelInfoPtr Panel = output->driver_private;
-
-    xf86SetModeCrtc(adjusted_mode, 0);
-    if (!Panel->Center && (mode->HDisplay < Panel->NativeWidth ||
-        mode->VDisplay < Panel->NativeHeight)) {
-        Panel->Scale = TRUE;
-    } else {
-        Panel->Scale = FALSE;
-        ViaPanelCenterMode(mode, adjusted_mode);
-    }
-    return TRUE;
-}
-
-static void
-via_lvds_prepare(xf86OutputPtr output)
-{
-    via_lvds_dpms(output, DPMSModeOff);
-
-    if (output->crtc) {
-        drmmode_crtc_private_ptr iga = output->crtc->driver_private;
-        CARD8 value = 0x00; /* Value for IGA 1 */
-        ScrnInfoPtr pScrn = output->scrn;
-        vgaHWPtr hwp = VGAHWPTR(pScrn);
-
-        /* IGA 2 */
-        if (iga->index)
-            value = 0x10;
-        ViaCrtcMask(hwp, 0x99, value, value);
-    }
-}
-
-static void
-via_lvds_commit(xf86OutputPtr output)
-{
-    via_lvds_dpms(output, DPMSModeOn);
-}
-
 static void
 ViaPanelScale(ScrnInfoPtr pScrn, int resWidth, int resHeight,
               int panelWidth, int panelHeight)
@@ -771,11 +865,152 @@
 }
 
 static void
+viaSetLVDSOutput(ScrnInfoPtr pScrn)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSetLVDSOutput.\n"));
+
+    switch (pVia->Chipset) {
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* Do not power down LVDS Channel 2. */
+        /* For now, use OPENLDI mode for LVDS Channel 2. */
+        ViaCrtcMask(hwp, 0xD2, 0x01, 0x41);
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSetLVDSOutput.\n"));
+}
+
+static void
+via_lvds_create_resources(xf86OutputPtr output)
+{
+}
+
+static void
+via_lvds_dpms(xf86OutputPtr output, int mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    switch (mode) {
+    case DPMSModeOn:
+        switch (pVia->Chipset) {
+        case VIA_PM800:
+        case VIA_P4M800PRO:
+        case VIA_P4M890:
+        case VIA_K8M890:
+        case VIA_P4M900:
+        case VIA_CX700:
+        case VIA_VX800:
+        case VIA_VX855:
+        case VIA_VX900:
+            ViaLVDSPower(pScrn, TRUE);
+            break;
+        default:
+            ViaLCDPower(output, TRUE);
+            break;
+        }
+
+        break;
+
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+    case DPMSModeOff:
+        switch (pVia->Chipset) {
+        case VIA_PM800:
+        case VIA_P4M800PRO:
+        case VIA_P4M890:
+        case VIA_K8M890:
+        case VIA_P4M900:
+        case VIA_CX700:
+        case VIA_VX800:
+        case VIA_VX855:
+        case VIA_VX900:
+            ViaLVDSPower(pScrn, FALSE);
+            break;
+        default:
+            ViaLCDPower(output, FALSE);
+            break;
+        }
+
+        break;
+    }
+}
+
+static void
+via_lvds_save(xf86OutputPtr output)
+{
+}
+
+static void
+via_lvds_restore(xf86OutputPtr output)
+{
+    ViaLCDPower(output, TRUE);
+}
+
+static int
+via_lvds_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    ViaPanelInfoPtr Panel = output->driver_private;
+
+    if (Panel->NativeWidth < pMode->HDisplay ||
+        Panel->NativeHeight < pMode->VDisplay)
+        return MODE_PANEL;
+
+    if (!Panel->Scale && Panel->NativeHeight != pMode->VDisplay &&
+         Panel->NativeWidth != pMode->HDisplay)
+        return MODE_PANEL;
+
+    if (!ViaModeDotClockTranslate(pScrn, pMode))
+        return MODE_NOCLOCK;
+
+    return MODE_OK;
+}
+
+static Bool
+via_lvds_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
+                    DisplayModePtr adjusted_mode)
+{
+    ViaPanelInfoPtr Panel = output->driver_private;
+
+    xf86SetModeCrtc(adjusted_mode, 0);
+    if (!Panel->Center && (mode->HDisplay < Panel->NativeWidth ||
+        mode->VDisplay < Panel->NativeHeight)) {
+        Panel->Scale = TRUE;
+    } else {
+        Panel->Scale = FALSE;
+        ViaPanelCenterMode(mode, adjusted_mode);
+    }
+    return TRUE;
+}
+
+static void
+via_lvds_prepare(xf86OutputPtr output)
+{
+    via_lvds_dpms(output, DPMSModeOff);
+}
+
+static void
+via_lvds_commit(xf86OutputPtr output)
+{
+    via_lvds_dpms(output, DPMSModeOn);
+}
+
+static void
 via_lvds_mode_set(xf86OutputPtr output, DisplayModePtr mode,
-					DisplayModePtr adjusted_mode)
+                    DisplayModePtr adjusted_mode)
 {
     ViaPanelInfoPtr Panel = output->driver_private;
     ScrnInfoPtr pScrn = output->scrn;
+    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
     VIAPtr pVia = VIAPTR(pScrn);
 
     if (Panel->Scale) {
@@ -785,102 +1020,101 @@
     } else {
         ViaPanelScaleDisable(pScrn);
     }
-}
 
-static int
-ViaPanelLookUpModeIndex(int width, int height)
-{
-    int i, index = VIA_PANEL_INVALID;
-    int length = sizeof(ViaPanelNativeModes) / sizeof(ViaPanelModeRec);
+    if (output->crtc) {
+        viaSetLVDSOutput(pScrn);
+
+        switch (pVia->Chipset) {
+        case VIA_P4M900:
+            viaDFPLowSetDelayTap(pScrn, 0x08);
+            break;
+        case VIA_CX700:
+            viaLVDS2SetDelayTap(pScrn, 0x01);
+            break;
+        default:
+            break;
+        }
 
 
-    for (i = 0; i < length; i++) {
-        if (ViaPanelNativeModes[i].Width == width
-            && ViaPanelNativeModes[i].Height == height) {
-            index = i;
+        switch (pVia->Chipset) {
+        case VIA_KM400:
+        case VIA_K8M800:
+        case VIA_PM800:
+        case VIA_P4M800PRO:
+        case VIA_P4M890:
+        case VIA_K8M890:
+        case VIA_P4M900:
+            viaDFPLowSetDisplaySource(pScrn, iga->index ? 0x01 : 0x00);
+            viaDVP1SetDisplaySource(pScrn, iga->index ? 0x01 : 0x00);
+            break;
+        case VIA_CX700:
+        case VIA_VX800:
+        case VIA_VX855:
+        case VIA_VX900:
+            viaLVDS2SetDisplaySource(pScrn, iga->index ? 0x01 : 0x00);
+
+            /* Set LVDS2 output color dithering. */
+            viaLVDS2SetDithering(pScrn, Panel->useDithering ? TRUE : FALSE);
+
+            /* Set LVDS2 output format to sequential mode. */
+            viaLVDS2SetOutputFormat(pScrn, 0x01);
+            break;
+        default:
             break;
         }
     }
-    return index;
 }
 
 static xf86OutputStatus
 via_lvds_detect(xf86OutputPtr output)
 {
     xf86OutputStatus status = XF86OutputStatusDisconnected;
-    ViaPanelInfoPtr panel = output->driver_private;
     ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    CARD8 cr3b = 0x00;
-    CARD8 cr3b_mask = 0x00;
+    VIAPtr pVia = VIAPTR(pScrn);
+    ViaPanelInfoPtr panel = output->driver_private;
+    CARD8 cr3b;
+    CARD8 cr3b_mask;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered via_lvds_detect.\n"));
 
-    /* Hardcode panel size for the XO */
+    /* Hardcode panel size for the OLPC XO-1.5. */
     if (pVia->IsOLPCXO15) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "Setting up OLPC XO-1.5 flat panel.\n");
         panel->NativeWidth = 1200;
         panel->NativeHeight = 900;
         status = XF86OutputStatusConnected;
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                            "Setting up OLPC XO-1.5 flat panel.\n"));
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                            "Detected Flat Panel Screen Resolution: "
-                            "%dx%d\n",
-                            panel->NativeWidth, panel->NativeHeight));
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_lvds_detect.\n"));
-        return status;
+        goto exit;
     }
 
-    if (!panel->NativeWidth || !panel->NativeHeight) {
-        int width, height;
-        Bool ret;
-
-        ret = ViaPanelGetSizeFromDDCv1(output, &width, &height);
-        if (ret) {
-            panel->NativeModeIndex = ViaPanelLookUpModeIndex(width, height);
-            DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                                "ViaPanelLookUpModeIndex: Width %d, "
-                                "Height %d, NativeModeIndex%d\n", 
-                                width, height, panel->NativeModeIndex));
-            if (panel->NativeModeIndex != VIA_PANEL_INVALID) {
-                panel->NativeWidth = width;
-                panel->NativeHeight = height;
-                status = XF86OutputStatusConnected;
-            }
+    /* Disable reading off EDID from I2C bus 2 since it is often
+     * used by DVI as well. For now, this is how DVI and LVDS FP will
+     * coexist. */
+/*
+    if (ViaPanelGetSizeFromDDCv1(output, &width, &height)) {
+*/
+    if (FALSE) {
+        status = XF86OutputStatusConnected;
+    } else {
+        /* Apparently this is the way VIA Technologies passes */
+        /* the presence of a flat panel to the device driver */
+        /* via BIOS setup. */
+        if (pVia->Chipset == VIA_CLE266) {
+            cr3b_mask = 0x08;
         } else {
-            /* Apparently this is the way VIA Technologies passes */
-            /* the presence of a flat panel to the device driver */
-            /* via BIOS setup. */
-            if (pVia->Chipset == VIA_CLE266) {
-                cr3b_mask = 0x08;
-            } else {
-                cr3b_mask = 0x02;
-            }            
-
-            cr3b = hwp->readCrtc(hwp, 0x3B) & cr3b_mask;
-
-            if (cr3b) {
-                ViaPanelGetNativeModeFromScratchPad(output);
-
-                if (panel->NativeWidth && panel->NativeHeight) {
-                    status = XF86OutputStatusConnected;
-                }
-            }
+            cr3b_mask = 0x02;
         }
 
-        if (status == XF86OutputStatusConnected) {
-            DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                                "Detected Flat Panel Screen Resolution: "
-                                "%dx%d\n",
-                                panel->NativeWidth, panel->NativeHeight));
+        cr3b = hwp->readCrtc(hwp, 0x3B) & cr3b_mask;
+        if (cr3b) {
+            viaLVDSGetFPInfoFromScratchPad(output);
+            status = XF86OutputStatusConnected;
         }
-    } else {
-        status = XF86OutputStatusConnected;
     }
 
+exit:
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting via_lvds_detect.\n"));
     return status;
@@ -947,6 +1181,21 @@
     return pDisplay_Mode;
 }
 
+#ifdef RANDR_12_INTERFACE
+static Bool
+via_lvds_set_property(xf86OutputPtr output, Atom property,
+                        RRPropertyValuePtr value)
+{
+    return FALSE;
+}
+
+static Bool
+via_lvds_get_property(xf86OutputPtr output, Atom property)
+{
+    return FALSE;
+}
+#endif
+
 static void
 via_lvds_destroy(xf86OutputPtr output)
 {
@@ -957,12 +1206,6 @@
 
 static const xf86OutputFuncsRec via_lvds_funcs = {
     .create_resources   = via_lvds_create_resources,
-#ifdef RANDR_12_INTERFACE
-    .set_property       = via_lvds_set_property,
-#endif
-#ifdef RANDR_13_INTERFACE
-    .get_property       = via_lvds_get_property,
-#endif
     .dpms               = via_lvds_dpms,
     .save               = via_lvds_save,
     .restore            = via_lvds_restore,
@@ -973,7 +1216,13 @@
     .mode_set           = via_lvds_mode_set,
     .detect             = via_lvds_detect,
     .get_modes          = via_lvds_get_modes,
-    .destroy            = via_lvds_destroy,
+#ifdef RANDR_12_INTERFACE
+    .set_property       = via_lvds_set_property,
+#endif
+#ifdef RANDR_13_INTERFACE
+    .get_property       = via_lvds_get_property,
+#endif
+    .destroy            = via_lvds_destroy
 };
 
 
@@ -983,12 +1232,12 @@
     ViaPanelInfoPtr Panel = (ViaPanelInfoPtr) xnfcalloc(sizeof(ViaPanelInfoRec), 1);
     OptionInfoPtr  Options = xnfalloc(sizeof(ViaPanelOptions));
     MessageType from = X_DEFAULT;
-    const char *s = NULL;
     VIAPtr pVia = VIAPTR(pScrn);
     xf86OutputPtr output = NULL;
     vgaHWPtr hwp = VGAHWPTR(pScrn);
     CARD8 cr3b = 0x00;
     CARD8 cr3b_mask = 0x00;
+    char outputNameBuffer[32];
 
     if (!Panel)
         return;
@@ -1020,19 +1269,27 @@
     xf86DrvMsg(pScrn->scrnIndex, from, "LVDS-0 : DVI Center is %s.\n",
                Panel->Center ? "enabled" : "disabled");
 
-    output = xf86OutputCreate(pScrn, &via_lvds_funcs, "LVDS-1");
+    /* The code to dynamically designate a particular FP (i.e., FP-1,
+     * FP-2, etc.) for xrandr was borrowed from xf86-video-r128 DDX. */
+    sprintf(outputNameBuffer, "FP-%d", (pVia->numberFP + 1));
+    output = xf86OutputCreate(pScrn, &via_lvds_funcs, outputNameBuffer);
 
     if (output)  {
         output->driver_private = Panel;
 
-        if (pVia->Chipset == VIA_VX900)
-            output->possible_crtcs = 0x3;
-        else
-            output->possible_crtcs = 0x2;
+        /* While there are two (2) display controllers registered with the
+         * X.Org Server, it is often desirable to fix FP (Flat Panel) to
+         * IGA2 since only IGA2 contains panel resolution scaling
+         * functionality. IGA1 does not have this. */
+        output->possible_crtcs = 1 << 1;
+
         output->possible_clones = 0;
         output->interlaceAllowed = FALSE;
         output->doubleScanAllowed = FALSE;
 
+        /* Increment the number of FP connectors. */
+        pVia->numberFP++;
+
         if (pVia->IsOLPCXO15) {
             output->mm_height = 152;
             output->mm_width = 114;
diff -ruN xf86-video-openchrome-0.5.0/src/via_memcpy.c xf86-video-openchrome/src/via_memcpy.c
--- xf86-video-openchrome-0.5.0/src/via_memcpy.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_memcpy.c	2016-09-09 20:39:48.266850402 +0300
@@ -528,7 +528,6 @@
     McFuncData *curData;
     FILE *cpuInfoFile;
     double cpuFreq;
-    VIAPtr pVia = VIAPTR(pScrn);
 
     if (NULL == (cpuInfoFile = fopen("/proc/cpuinfo", "r"))) {
         return libc_YUV42X;
diff -ruN xf86-video-openchrome-0.5.0/src/via_mode.h xf86-video-openchrome/src/via_mode.h
--- xf86-video-openchrome-0.5.0/src/via_mode.h	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_mode.h	2016-09-09 20:39:48.269261065 +0300
@@ -132,70 +132,6 @@
 #define VIA_RES_1200X900   23
 #define VIA_RES_INVALID  0xFF
 
-/*
- * simple lookuptable for PanelIndex selection
- */
-
-static struct {
-    int Index;
-    int PanelIndex;
-    int X;
-    int Y;
-} ViaResolutionTable[] = {
-    {VIA_RES_640X480,   VIA_PANEL6X4,       640,  480},
-    {VIA_RES_800X600,   VIA_PANEL8X6,       800,  600},
-    {VIA_RES_1024X768,  VIA_PANEL10X7,     1024,  768},
-    {VIA_RES_1152X864,  VIA_PANEL_INVALID, 1152,  864},
-    {VIA_RES_1280X1024, VIA_PANEL12X10,    1280, 1024},
-    {VIA_RES_1600X1200, VIA_PANEL16X12,    1600, 1200},
-    {VIA_RES_1440X1050, VIA_PANEL_INVALID, 1440, 1050},
-    {VIA_RES_1280X768,  VIA_PANEL12X7,     1280,  768},
-    {VIA_RES_1280X800,  VIA_PANEL12X8,     1280,  800},
-    {VIA_RES_1280X960,  VIA_PANEL_INVALID, 1280,  960},
- /* {VIA_RES_1920X1440, VIA_PANEL_INVALID, 1920, 1140}, */
-    {VIA_RES_848X480,   VIA_PANEL_INVALID,  848,  480},
-    {VIA_RES_1400X1050, VIA_PANEL14X10,    1400, 1050},
-    {VIA_RES_720X480,   VIA_PANEL_INVALID,  720,  480},
-    {VIA_RES_720X576,   VIA_PANEL_INVALID,  720,  576},
-    {VIA_RES_1024X512,  VIA_PANEL_INVALID, 1024,  512},
-    {VIA_RES_856X480,   VIA_PANEL_INVALID,  856,  480},
-    {VIA_RES_1024X576,  VIA_PANEL_INVALID, 1024,  576},
-    {VIA_RES_800X480,   VIA_PANEL8X4,	    800,  480},
-    {VIA_RES_1200X900,  VIA_PANEL12X9,     1200,  900},
-    {VIA_RES_INVALID,   VIA_PANEL_INVALID,    0,    0}
-};
-
-static struct {
-    CARD16 Width;
-    CARD16 Height;
-    CARD8  mode_8b;
-    CARD8  mode_16b;
-    CARD8  mode_32b;
-} ViaVesaModes[] = {
-    {  400,  300, 0x22, 0x23, 0x24 },
-    {  512,  384, 0x25, 0x26, 0x27 },
-    {  640,  400, 0x30, 0x2E, 0x2F },
-    {  640,  480, 0x31, 0x33, 0x34 },
-    {  800,  600, 0x36, 0x38, 0x39 },
-    { 1024,  768, 0x3B, 0x3D, 0x3E },
-    { 1152,  864, 0x40, 0x42, 0x43 },
-    { 1280, 1024, 0x45, 0x47, 0x48 },
-    { 1600, 1200, 0x4A, 0x4C, 0x4D },
-    { 1440, 1050, 0x50, 0x52, 0x53 },
-    { 1280,  768, 0x54, 0x56, 0x57 },
-    { 1280,  960, 0x58, 0x5A, 0x5B },
-    {  320,  200, 0x5C, 0x5D, 0x5E },
-    { 1920, 1440, 0x60, 0x61, 0x62 },
-    {  848,  480, 0x63, 0x64, 0x65 },
-    { 1400, 1050, 0x66, 0x67, 0x68 },
-    {  720,  480, 0x70, 0x71, 0x72 },
-    {  720,  576, 0x73, 0x74, 0x75 },
-    { 1024,  512, 0x76, 0x77, 0x78 },
-    {  856,  480, 0x79, 0x7A, 0x7B },
-    {  320,  240, 0x7C, 0x7D, 0x7E },
-    {    0,    0,    0,    0,    0 },
-};
-
 #define     VIA_BIOS_REG_LCD_MAX_NUM        48
 #define     VIA_BIOS_NUM_LCD_SUPPORT_MASK   8
 #define     VIA_BIOS_NUM_PANEL              7
diff -ruN xf86-video-openchrome-0.5.0/src/via_outputs.c xf86-video-openchrome/src/via_outputs.c
--- xf86-video-openchrome-0.5.0/src/via_outputs.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_outputs.c	2016-09-09 20:39:48.269696313 +0300
@@ -46,1030 +46,221 @@
  */
 #include "via_mode.h"
 
-static void
-ViaPrintMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
-{
-    xf86PrintModeline(pScrn->scrnIndex, mode);
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHDisplay: 0x%x\n",
-               mode->CrtcHDisplay);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHBlankStart: 0x%x\n",
-               mode->CrtcHBlankStart);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHSyncStart: 0x%x\n",
-               mode->CrtcHSyncStart);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHSyncEnd: 0x%x\n",
-               mode->CrtcHSyncEnd);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHBlankEnd: 0x%x\n",
-               mode->CrtcHBlankEnd);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHTotal: 0x%x\n",
-               mode->CrtcHTotal);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcHSkew: 0x%x\n",
-               mode->CrtcHSkew);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVDisplay: 0x%x\n",
-               mode->CrtcVDisplay);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVBlankStart: 0x%x\n",
-               mode->CrtcVBlankStart);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVSyncStart: 0x%x\n",
-               mode->CrtcVSyncStart);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVSyncEnd: 0x%x\n",
-               mode->CrtcVSyncEnd);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVBlankEnd: 0x%x\n",
-               mode->CrtcVBlankEnd);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CrtcVTotal: 0x%x\n",
-               mode->CrtcVTotal);
-
-}
-
 /*
- *
- * TV specific code.
- *
+ * Sets IGA1 or IGA2 as the display output source for DIP0
+ * (Digital Interface Port 0) interface for CLE266 only.
  */
 void
-ViaTVSave(ScrnInfoPtr pScrn)
-{
-    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
-
-    if (pBIOSInfo->TVSave)
-        pBIOSInfo->TVSave(pScrn);
-}
-
-void
-ViaTVRestore(ScrnInfoPtr pScrn)
-{
-    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
-
-    if (pBIOSInfo->TVRestore)
-        pBIOSInfo->TVRestore(pScrn);
-}
-
-static Bool
-ViaTVDACSense(ScrnInfoPtr pScrn)
-{
-    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
-
-    if (pBIOSInfo->TVDACSense)
-        return pBIOSInfo->TVDACSense(pScrn);
-    return FALSE;
-}
-
-static void
-ViaTVSetMode(xf86CrtcPtr crtc, DisplayModePtr mode)
-{
-    ScrnInfoPtr pScrn = crtc->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
-
-    if (pBIOSInfo->TVModeI2C)
-        pBIOSInfo->TVModeI2C(pScrn, mode);
-
-    if (pBIOSInfo->TVModeCrtc)
-        pBIOSInfo->TVModeCrtc(crtc, mode);
-
-    /* TV reset. */
-    xf86I2CWriteByte(pBIOSInfo->TVI2CDev, 0x1D, 0x00);
-    xf86I2CWriteByte(pBIOSInfo->TVI2CDev, 0x1D, 0x80);
-}
-
-void
-ViaTVPower(ScrnInfoPtr pScrn, Bool On)
-{
-    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
-
-#ifdef HAVE_DEBUG
-    if (On)
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaTVPower: On.\n");
-    else
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaTVPower: Off.\n");
-#endif
-
-    if (pBIOSInfo->TVPower)
-        pBIOSInfo->TVPower(pScrn, On);
-}
-
-#ifdef HAVE_DEBUG
-void
-ViaTVPrintRegs(ScrnInfoPtr pScrn)
-{
-    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
-
-    if (pBIOSInfo->TVPrintRegs)
-        pBIOSInfo->TVPrintRegs(pScrn);
-}
-#endif /* HAVE_DEBUG */
-
-static void
-via_tv_create_resources(xf86OutputPtr output)
-{
-}
-
-#ifdef RANDR_12_INTERFACE
-static Bool
-via_tv_set_property(xf86OutputPtr output, Atom property,
-                    RRPropertyValuePtr value)
-{
-    return TRUE;
-}
-
-static Bool
-via_tv_get_property(xf86OutputPtr output, Atom property)
-{
-    return FALSE;
-}
-#endif
-
-static void
-via_tv_dpms(xf86OutputPtr output, int mode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-
-    switch (mode) {
-    case DPMSModeOn:
-        ViaTVPower(pScrn, TRUE);
-        break;
-
-    case DPMSModeStandby:
-    case DPMSModeSuspend:
-    case DPMSModeOff:
-        ViaTVPower(pScrn, FALSE);
-        break;
-    }
-}
-
-static void
-via_tv_save(xf86OutputPtr output)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-
-    ViaTVSave(pScrn);
-}
-
-static void
-via_tv_restore(xf86OutputPtr output)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-
-    ViaTVRestore(pScrn);
-}
-
-static int
-via_tv_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    int ret = MODE_OK;
-
-    if (!ViaModeDotClockTranslate(pScrn, pMode))
-        return MODE_NOCLOCK;
-
-    return ret;
-}
-
-static Bool
-via_tv_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
-                  DisplayModePtr adjusted_mode)
-{
-    return TRUE;
-}
-
-static void
-via_tv_prepare(xf86OutputPtr output)
-{
-    via_tv_dpms(output, DPMSModeOff);
-}
-
-static void
-via_tv_commit(xf86OutputPtr output)
-{
-    via_tv_dpms(output, DPMSModeOn);
-}
-
-static void
-ViaDisplayEnableDVO(ScrnInfoPtr pScrn, int port)
-{
-    vgaHWPtr hwp = VGAHWPTR(pScrn);
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaDisplayEnableDVO, port: %d\n",
-                     port));
-    switch (port) {
-    case VIA_DI_PORT_DVP0:
-        ViaSeqMask(hwp, 0x1E, 0xC0, 0xC0);
-        break;
-    case VIA_DI_PORT_DVP1:
-        ViaSeqMask(hwp, 0x1E, 0x30, 0x30);
-        break;
-    }
-}
-
-static void
-ViaDisplayDisableDVO(ScrnInfoPtr pScrn, int port)
-{
-    vgaHWPtr hwp = VGAHWPTR(pScrn);
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaDisplayDisableDVO, port: %d\n",
-                     port));
-    switch (port) {
-    case VIA_DI_PORT_DVP0:
-        ViaSeqMask(hwp, 0x1E, 0x00, 0xC0);
-        break;
-    case VIA_DI_PORT_DVP1:
-        ViaSeqMask(hwp, 0x1E, 0x00, 0x30);
-        break;
-    }
-}
-
-static void
-ViaDisplaySetStreamOnDVO(ScrnInfoPtr pScrn, int port, int iga)
+viaDIP0SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
 {
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    int regNum;
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaDisplaySetStreamOnDVO, port: %d\n",
-                     port));
-
-    switch (port) {
-        case VIA_DI_PORT_DVP0:
-            regNum = 0x96;
-            break;
-        case VIA_DI_PORT_DVP1:
-            regNum = 0x9B;
-            break;
-        case VIA_DI_PORT_DFPLOW:
-            regNum = 0x97;
-            break;
-        case VIA_DI_PORT_DFPHIGH:
-            regNum = 0x99;
-            break;
-    }
-
-    if (!iga)
-        ViaCrtcMask(hwp, regNum, 0x00, 0x10);
-    else
-        ViaCrtcMask(hwp, regNum, 0x10, 0x10);
-}
-
-static void
-via_tv_mode_set(xf86OutputPtr output, DisplayModePtr mode,
-                DisplayModePtr adjusted_mode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
-
-    /* TV on FirstCrtc */
-    if (output->crtc) {
-        drmmode_crtc_private_ptr iga = output->crtc->driver_private;
-
-        ViaDisplaySetStreamOnDVO(pScrn, pBIOSInfo->TVDIPort, iga->index);
-    }
-    ViaDisplayEnableDVO(pScrn, pBIOSInfo->TVDIPort);
-
-    ViaTVSetMode(output->crtc, adjusted_mode);
-
-    pVia->FirstInit = FALSE;
-}
-
-static xf86OutputStatus
-via_tv_detect(xf86OutputPtr output)
-{
-    xf86OutputStatus status = XF86OutputStatusDisconnected;
-    ScrnInfoPtr pScrn = output->scrn;
-
-    if (ViaTVDACSense(pScrn))
-        status = XF86OutputStatusConnected;
-    return status;
-}
-
-static DisplayModePtr
-via_tv_get_modes(xf86OutputPtr output)
-{
-    DisplayModePtr modes = NULL, mode = NULL;
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    int i;
-
-    for (i = 0; i < pVia->pBIOSInfo->TVNumModes; i++) {
-        mode = xf86DuplicateMode(&pVia->pBIOSInfo->TVModes[i]);
-        modes = xf86ModesAdd(modes, mode);
-    }
-    return modes;
-}
-
-static void
-via_tv_destroy(xf86OutputPtr output)
-{
-}
-
-static const xf86OutputFuncsRec via_tv_funcs = {
-    .create_resources   = via_tv_create_resources,
-#ifdef RANDR_12_INTERFACE
-    .set_property       = via_tv_set_property,
-#endif
-#ifdef RANDR_13_INTERFACE
-    .get_property       = via_tv_get_property,
-#endif
-    .dpms               = via_tv_dpms,
-    .save               = via_tv_save,
-    .restore            = via_tv_restore,
-    .mode_valid         = via_tv_mode_valid,
-    .mode_fixup         = via_tv_mode_fixup,
-    .prepare            = via_tv_prepare,
-    .commit             = via_tv_commit,
-    .mode_set           = via_tv_mode_set,
-    .detect             = via_tv_detect,
-    .get_modes          = via_tv_get_modes,
-    .destroy            = via_tv_destroy,
-};
-
-/*
- *
- */
-static Bool
-via_tv_init(ScrnInfoPtr pScrn)
-{
-    VIAPtr pVia = VIAPTR(pScrn);
-    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
-    xf86OutputPtr output = NULL;
+    CARD8 temp = displaySource;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_tv_init.\n"));
-
-    /* preset some pBIOSInfo TV related values -- move up */
-    pBIOSInfo->TVEncoder = VIA_NONETV;
-    pBIOSInfo->TVI2CDev = NULL;
-    pBIOSInfo->TVSave = NULL;
-    pBIOSInfo->TVRestore = NULL;
-    pBIOSInfo->TVDACSense = NULL;
-    pBIOSInfo->TVModeValid = NULL;
-    pBIOSInfo->TVModeI2C = NULL;
-    pBIOSInfo->TVModeCrtc = NULL;
-    pBIOSInfo->TVPower = NULL;
-    pBIOSInfo->TVModes = NULL;
-    pBIOSInfo->TVPrintRegs = NULL;
-    pBIOSInfo->LCDPower = NULL;
-    pBIOSInfo->TVNumRegs = 0;
-
-    /*
-     * On an SK43G (KM400/Ch7011), false positive detections at a VT162x
-     * chip were observed, so try to detect the Ch7011 first.
-     */
-    if (pVia->pI2CBus2 && xf86I2CProbeAddress(pVia->pI2CBus2, 0xEC))
-        pBIOSInfo->TVI2CDev = ViaCH7xxxDetect(pScrn, pVia->pI2CBus2, 0xEC);
-    else if (pVia->pI2CBus2 && xf86I2CProbeAddress(pVia->pI2CBus2, 0x40))
-        pBIOSInfo->TVI2CDev = ViaVT162xDetect(pScrn, pVia->pI2CBus2, 0x40);
-    else if (pVia->pI2CBus3 && xf86I2CProbeAddress(pVia->pI2CBus3, 0x40))
-        pBIOSInfo->TVI2CDev = ViaVT162xDetect(pScrn, pVia->pI2CBus3, 0x40);
-    else if (pVia->pI2CBus2 && xf86I2CProbeAddress(pVia->pI2CBus2, 0xEA))
-        pBIOSInfo->TVI2CDev = ViaCH7xxxDetect(pScrn, pVia->pI2CBus2, 0xEA);
-    else if (pVia->pI2CBus3 && xf86I2CProbeAddress(pVia->pI2CBus3, 0xEA))
-        pBIOSInfo->TVI2CDev = ViaCH7xxxDetect(pScrn, pVia->pI2CBus3, 0xEA);
-
-    if (!pBIOSInfo->TVI2CDev) {
-        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                    "Did not detect a TV encoder.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_tv_init.\n"));
-
-        return FALSE;
-    }
-
-    switch (pBIOSInfo->TVEncoder) {
-        case VIA_VT1621:
-        case VIA_VT1622:
-        case VIA_VT1623:
-        case VIA_VT1625:
-            ViaVT162xInit(pScrn);
-            break;
-        case VIA_CH7011:
-        case VIA_CH7019A:
-        case VIA_CH7019B:
-            ViaCH7xxxInit(pScrn);
-            break;
-        default:
-            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                        "Was not able to initialize a known TV encoder.\n");
-            DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                                "Exiting via_tv_init.\n"));
-            return FALSE;
-            break;
-    }
-
-    if (!pBIOSInfo->TVSave || !pBIOSInfo->TVRestore
-        || !pBIOSInfo->TVDACSense || !pBIOSInfo->TVModeValid
-        || !pBIOSInfo->TVModeI2C || !pBIOSInfo->TVModeCrtc
-        || !pBIOSInfo->TVPower || !pBIOSInfo->TVModes
-        || !pBIOSInfo->TVPrintRegs) {
-
-        xf86DestroyI2CDevRec(pBIOSInfo->TVI2CDev, TRUE);
-
-        pBIOSInfo->TVI2CDev = NULL;
-        pBIOSInfo->TVOutput = TVOUTPUT_NONE;
-        pBIOSInfo->TVEncoder = VIA_NONETV;
-        pBIOSInfo->TVI2CDev = NULL;
-        pBIOSInfo->TVSave = NULL;
-        pBIOSInfo->TVRestore = NULL;
-        pBIOSInfo->TVDACSense = NULL;
-        pBIOSInfo->TVModeValid = NULL;
-        pBIOSInfo->TVModeI2C = NULL;
-        pBIOSInfo->TVModeCrtc = NULL;
-        pBIOSInfo->TVPower = NULL;
-        pBIOSInfo->TVModes = NULL;
-        pBIOSInfo->TVPrintRegs = NULL;
-        pBIOSInfo->TVNumRegs = 0;
-
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "TV encoder was not properly initialized.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_tv_init.\n"));
-        return FALSE;
-    }
-
-    output = xf86OutputCreate(pScrn, &via_tv_funcs, "TV-1");
-    pVia->FirstInit = TRUE;
+                        "Entered viaDIP0SetDisplaySource.\n"));
 
-    if (output) {
-        /* Allow tv output on both crtcs, set bit 0 and 1. */
-        output->possible_crtcs = 0x3;
-    } else {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "Failed to register TV-1.\n");
-    }
-
-    pBIOSInfo->tv = output;
-    /* Save now */
-    pBIOSInfo->TVSave(pScrn);
-
-#ifdef HAVE_DEBUG
-    if (VIAPTR(pScrn)->PrintTVRegs)
-        pBIOSInfo->TVPrintRegs(pScrn);
-#endif
+    /* Set DIP0 display output source. */
+    /* 3X5.6C[7] - DIP0 (Digital Interface Port 0) Data Source Selection
+     *             0: Primary Display (IGA1)
+     *             1: Secondary Display (IGA2) */
+    ViaCrtcMask(hwp, 0x6C, temp << 7, 0x80);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DIP0 Display Output Source: IGA%d\n",
+                (temp & 0x01) + 1);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_tv_init.\n"));
-    return TRUE;
+                        "Exiting viaDIP0SetDisplaySource.\n"));
 }
 
 /*
- * Enables or disables analog VGA output by controlling DAC
- * (Digital to Analog Converter) output state.
+ * Sets DIP0 (Digital Interface Port 0) I/O pad state.
+ * This function is for CLE266 chipset only.
  */
-static void
-viaAnalogOutput(ScrnInfoPtr pScrn, Bool outputState)
+void
+viaDIP0EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
 {
     vgaHWPtr hwp = VGAHWPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered viaAnalogOutput.\n"));
+                        "Entered viaDIP0EnableIOPads.\n"));
 
-    /* This register controls analog VGA DAC output state. */
-    /* 3X5.47[2] - DACOFF Backdoor Register
-     *             0: DAC on
-     *             1: DAC off */
-    ViaCrtcMask(hwp, 0x47, outputState ? 0x00 : 0x04, 0x04);
+    /* Set DIP0 I/O pad state. */
+    /* 3C5.1E[7:6] - DIP0 Power Control
+     *               0x: Pad always off
+     *               10: Depend on the other control signal
+     *               11: Pad on/off according to the
+     *                   Power Management Status (PMS) */
+    ViaSeqMask(hwp, 0x1E, ioPadState << 6, 0xC0);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                "Analog VGA Output: %s\n",
-                outputState ? "On" : "Off");
+                "DIP0 I/O Pad State: %s\n",
+                (ioPadState & 0x02) ?
+                    (ioPadState & 0x01) ? "Automatic On / Off" : "Conditional"
+                : "Off");
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting viaAnalogOutput.\n"));
+                        "Exiting viaDIP0EnableIOPads.\n"));
 }
 
 /*
- * Specifies IGA1 or IGA2 for analog VGA DAC source.
+ * Sets IGA1 or IGA2 as the display output source for DVP0
+ * (Digital Video Port) interface.
  */
-static void
-viaAnalogSource(ScrnInfoPtr pScrn, CARD8 displaySource)
+void
+viaDVP0SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
 {
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    CARD8 value = displaySource;
+    CARD8 temp = displaySource;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered viaAnalogSource.\n"));
+                        "Entered viaDVP0SetDisplaySource.\n"));
 
-    ViaSeqMask(hwp, 0x16, value << 6, 0x40);
+    /* Set DVP0 display output source. */
+    /* 3X5.96[4] - DVP0 Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x96, temp << 4, 0x10);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                "Analog VGA Output Source: IGA%d\n",
-                (value & 0x01) + 1);
+                "DVP0 Display Output Source: IGA%d\n",
+                (temp & 0x01) + 1);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting viaAnalogSource.\n"));
+                        "Exiting viaDVP0SetDisplaySource.\n"));
 }
 
 /*
- * Intializes analog VGA related registers.
+ * Sets DVP0 (Digital Video Port 0) I/O pad state.
  */
-static void
-viaAnalogInit(ScrnInfoPtr pScrn)
+void
+viaDVP0EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
 {
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    VIAPtr pVia = VIAPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered viaAnalogInit.\n"));
-
-    /* 3X5.37[7]   - DAC Power Save Control 1
-     *               0: Depend on Rx3X5.37[5:4] setting
-     *               1: DAC always goes into power save mode
-     * 3X5.37[6]   - DAC Power Down Control
-     *               0: Depend on Rx3X5.47[2] setting
-     *               1: DAC never goes to power down mode
-     * 3X5.37[5:4] - DAC Power Save Control 2
-     *               00: DAC never goes to power save mode
-     *               01: DAC goes to power save mode by line
-     *               10: DAC goes to power save mode by frame
-     *               11: DAC goes to power save mode by line and frame
-     * 3X5.37[3]   - DAC PEDESTAL Control
-     * 3X5.37[2:0] - DAC Factor
-     *               (Default: 100) */
-    ViaCrtcMask(hwp, 0x37, 0x04, 0xFF);
+                        "Entered viaDVP0EnableIOPads.\n"));
 
-    switch (pVia->Chipset) {
-    case VIA_CX700:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        /* 3C5.5E[0] - CRT DACOFF Setting
-         *             1: CRT DACOFF controlled by 3C5.01[5] */
-        ViaSeqMask(hwp, 0x5E, 0x01, 0x01);
-        break;
-    default:
-        break;
-    }
+    /* Set DVP0 I/O pad state. */
+    /* 3C5.1E[7:6] - DVP0 Power Control
+     *               0x: Pad always off
+     *               10: Depend on the other control signal
+     *               11: Pad on/off according to the
+     *                   Power Management Status (PMS) */
+    ViaSeqMask(hwp, 0x1E, ioPadState << 6, 0xC0);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DVP0 I/O Pad State: %s\n",
+                (ioPadState & 0x02) ?
+                    (ioPadState & 0x01) ? "Automatic On / Off" : "Conditional"
+                : "Off");
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting viaAnalogInit.\n"));
-}
-
-static void
-via_analog_create_resources(xf86OutputPtr output)
-{
+                        "Exiting viaDVP0EnableIOPads.\n"));
 }
 
-#ifdef RANDR_12_INTERFACE
-static Bool
-via_analog_set_property(xf86OutputPtr output, Atom property,
-                        RRPropertyValuePtr value)
-{
-    return TRUE;
-}
-
-static Bool
-via_analog_get_property(xf86OutputPtr output, Atom property)
-{
-    return FALSE;
-}
-#endif
-
-static void
-via_analog_dpms(xf86OutputPtr output, int mode)
+/*
+ * Sets IGA1 or IGA2 as the display output source for DVP1
+ * (Digital Video Port) interface.
+ */
+void
+viaDVP1SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
 {
-    ScrnInfoPtr pScrn = output->scrn;
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 temp = displaySource;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_analog_dpms.\n"));
+                        "Entered viaDVP1SetDisplaySource.\n"));
 
-    switch (mode) {
-    case DPMSModeOn:
-        viaAnalogOutput(pScrn, TRUE);
-        break;
-    case DPMSModeStandby:
-    case DPMSModeSuspend:
-    case DPMSModeOff:
-        viaAnalogOutput(pScrn, FALSE);
-        break;
-    default:
-        break;
-    }
+    /* Set DVP1 display output source. */
+    /* 3X5.9B[4] - DVP1 Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x9B, temp << 4, 0x10);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DVP1 Display Output Source: IGA%d\n",
+                (temp & 0x01) + 1);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_analog_dpms.\n"));
-}
-
-static void
-via_analog_save(xf86OutputPtr output)
-{
-}
-
-static void
-via_analog_restore(xf86OutputPtr output)
-{
+                        "Exiting viaDVP1SetDisplaySource.\n"));
 }
 
-static int
-via_analog_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-
-    if (!ViaModeDotClockTranslate(pScrn, pMode))
-        return MODE_NOCLOCK;
-    return MODE_OK;
-}
-
-static Bool
-via_analog_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
-                      DisplayModePtr adjusted_mode)
-{
-    return TRUE;
-}
-
-static void
-via_analog_prepare(xf86OutputPtr output)
-{
-    via_analog_dpms(output, DPMSModeOff);
-}
-
-static void
-via_analog_commit(xf86OutputPtr output)
-{
-    via_analog_dpms(output, DPMSModeOn);
-}
-
-static void
-via_analog_mode_set(xf86OutputPtr output, DisplayModePtr mode,
-                    DisplayModePtr adjusted_mode)
+/*
+ * Sets DVP1 (Digital Video Port 1) I/O pad state.
+ */
+void
+viaDVP1EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
 {
-    ScrnInfoPtr pScrn = output->scrn;
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_analog_mode_set.\n"));
-
-    viaAnalogInit(pScrn);
+                        "Entered viaDVP1EnableIOPads.\n"));
 
-    if (output->crtc) {
-        viaAnalogSource(pScrn, iga->index ? 0x01 : 0x00);
-    }
+    /* Set DVP1 I/O pad state. */
+    /* 3C5.1E[5:4] - DVP1 Power Control
+     *               0x: Pad always off
+     *               10: Depend on the other control signal
+     *               11: Pad on/off according to the
+     *                   Power Management Status (PMS) */
+    ViaSeqMask(hwp, 0x1E, ioPadState << 4, 0x30);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DVP1 I/O Pad State: %s\n",
+                (ioPadState & 0x02) ?
+                    (ioPadState & 0x01) ? "Automatic On / Off": "Conditional"
+                : "Off");
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_analog_mode_set.\n"));
+                        "Exiting viaDVP1EnableIOPads.\n"));
 }
 
-static xf86OutputStatus
-via_analog_detect(xf86OutputPtr output)
-{
-    xf86OutputStatus status = XF86OutputStatusDisconnected;
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    xf86MonPtr mon;
-
-    /* Probe I2C Bus 1 to see if a VGA monitor is connected. */
-    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                "Probing for a VGA monitor on I2C Bus 1.\n");
-    mon = xf86OutputGetEDID(output, pVia->pI2CBus1);
-    if (mon && (!mon->features.input_type)) {
-        xf86OutputSetEDID(output, mon);
-        status = XF86OutputStatusConnected;
-        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                    "Detected a VGA monitor on I2C Bus 1.\n");
-    } else {
-        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                    "Did not detect a VGA monitor on I2C Bus 1.\n");
-
-        /* Probe I2C Bus 2 to see if a VGA monitor is connected. */
-        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                    "Probing for a VGA monitor on I2C Bus 2.\n");
-        mon = xf86OutputGetEDID(output, pVia->pI2CBus2);
-        if (mon && (!mon->features.input_type)) {
-            xf86OutputSetEDID(output, mon);
-            status = XF86OutputStatusConnected;
-            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                        "Detected a VGA monitor on I2C Bus 2.\n");
-        } else {
-            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                        "Did not detect a VGA monitor on I2C Bus 2.\n");
-
-            /* Perform manual detection of a VGA monitor since */
-            /* it was not detected via I2C buses. */
-            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                        "Now perform manual detection of a VGA "
-                        "monitor.\n");
-            vgaHWPtr hwp = VGAHWPTR(pScrn);
-            CARD8 SR01 = hwp->readSeq(hwp, 0x01);
-            CARD8 SR40 = hwp->readSeq(hwp, 0x40);
-            CARD8 CR36 = hwp->readCrtc(hwp, 0x36);
-
-            /* We have to power on the display to detect it */
-            ViaSeqMask(hwp, 0x01, 0x00, 0x20);
-            ViaCrtcMask(hwp, 0x36, 0x00, 0xF0);
-
-            /* Wait for vblank */
-            usleep(16);
-
-            /* Detect the load on pins */
-            ViaSeqMask(hwp, 0x40, 0x80, 0x80);
-
-            if ((VIA_CX700 == pVia->Chipset) ||
-                (VIA_VX800 == pVia->Chipset) ||
-                (VIA_VX855 == pVia->Chipset) ||
-                (VIA_VX900 == pVia->Chipset))
-                ViaSeqMask(hwp, 0x40, 0x00, 0x80);
-
-            if (ViaVgahwIn(hwp, 0x3C2) & 0x20) {
-                status = XF86OutputStatusConnected;
-                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                            "Detected a VGA monitor using manual "
-                            "detection method.\n");
-            }
-
-            if ((VIA_CX700 == pVia->Chipset) ||
-                (VIA_VX800 == pVia->Chipset) ||
-                (VIA_VX855 == pVia->Chipset) ||
-                (VIA_VX900 == pVia->Chipset))
-                ViaSeqMask(hwp, 0x40, 0x00, 0x80);
-
-            /* Restore previous state */
-            hwp->writeSeq(hwp, 0x40, SR40);
-            hwp->writeSeq(hwp, 0x01, SR01);
-            hwp->writeCrtc(hwp, 0x36, CR36);
-        }
-    }
-
-    return status;
-}
-
-static void
-via_analog_destroy(xf86OutputPtr output)
-{
-}
-
-static const xf86OutputFuncsRec via_analog_funcs = {
-    .create_resources   = via_analog_create_resources,
-#ifdef RANDR_12_INTERFACE
-    .set_property       = via_analog_set_property,
-#endif
-#ifdef RANDR_13_INTERFACE
-    .get_property       = via_analog_get_property,
-#endif
-    .dpms               = via_analog_dpms,
-    .save               = via_analog_save,
-    .restore            = via_analog_restore,
-    .mode_valid         = via_analog_mode_valid,
-    .mode_fixup         = via_analog_mode_fixup,
-    .prepare            = via_analog_prepare,
-    .commit             = via_analog_commit,
-    .mode_set           = via_analog_mode_set,
-    .detect             = via_analog_detect,
-    .get_modes          = xf86OutputGetEDIDModes,
-    .destroy            = via_analog_destroy,
-};
-
+/*
+ * Sets IGA1 or IGA2 as the display output source for VIA Technologies
+ * Chrome IGP DFP (Digital Flat Panel) Low interface.
+ */
 void
-via_analog_init(ScrnInfoPtr pScrn)
+viaDFPLowSetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
 {
-    VIAPtr pVia = VIAPTR(pScrn);
-    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
-    xf86OutputPtr output = NULL;
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 temp = displaySource;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_analog_init.\n"));
-
-    if (!pVia->pI2CBus1 || !pVia->pI2CBus2) {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                    "I2C Bus 1 or I2C Bus 2 does not exist.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_analog_init.\n"));
-        return;
-    }
-
-    output = xf86OutputCreate(pScrn, &via_analog_funcs, "VGA-1");
+                        "Entered viaDFPLowSetDisplaySource.\n"));
 
-    output->possible_crtcs = 0x3;
-    output->possible_clones = 0;
-    output->interlaceAllowed = TRUE;
-    output->doubleScanAllowed = FALSE;
-    pBIOSInfo->analog = output;
+    /* Set DFP Low display output source. */
+    /* 3X5.99[4] - DFP Low Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x99, temp << 4, 0x10);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DFP Low Display Output Source: IGA%d\n",
+                (temp & 0x01) + 1);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_analog_init.\n"));
-}
-
-static void
-via_dvi_create_resources(xf86OutputPtr output)
-{
-}
-
-#ifdef RANDR_12_INTERFACE
-static Bool
-via_dvi_set_property(xf86OutputPtr output, Atom property,
-                     RRPropertyValuePtr value)
-{
-    return TRUE;
-}
-
-static Bool
-via_dvi_get_property(xf86OutputPtr output, Atom property)
-{
-    return FALSE;
-}
-#endif
-
-static void
-via_dvi_dpms(xf86OutputPtr output, int mode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-
-    switch (mode) {
-    case DPMSModeOn:
-        via_vt1632_power(output, TRUE);
-        break;
-    case DPMSModeStandby:
-    case DPMSModeSuspend:
-    case DPMSModeOff:
-        via_vt1632_power(output, FALSE);
-        break;
-    default:
-        break;
-    }
-}
-
-static void
-via_dvi_save(xf86OutputPtr output)
-{
-    via_vt1632_save(output);
-}
-
-static void
-via_dvi_restore(xf86OutputPtr output)
-{
-    via_vt1632_restore(output);
-}
-
-static int
-via_dvi_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
-{
-    return via_vt1632_mode_valid(output, pMode);
-}
-
-static Bool
-via_dvi_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
-                   DisplayModePtr adjusted_mode)
-{
-    return TRUE;
+                        "Exiting viaDFPLowSetDisplaySource.\n"));
 }
 
-static void
-via_dvi_prepare(xf86OutputPtr output)
-{
-}
-
-static void
-via_dvi_commit(xf86OutputPtr output)
-{
-}
-
-static void
-via_dvi_mode_set(xf86OutputPtr output, DisplayModePtr mode,
-                 DisplayModePtr adjusted_mode)
-{
-    ScrnInfoPtr pScrn = output->scrn;
-    vgaHWPtr hwp = VGAHWPTR(pScrn);
-
-    via_vt1632_mode_set(output, mode, adjusted_mode);
-}
-
-static xf86OutputStatus
-via_dvi_detect(xf86OutputPtr output)
-{
-    xf86OutputStatus status = XF86OutputStatusDisconnected;
-    ScrnInfoPtr pScrn = output->scrn;
-    VIAPtr pVia = VIAPTR(pScrn);
-    ViaVT1632Ptr Private = output->driver_private;
-    xf86MonPtr mon;
-
-    /* Check for the DVI presence via VT1632A first before accessing
-     * I2C bus. */
-    status = via_vt1632_detect(output);
-    if (status == XF86OutputStatusConnected) {
-
-        /* Since DVI presence was established, access the I2C bus
-         * assigned to DVI. */
-        mon = xf86OutputGetEDID(output, Private->VT1632I2CDev->pI2CBus);
-
-        /* Is the interface type digital? */
-        if (mon && DIGITAL(mon->features.input_type)) {
-            xf86OutputSetEDID(output, mon);
-        } else {
-            status = XF86OutputStatusDisconnected;
-        }
-    }
-
-    return status;
-}
-
-static void
-via_dvi_destroy(xf86OutputPtr output)
-{
-}
-
-static const xf86OutputFuncsRec via_dvi_funcs = {
-    .create_resources   = via_dvi_create_resources,
-#ifdef RANDR_12_INTERFACE
-    .set_property       = via_dvi_set_property,
-#endif
-#ifdef RANDR_13_INTERFACE
-    .get_property       = via_dvi_get_property,
-#endif
-    .dpms               = via_dvi_dpms,
-    .save               = via_dvi_save,
-    .restore            = via_dvi_restore,
-    .mode_valid         = via_dvi_mode_valid,
-    .mode_fixup         = via_dvi_mode_fixup,
-    .prepare            = via_dvi_prepare,
-    .commit             = via_dvi_commit,
-    .mode_set           = via_dvi_mode_set,
-    .detect             = via_dvi_detect,
-    .get_modes          = xf86OutputGetEDIDModes,
-    .destroy            = via_dvi_destroy,
-};
-
+/*
+ * Sets DFP (Digital Flat Panel) Low I/O pad state.
+ */
 void
-via_dvi_init(ScrnInfoPtr pScrn)
+viaDFPLowEnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
 {
-    VIAPtr pVia = VIAPTR(pScrn);
-    xf86OutputPtr output = NULL;
-    ViaVT1632Ptr private_data = NULL;
-    I2CBusPtr pBus = NULL;
-    I2CDevPtr pDev = NULL;
-    I2CSlaveAddr addr = 0x10;
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_dvi_init.\n"));
-
-    if (!pVia->pI2CBus2 || !pVia->pI2CBus3) {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                    "I2C Bus 2 or I2C Bus 3 does not exist.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                    "Exiting via_dvi_init.\n"));
-        return;
-    }
+                        "Entered viaDFPLowEnableIOPads.\n"));
 
-    if (xf86I2CProbeAddress(pVia->pI2CBus3, addr)) {
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                            "Will probe I2C Bus 3 for a possible "
-                            "external TMDS transmitter.\n"));
-        pBus = pVia->pI2CBus3;
-    } else if (xf86I2CProbeAddress(pVia->pI2CBus2, addr)) {
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                            "Will probe I2C Bus 2 for a possible "
-                            "external TMDS transmitter.\n"));
-        pBus = pVia->pI2CBus2;
-    } else {
-        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                    "Did not find a possible external TMDS transmitter "
-                    "on I2C Bus 2 or I2C Bus 3.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_dvi_init.\n"));
-        return;
-    }
-
-    pDev = xf86CreateI2CDevRec();
-    if (!pDev) {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                    "Failed to create an I2C bus structure.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_dvi_init.\n"));
-        return;
-    }
-
-    pDev->DevName = "VT1632A";
-    pDev->SlaveAddr = addr;
-    pDev->pI2CBus = pBus;
-    if (!xf86I2CDevInit(pDev)) {
-        xf86DestroyI2CDevRec(pDev, TRUE);
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                    "Failed to initialize a device on I2C bus.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_dvi_init.\n"));
-        return;
-    }
-
-    if (!via_vt1632_probe(pScrn, pDev)) {
-        xf86DestroyI2CDevRec(pDev, TRUE);
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_dvi_init.\n"));
-        return;
-    }
-
-    private_data = via_vt1632_init(pScrn, pDev);
-    if (!private_data) {
-        xf86DestroyI2CDevRec(pDev, TRUE);
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_dvi_init.\n"));
-        return;
-    }
-
-    output = xf86OutputCreate(pScrn, &via_dvi_funcs, "DVI-1");
-    if (output) {
-        output->driver_private = private_data;
-        output->possible_crtcs = 0x2;
-        output->possible_clones = 0;
-        output->interlaceAllowed = FALSE;
-        output->doubleScanAllowed = FALSE;
-    }
+    /* Set DFP Low I/O pad state. */
+    /* 3C5.2A[1:0] - DFP Low Power Control
+     *               0x: Pad always off
+     *               10: Depend on the other control signal
+     *               11: Pad on/off according to the
+     *                   Power Management Status (PMS) */
+    ViaSeqMask(hwp, 0x2A, ioPadState, 0x03);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "DFP Low I/O Pad State: %s\n",
+                (ioPadState & 0x02) ?
+                    (ioPadState & 0x01) ? "Automatic On / Off": "Conditional"
+                : "Off");
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_dvi_init.\n"));
+                        "Exiting viaDFPLowEnableIOPads.\n"));
 }
 
 /*
@@ -1111,7 +302,6 @@
 
     switch (pVia->Chipset) {
     case VIA_CLE266:
-    case VIA_KM400:
 
         /* 3C5.12[4] - FPD17 pin strapping
          *             0: TMDS transmitter (DVI) / capture device
@@ -1130,7 +320,7 @@
         } else {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "A TMDS transmitter (DVI) / capture device is "
-                        "connected to flat panel interface.\n");
+                        "connected to DIP0.\n");
         }
 
         /* 3C5.12[5] - FPD18 pin strapping
@@ -1138,19 +328,15 @@
          *             1: TV encoder */
         if (sr12 & 0x20) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "A TMDS transmitter (DVI) is connected to "
-                        "DVI port.\n");
-        } else {
-            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "A TV encoder is connected to "
-                        "DVI port.\n");
+                        "DIP0.\n");
 
             /* 3C5.13[4:3] - FPD21-20 pin strapping
              *               00: PAL
              *               01: NTSC
              *               10: PAL-N
              *               11: PAL-NC */
-            if (sr13 & 0x04) {
+            if ((!(sr13 & 0x08)) & (sr13 & 0x04)) {
                 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                             "NTSC for the TV encoder.\n");
             } else {
@@ -1160,7 +346,7 @@
                 } else {
                     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                                 "PAL%s for the TV encoder.\n",
-                                sr13 & 0x04 ? "-NC" : "-N");
+                                (sr13 & 0x04) ? "-NC" : "-N");
                 }
             }
 
@@ -1169,11 +355,16 @@
              *             1: 625 lines (PAL) */
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "%s lines for the TV encoder.\n",
-                        sr12 & 0x40 ? "625" : "525");
+                        (sr12 & 0x40) ? "625" : "525");
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "A TMDS transmitter (DVI) is connected to "
+                        "DIP0.\n");
         }
 
         break;
 
+    case VIA_KM400:
     case VIA_K8M800:
     case VIA_PM800:
     case VIA_P4M800PRO:
@@ -1317,22 +508,31 @@
 
     pBIOSInfo->analog = NULL;
 
+    /* Initialize the number of VGA connectors. */
+    pVia->numberVGA = 0;
+
+    /* Initialize the number of DVI connectors. */
+    pVia->numberDVI = 0;
+
+    /* Initialize the number of FP connectors. */
+    pVia->numberFP = 0;
+
     /* Read off the VIA Technologies IGP pin strapping for
        display detection purposes. */
     viaProbePinStrapping(pScrn);
 
-    /* LVDS */
-    via_lvds_init(pScrn);
-
     /* VGA */
     via_analog_init(pScrn);
 
     /* TV */
     via_tv_init(pScrn);
 
-    /* External TMDS Transmitter (DVI) */
+    /* DVI */
     via_dvi_init(pScrn);
 
+    /* LVDS */
+    via_lvds_init(pScrn);
+
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting viaOutputDetect.\n"));
 }
@@ -1531,12 +731,11 @@
 static CARD32
 ViaComputeProDotClock(unsigned clock)
 {
-    double fvco, fout, fref, err, minErr;
+    double fvco, fout, err, minErr;
     CARD32 dr = 0, dn, dm, maxdm, maxdn;
     CARD32 factual;
     union pllparams bestClock;
 
-    fref = 14.318e6;
     fout = (double)clock * 1.e3;
 
     factual = ~0;
@@ -1615,28 +814,3 @@
 
     return 0;
 }
-
-void
-viaTMDSPower(ScrnInfoPtr pScrn, Bool On)
-{
-
-    vgaHWPtr hwp = VGAHWPTR(pScrn);
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered viaTMDSPower.\n"));
-
-    if (On) {
-        /* Power on TMDS */
-        ViaCrtcMask(hwp, 0xD2, 0x00, 0x08);
-    } else {
-        /* Power off TMDS */
-        ViaCrtcMask(hwp, 0xD2, 0x08, 0x08);
-    }
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                "Integrated TMDS (DVI) Power: %s\n",
-                On ? "On" : "Off");
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting viaTMDSPower.\n"));
-}
diff -ruN xf86-video-openchrome-0.5.0/src/via_sii164.c xf86-video-openchrome/src/via_sii164.c
--- xf86-video-openchrome-0.5.0/src/via_sii164.c	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/via_sii164.c	2016-09-10 02:42:52.036255402 +0300
@@ -0,0 +1,746 @@
+/*
+ * Copyright 2016 Kevin Brace
+ * Copyright 2016 The OpenChrome Project
+ *                [http://www.freedesktop.org/wiki/Openchrome]
+ * Copyright 2014 SHS SERVICES GmbH
+ * Copyright 2006-2009 Luc Verhaegen.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "via_driver.h"
+#include "via_sii164.h"
+
+static void
+viaSiI164SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 sr12, sr13, sr5a;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164SetDisplaySource.\n"));
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        sr5a = hwp->readSeq(hwp, 0x5A);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "SR5A: 0x%02X\n", sr5a));
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Setting 3C5.5A[0] to 0.\n"));
+        ViaSeqMask(hwp, 0x5A, sr5a & 0xFE, 0x01);
+    }
+
+    sr12 = hwp->readSeq(hwp, 0x12);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR12: 0x%02X\n", sr12));
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+        /* 3C5.12[5] - FPD18 pin strapping
+         *             0: DIP0 (Digital Interface Port 0) is used by
+         *                a TMDS transmitter (DVI)
+         *             1: DIP0 (Digital Interface Port 0) is used by
+         *                a TV encoder */
+        if (!(sr12 & 0x20)) {
+            viaDIP0SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DIP0 was not set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_KM400:
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+        /* 3C5.13[3] - DVP0D8 pin strapping
+         *             0: AGP pins are used for AGP
+         *             1: AGP pins are used by FPDP
+         *                (Flat Panel Display Port)
+         * 3C5.12[6] - DVP0D6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - DVP0D5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - DVP0D4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP (Flat Panel Display Port) */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0SetDisplaySource(pScrn, displaySource);
+        } else if ((sr13 & 0x08) && (!(sr12 & 0x10))) {
+            viaDFPLowSetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+        /* 3C5.12[6] - FPD6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - FPD5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0SetDisplaySource(pScrn, displaySource);
+        } else if (!(sr12 & 0x10)) {
+            viaDFPLowSetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.13[6] - DVP1 DVP / capture port selection
+         *             0: DVP1 is used as a DVP (Digital Video Port)
+         *             1: DVP1 is used as a capture port
+         */
+        if (!(sr13 & 0x40)) {
+            viaDVP1SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DVP1 is not set up for TMDS "
+                        "transmitter use.\n");
+        }
+
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Unrecognized IGP for "
+                    "TMDS transmitter use.\n");
+        break;
+    }
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        hwp->writeSeq(hwp, 0x5A, sr5a);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Restoring 3C5.5A[0].\n"));
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164SetDisplaySource.\n"));
+}
+
+static void
+viaSiI164EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
+{
+
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 sr12, sr13, sr5a;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164EnableIOPads.\n"));
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        sr5a = hwp->readSeq(hwp, 0x5A);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "SR5A: 0x%02X\n", sr5a));
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Setting 3C5.5A[0] to 0.\n"));
+        ViaSeqMask(hwp, 0x5A, sr5a & 0xFE, 0x01);
+    }
+
+    sr12 = hwp->readSeq(hwp, 0x12);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR12: 0x%02X\n", sr12));
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+        /* 3C5.12[5] - FPD18 pin strapping
+         *             0: DIP0 (Digital Interface Port 0) is used by
+         *                a TMDS transmitter (DVI)
+         *             1: DIP0 (Digital Interface Port 0) is used by
+         *                a TV encoder */
+        if (!(sr12 & 0x20)) {
+            viaDIP0EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DIP0 was not set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_KM400:
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+        /* 3C5.13[3] - DVP0D8 pin strapping
+         *             0: AGP pins are used for AGP
+         *             1: AGP pins are used by FPDP
+         *                (Flat Panel Display Port)
+         * 3C5.12[6] - DVP0D6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - DVP0D5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - DVP0D4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP (Flat Panel Display Port) */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0EnableIOPads(pScrn, ioPadState);
+        } else if ((sr13 & 0x08) && (!(sr12 & 0x10))) {
+            viaDFPLowEnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+        /* 3C5.12[6] - FPD6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - FPD5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0EnableIOPads(pScrn, ioPadState);
+        } else if (!(sr12 & 0x10)) {
+            viaDFPLowEnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.13[6] - DVP1 DVP / capture port selection
+         *             0: DVP1 is used as a DVP (Digital Video Port)
+         *             1: DVP1 is used as a capture port
+         */
+        if (!(sr13 & 0x40)) {
+            viaDVP1EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DVP1 is not set up for TMDS "
+                        "transmitter use.\n");
+        }
+
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Unrecognized IGP for "
+                    "TMDS transmitter use.\n");
+        break;
+    }
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        hwp->writeSeq(hwp, 0x5A, sr5a);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Restoring 3C5.5A[0].\n"));
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164EnableIOPads.\n"));
+}
+
+static void
+via_sii164_dump_registers(ScrnInfoPtr pScrn, I2CDevPtr pDev)
+{
+    int i;
+    CARD8 tmp;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_sii164_dump_registers.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "SiI 164: dumping registers:\n"));
+    for (i = 0; i <= 0x0f; i++) {
+        xf86I2CReadByte(pDev, i, &tmp);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "SiI 164: 0x%02x: 0x%02x\n", i, tmp));
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_sii164_dump_registers.\n"));
+}
+
+static void
+viaSiI164InitRegisters(ScrnInfoPtr pScrn, I2CDevPtr pDev)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164InitRegisters.\n"));
+
+    xf86I2CWriteByte(pDev, 0x08,
+                        VIA_SII164_VEN | VIA_SII164_HEN |
+                        VIA_SII164_DSEL |
+                        VIA_SII164_EDGE | VIA_SII164_PDB);
+
+    /* Route receiver detect bit (Offset 0x09[2]) as the output of
+     * MSEN pin. */
+    xf86I2CWriteByte(pDev, 0x09, 0x20);
+
+    xf86I2CWriteByte(pDev, 0x0A, 0x00);
+
+    xf86I2CWriteByte(pDev, 0x0C, 0x00);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164InitRegisters.\n"));
+}
+
+/*
+ * Returns TMDS receiver detection state for Silicon Image SiI 164
+ * external TMDS transmitter.
+ */
+static Bool
+viaSiI164Sense(ScrnInfoPtr pScrn, I2CDevPtr pDev)
+{
+    CARD8 tmp;
+    Bool receiverDetected = FALSE;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164Sense.\n"));
+
+    xf86I2CReadByte(pDev, 0x09, &tmp);
+    if (tmp & 0x04) {
+        receiverDetected = TRUE;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "SiI 164 %s a TMDS receiver.\n",
+                receiverDetected ? "detected" : "did not detect");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164Sense.\n"));
+    return receiverDetected;
+}
+
+static void
+viaSiI164Power(ScrnInfoPtr pScrn, I2CDevPtr pDev, Bool powerState)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164Power.\n"));
+
+    xf86I2CMaskByte(pDev, 0x08, powerState ? 0x01 : 0x00, 0x01);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "SiI 164 (DVI) Power: %s\n",
+                powerState ? "On" : "Off");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164Power.\n"));
+}
+
+static void
+viaSiI164SaveRegisters(ScrnInfoPtr pScrn, I2CDevPtr pDev,
+                        viaSiI164RecPtr pSiI164Rec)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164SaveRegisters.\n"));
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Saving SiI 164 registers.\n");
+    xf86I2CReadByte(pDev, 0x08, &pSiI164Rec->Register08);
+    xf86I2CReadByte(pDev, 0x09, &pSiI164Rec->Register09);
+    xf86I2CReadByte(pDev, 0x0A, &pSiI164Rec->Register0A);
+    xf86I2CReadByte(pDev, 0x0C, &pSiI164Rec->Register0C);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164SaveRegisters.\n"));
+}
+
+static void
+viaSiI164RestoreRegisters(ScrnInfoPtr pScrn, I2CDevPtr pDev,
+                            viaSiI164RecPtr pSiI164Rec)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164RestoreRegisters.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Restoring SiI 164 registers.\n"));
+    xf86I2CWriteByte(pDev, 0x08, pSiI164Rec->Register08);
+    xf86I2CWriteByte(pDev, 0x09, pSiI164Rec->Register09);
+    xf86I2CWriteByte(pDev, 0x0A, pSiI164Rec->Register0A);
+    xf86I2CWriteByte(pDev, 0x0C, pSiI164Rec->Register0C);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164RestoreRegisters.\n"));
+}
+
+static int
+viaSiI164CheckModeValidity(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    viaSiI164RecPtr pSiI164Rec = output->driver_private;
+    int status = MODE_OK;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
+                        "Entered viaSiI164CheckModeValidity.\n"));
+
+    if (pMode->Clock < pSiI164Rec->DotclockMin) {
+        status = MODE_CLOCK_LOW;
+        goto exit;
+    }
+
+    if (pMode->Clock > pSiI164Rec->DotclockMax) {
+        status = MODE_CLOCK_HIGH;
+    }
+
+exit:
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164CheckModeValidity.\n"));
+    return status;
+}
+
+static void
+via_sii164_create_resources(xf86OutputPtr output)
+{
+}
+
+static void
+via_sii164_dpms(xf86OutputPtr output, int mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    viaSiI164RecPtr pSiI164Rec = output->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_sii164_dpms.\n"));
+
+    switch (mode) {
+    case DPMSModeOn:
+        viaSiI164Power(pScrn, pSiI164Rec->SiI164I2CDev, TRUE);
+        break;
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+    case DPMSModeOff:
+        viaSiI164Power(pScrn, pSiI164Rec->SiI164I2CDev, FALSE);
+        break;
+    default:
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_sii164_dpms.\n"));
+}
+
+static void
+via_sii164_save(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    viaSiI164RecPtr pSiI164Rec = output->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_sii164_save.\n"));
+
+    viaSiI164SaveRegisters(pScrn, pSiI164Rec->SiI164I2CDev, pSiI164Rec);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_sii164_save.\n"));
+}
+
+static void
+via_sii164_restore(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    viaSiI164RecPtr pSiI164Rec = output->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_sii164_restore.\n"));
+
+    viaSiI164RestoreRegisters(pScrn, pSiI164Rec->SiI164I2CDev,
+                                pSiI164Rec);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_sii164_restore.\n"));
+}
+
+static int
+via_sii164_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    return viaSiI164CheckModeValidity(output, pMode);
+}
+
+static Bool
+via_sii164_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
+                   DisplayModePtr adjusted_mode)
+{
+    return TRUE;
+}
+
+static void
+via_sii164_prepare(xf86OutputPtr output)
+{
+}
+
+static void
+via_sii164_commit(xf86OutputPtr output)
+{
+}
+
+static void
+via_sii164_mode_set(xf86OutputPtr output, DisplayModePtr mode,
+                    DisplayModePtr adjusted_mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
+    VIAPtr pVia = VIAPTR(pScrn);
+    viaSiI164RecPtr pSiI164Rec = output->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_sii164_mode_set.\n"));
+
+    viaSiI164SetDisplaySource(pScrn, iga->index ? 0x01 : 0x00);
+    viaSiI164EnableIOPads(pScrn, 0x03);
+
+    via_sii164_dump_registers(pScrn, pSiI164Rec->SiI164I2CDev);
+
+    viaSiI164InitRegisters(pScrn, pSiI164Rec->SiI164I2CDev);
+
+    via_sii164_dump_registers(pScrn, pSiI164Rec->SiI164I2CDev);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Exiting via_sii164_mode_set.\n"));
+}
+
+static xf86OutputStatus
+via_sii164_detect(xf86OutputPtr output)
+{
+    xf86MonPtr mon;
+    xf86OutputStatus status = XF86OutputStatusDisconnected;
+    ScrnInfoPtr pScrn = output->scrn;
+    viaSiI164RecPtr pSiI164Rec = output->driver_private;
+
+    /* Check for the DVI presence via SiI 164 first before accessing
+     * I2C bus. */
+    if (viaSiI164Sense(pScrn, pSiI164Rec->SiI164I2CDev)) {
+
+        /* Since DVI presence was established, access the I2C bus
+         * assigned to DVI. */
+        mon = xf86OutputGetEDID(output, pSiI164Rec->SiI164I2CDev->pI2CBus);
+
+        /* Is the interface type digital? */
+        if (mon && DIGITAL(mon->features.input_type)) {
+            status = XF86OutputStatusConnected;
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Detected a monitor connected to DVI.\n");
+            xf86OutputSetEDID(output, mon);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Could not obtain EDID from a monitor "
+                        "connected to DVI.\n");
+        }
+    }
+
+    return status;
+}
+
+#ifdef RANDR_12_INTERFACE
+static Bool
+via_sii164_set_property(xf86OutputPtr output, Atom property,
+                     RRPropertyValuePtr value)
+{
+    return TRUE;
+}
+#endif
+
+#ifdef RANDR_13_INTERFACE
+static Bool
+via_sii164_get_property(xf86OutputPtr output, Atom property)
+{
+    return FALSE;
+}
+#endif
+
+static void
+via_sii164_destroy(xf86OutputPtr output)
+{
+}
+
+const xf86OutputFuncsRec via_sii164_funcs = {
+    .create_resources   = via_sii164_create_resources,
+    .dpms               = via_sii164_dpms,
+    .save               = via_sii164_save,
+    .restore            = via_sii164_restore,
+    .mode_valid         = via_sii164_mode_valid,
+    .mode_fixup         = via_sii164_mode_fixup,
+    .prepare            = via_sii164_prepare,
+    .commit             = via_sii164_commit,
+    .mode_set           = via_sii164_mode_set,
+    .detect             = via_sii164_detect,
+    .get_modes          = xf86OutputGetEDIDModes,
+#ifdef RANDR_12_INTERFACE
+    .set_property       = via_sii164_set_property,
+#endif
+#ifdef RANDR_13_INTERFACE
+    .get_property       = via_sii164_get_property,
+#endif
+    .destroy            = via_sii164_destroy,
+};
+
+Bool
+viaSiI164Init(ScrnInfoPtr pScrn, I2CBusPtr pI2CBus)
+{
+    xf86OutputPtr output;
+    VIAPtr pVia = VIAPTR(pScrn);
+    viaSiI164RecPtr pSiI164Rec = NULL;
+    I2CDevPtr pI2CDevice = NULL;
+    I2CSlaveAddr i2cAddr = 0x70;
+    CARD8 buf;
+    CARD16 vendorID, deviceID;
+    Bool status = FALSE;
+    char outputNameBuffer[32];
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaSiI164Init.\n"));
+
+    if (!xf86I2CProbeAddress(pI2CBus, i2cAddr)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "I2C device not found.\n");
+        goto exit;
+    }
+
+    pI2CDevice = xf86CreateI2CDevRec();
+    if (!pI2CDevice) {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to create an I2C bus device record.\n");
+        goto exit;
+    }
+
+    pI2CDevice->DevName = "SiI 164";
+    pI2CDevice->SlaveAddr = i2cAddr;
+    pI2CDevice->pI2CBus = pI2CBus;
+    if (!xf86I2CDevInit(pI2CDevice)) {
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to initialize a device on I2C bus.\n");
+        goto exit;
+    }
+
+    xf86I2CReadByte(pI2CDevice, 0, &buf);
+    vendorID = buf;
+    xf86I2CReadByte(pI2CDevice, 1, &buf);
+    vendorID |= buf << 8;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Vendor ID: 0x%04x\n", vendorID));
+
+    xf86I2CReadByte(pI2CDevice, 2, &buf);
+    deviceID = buf;
+    xf86I2CReadByte(pI2CDevice, 3, &buf);
+    deviceID |= buf << 8;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Device ID: 0x%04x\n", deviceID));
+
+    if ((vendorID != 0x0001) || (deviceID != 0x0006)) {
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "SiI 164 external TMDS transmitter not detected.\n");
+        goto exit;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                "SiI 164 external TMDS transmitter detected.\n");
+
+    pSiI164Rec = xnfcalloc(1, sizeof(viaSiI164Rec));
+    if (!pSiI164Rec) {
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to allocate working storage for SiI 164.\n");
+        goto exit;
+    }
+
+    // Remembering which I2C bus is used for SiI 164.
+    pSiI164Rec->SiI164I2CDev = pI2CDevice;
+
+    xf86I2CReadByte(pI2CDevice, 0x06, &buf);
+    pSiI164Rec->DotclockMin = buf * 1000;
+
+    xf86I2CReadByte(pI2CDevice, 0x07, &buf);
+    pSiI164Rec->DotclockMax = (buf + 65) * 1000;
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Supported SiI 164 Dot Clock Range: "
+                "%d to %d MHz\n",
+                pSiI164Rec->DotclockMin / 1000,
+                pSiI164Rec->DotclockMax / 1000);
+
+    /* The code to dynamically designate the particular DVI (i.e., DVI-1,
+     * DVI-2, etc.) for xrandr was borrowed from xf86-video-r128 DDX. */
+    sprintf(outputNameBuffer, "DVI-%d", (pVia->numberDVI + 1));
+    output = xf86OutputCreate(pScrn, &via_sii164_funcs, outputNameBuffer);
+    if (!output) {
+        free(pSiI164Rec);
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to allocate X Server display output record for "
+                    "SiI 164.\n");
+        goto exit;
+    }
+
+    output->driver_private = pSiI164Rec;
+
+    /* Since there are two (2) display controllers registered with the
+     * X.Org Server and both IGA1 and IGA2 can handle DVI without any
+     * limitations, possible_crtcs should be set to 0x3 (0b11) so that
+     * either display controller can get assigned to handle DVI. */
+    output->possible_crtcs = (1 << 1) | (1 << 0);
+
+    output->possible_clones = 0;
+    output->interlaceAllowed = FALSE;
+    output->doubleScanAllowed = FALSE;
+
+    via_sii164_dump_registers(pScrn, pI2CDevice);
+
+    pVia->numberDVI++;
+    status = TRUE;
+exit:
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaSiI164Init.\n"));
+    return status;
+}
diff -ruN xf86-video-openchrome-0.5.0/src/via_sii164.h xf86-video-openchrome/src/via_sii164.h
--- xf86-video-openchrome-0.5.0/src/via_sii164.h	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/via_sii164.h	2016-09-09 20:39:48.270758091 +0300
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Kevin Brace
+ * Copyright 2016 The OpenChrome Project
+ *                [http://www.freedesktop.org/wiki/Openchrome]
+ * Copyright 2014 SHS SERVICES GmbH
+ * Copyright 2006-2009 Luc Verhaegen.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _VIA_SII164_H_
+#define _VIA_SII164_H_ 1
+
+#define VIA_SII164_VEN  0x20
+#define VIA_SII164_HEN  0x10
+#define VIA_SII164_DSEL 0x08
+#define VIA_SII164_BSEL 0x04
+#define VIA_SII164_EDGE 0x02
+#define VIA_SII164_PDB  0x01
+
+typedef struct _viaSiI164 {
+	I2CDevPtr SiI164I2CDev;
+
+	int DotclockMin;
+	int DotclockMax;
+	CARD8 Register08;
+	CARD8 Register09;
+	CARD8 Register0A;
+	CARD8 Register0C;
+} viaSiI164Rec, *viaSiI164RecPtr;
+
+
+const xf86OutputFuncsRec via_sii164_funcs;
+
+Bool viaSiI164Init(ScrnInfoPtr pScrn, I2CBusPtr pI2CBus);
+
+#endif /* _VIA_SII164_H_ */
diff -ruN xf86-video-openchrome-0.5.0/src/via_tmds.c xf86-video-openchrome/src/via_tmds.c
--- xf86-video-openchrome-0.5.0/src/via_tmds.c	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/via_tmds.c	2016-09-09 20:39:48.271107207 +0300
@@ -0,0 +1,718 @@
+/*
+ * Copyright 2016 Kevin Brace
+ * Copyright 2015-2016 The OpenChrome Project
+ *                     [http://www.freedesktop.org/wiki/Openchrome]
+ * Copyright 2014 SHS SERVICES GmbH
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * via_tmds.c
+ *
+ * Handles initialization of TMDS (DVI) related resources and 
+ * controls the integrated TMDS transmitter found in CX700 and 
+ * later VIA Technologies chipsets.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <unistd.h>
+#include "via_driver.h"
+#include "via_vt1632.h"
+#include "via_sii164.h"
+
+
+/*
+	1. Formula:
+		2^13 X 0.0698uSec [1/14.318MHz] = 8192 X 0.0698uSec =572.1uSec
+		Timer = Counter x 572 uSec
+	2. Note:
+		0.0698 uSec is too small to compute for hardware. So we multiply a
+		reference value(2^13) to make it big enough to compute for hardware.
+	3. Note:
+		The meaning of the TD0~TD3 are count of the clock.
+		TD(sec) = (sec)/(per clock) x (count of clocks)
+*/
+#define TD0 200
+#define TD1 25
+#define TD2 0
+#define TD3 25
+
+
+/*
+ * Initializes most registers related to VIA Technologies IGP
+ * integrated TMDS transmitter. Synchronization polarity and
+ * display output source need to be set separately. */
+static void
+viaTMDSInitRegisters(ScrnInfoPtr pScrn)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTMDSInitRegisters.\n"));
+
+    /* Activate DVI + LVDS2 mode. */
+    /* 3X5.D2[5:4] - Display Channel Select
+     *               00: LVDS1 + LVDS2
+     *               01: DVI + LVDS2
+     *               10: One Dual LVDS Channel (High Resolution Pannel)
+     *               11: Single Channel DVI */
+    ViaCrtcMask(hwp, 0xD2, 0x10, 0x30);
+
+    /* Various DVI PLL settings should be set to default settings. */
+    /* 3X5.D1[7]   - PLL2 Reference Clock Edge Select Bit
+     *               0: PLLCK lock to rising edge of reference clock
+     *               1: PLLCK lock to falling edge of reference clock
+     * 3X5.D1[6:5] - PLL2 Charge Pump Current Set Bits
+     *               00: ICH = 12.5 uA
+     *               01: ICH = 25.0 uA
+     *               10: ICH = 37.5 uA
+     *               11: ICH = 50.0 uA
+     * 3X5.D1[4:1] - Reserved
+     * 3X5.D1[0]   - PLL2 Control Voltage Measurement Enable Bit */
+    ViaCrtcMask(hwp, 0xD1, 0x00, 0xE1);
+
+    /* Disable DVI test mode. */
+    /* 3X5.D5[7] - PD1 Enable Selection
+     *             1: Select by power flag
+     *             0: By register
+     * 3X5.D5[5] - DVI Testing Mode Enable
+     * 3X5.D5[4] - DVI Testing Format Selection
+     *             0: Half cycle
+     *             1: LFSR mode */
+    ViaCrtcMask(hwp, 0xD5, 0x00, 0xB0);
+
+    /* Disable DVI sense interrupt. */
+    /* 3C5.2B[7] - DVI Sense Interrupt Enable
+     *             0: Disable
+     *             1: Enable */
+    ViaSeqMask(hwp, 0x2B, 0x00, 0x80);
+
+    /* Clear DVI sense interrupt status. */
+    /* 3C5.2B[6] - DVI Sense Interrupt Status
+     *             (This bit has a RW1C attribute.) */
+    ViaSeqMask(hwp, 0x2B, 0x40, 0x40);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTMDSInitRegisters.\n"));
+}
+
+/*
+ * Sets the polarity of horizontal synchronization and vertical
+ * synchronization.
+ */
+static void
+viaTMDSSetSyncPolarity(ScrnInfoPtr pScrn, DisplayModePtr mode)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 cr97;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTMDSSetSyncPolarity.\n"));
+
+    /* 3X5.97[6] - DVI (TMDS) VSYNC Polarity
+     *             0: Positive
+     *             1: Negative
+     * 3X5.97[5] - DVI (TMDS) HSYNC Polarity
+     *             0: Positive
+     *             1: Negative */
+    cr97 = hwp->readCrtc(hwp, 0x97);
+    if (mode->Flags & V_NHSYNC) {
+        cr97 |= 0x20;
+    } else {
+        cr97 &= (~0x20);
+    }
+
+    if (mode->Flags & V_NVSYNC) {
+        cr97 |= 0x40;
+    } else {
+        cr97 &= (~0x40);
+    }
+
+    ViaCrtcMask(hwp, 0x97, cr97, 0x60);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTMDSSetSyncPolarity.\n"));
+}
+
+/*
+ * Sets IGA1 or IGA2 as the display output source for VIA Technologies IGP
+ * integrated TMDS transmitter.
+ */
+static void
+viaTMDSSetSource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 temp = displaySource;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTMDSSetSource.\n"));
+
+    /* Set integrated TMDS transmitter display output source.
+     * The integrated TMDS transmitter appears to utilize LVDS1's data
+     * source selection bit (3X5.99[4]). */
+    /* 3X5.99[4] - LVDS Channel1 Data Source Selection
+     *             0: Primary Display
+     *             1: Secondary Display */
+    ViaCrtcMask(hwp, 0x99, temp << 4, 0x10);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Integrated TMDS Transmitter Display Output Source: IGA%d\n",
+                (temp & 0x01) + 1);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTMDSSetSource.\n"));
+}
+
+/*
+ * Returns TMDS receiver detection state for VIA Technologies IGP
+ * integrated TMDS transmitter.
+ */
+static Bool
+viaTMDSSense(ScrnInfoPtr pScrn)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    CARD8 sr1a;
+    Bool tmdsReceiverDetected = FALSE;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTMDSSense.\n"));
+
+    /* Detect the presence of DVI. */
+    /* 3C5.1A[4] - DVI Sense
+     *             0: No connect
+     *             1: Connected */
+    sr1a = hwp->readSeq(hwp, 0x1A);
+    if (sr1a & 0x20) {
+        tmdsReceiverDetected = TRUE;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Integrated TMDS transmitter %s a TMDS receiver.\n",
+                tmdsReceiverDetected ? "detected" : "did not detect");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTMDSSense.\n"));
+    return tmdsReceiverDetected;
+}
+
+static void
+viaTMDSPower(ScrnInfoPtr pScrn, Bool powerState)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTMDSPower.\n"));
+
+    if (powerState) {
+        /* 3X5.91[7] - Software Direct On / Off Display Period
+                       in the Panel Path
+                       0: On
+                       1: Off */
+        ViaCrtcMask(hwp, 0x91, 0x00, 0x80);
+
+        /* 3X5.91[0] - Hardware or Software Control Power Sequence
+                       1: Software Control */
+        ViaCrtcMask(hwp, 0x91, 0x01, 0x01);
+
+        usleep(TD0);
+
+        /* 3X5.91[4] - Software VDD On
+                       0: Off
+                       1: On */
+        ViaCrtcMask(hwp, 0x91, 0x10, 0x10);
+
+        usleep(TD1);
+
+        /* 3X5.91[3] - Software Data On
+                       0: Off
+                       1: On */
+        ViaCrtcMask(hwp, 0x91, 0x08, 0x08);
+
+        /* 3X5.D2[3] - Power Down (Active High) for DVI
+         *             0: TMDS power on
+         *             1: TMDS power down */
+        ViaCrtcMask(hwp, 0xD2, 0x00, 0x08);
+    } else {
+        ViaCrtcMask(hwp, 0xD2, 0x08, 0x08);
+
+        ViaCrtcMask(hwp, 0x91, 0x00, 0x08);
+
+        usleep(TD1);
+
+        ViaCrtcMask(hwp, 0x91, 0x00, 0x10);
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Integrated TMDS (DVI) Power: %s\n",
+                powerState ? "On" : "Off");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTMDSPower.\n"));
+}
+
+static void
+via_tmds_create_resources(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_create_resources.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_create_resources.\n"));
+}
+
+static void
+via_tmds_dpms(xf86OutputPtr output, int mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_dpms.\n"));
+
+    switch (mode) {
+    case DPMSModeOn:
+        viaTMDSPower(pScrn, TRUE);
+        break;
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+    case DPMSModeOff:
+        viaTMDSPower(pScrn, FALSE);
+        break;
+    default:
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_dpms.\n"));
+}
+
+static void
+via_tmds_save(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_save.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_save.\n"));
+}
+
+static void
+via_tmds_restore(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_restore.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_restore.\n"));
+}
+
+static int
+via_tmds_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    int status;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_mode_valid.\n"));
+
+    if (!ViaModeDotClockTranslate(pScrn, pMode)) {
+        status = MODE_NOCLOCK;
+    } else {
+        status = MODE_OK;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_mode_valid.\n"));
+    return status;
+}
+
+static Bool
+via_tmds_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
+                      DisplayModePtr adjusted_mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_mode_fixup.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_mode_fixup.\n"));
+    return TRUE;
+}
+
+static void
+via_tmds_prepare(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_prepare.\n"));
+
+    viaTMDSPower(pScrn, FALSE);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_prepare.\n"));
+}
+
+static void
+via_tmds_commit(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_commit.\n"));
+
+    viaTMDSPower(pScrn, TRUE);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_commit.\n"));
+}
+
+static void
+via_tmds_mode_set(xf86OutputPtr output, DisplayModePtr mode,
+                    DisplayModePtr adjusted_mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_mode_set.\n"));
+
+    /* Initialize VIA IGP integrated TMDS transmitter registers. */
+    viaTMDSInitRegisters(pScrn);
+
+    /* Set integrated TMDS transmitter synchronization polarity for
+     * both horizontal synchronization and vertical synchronization. */
+    viaTMDSSetSyncPolarity(pScrn, adjusted_mode);
+
+    if (output->crtc) {
+        viaTMDSSetSource(pScrn, iga->index ? 0x01 : 0x00);
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_mode_set.\n"));
+}
+
+static xf86OutputStatus
+via_tmds_detect(xf86OutputPtr output)
+{
+    xf86MonPtr mon;
+    xf86OutputStatus status = XF86OutputStatusDisconnected;
+    ScrnInfoPtr pScrn = output->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_detect.\n"));
+
+    /* Check for DVI presence by sensing the TMDS receiver connected
+     * to the integrated TMDS transmitter. */
+    if (viaTMDSSense(pScrn)) {
+
+        if (!pVia->pI2CBus2) {
+            goto exit;
+        }
+
+        /* Assume that only I2C bus 2 is used for the DVI connected to the
+         * integrated TMDS transmitter. */
+        if (!xf86I2CProbeAddress(pVia->pI2CBus2, 0xA0)) {
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "I2C device on I2C Bus 2 does not support EDID.\n");
+            goto exit;
+        }
+
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "Obtaining EDID for DVI.\n");
+
+        /* Since DVI presence was established, access the I2C bus,
+         * in order to obtain EDID from the monitor. */
+        mon = xf86OutputGetEDID(output, pVia->pI2CBus2);
+
+        /* Is the interface type digital? */
+        if (mon && DIGITAL(mon->features.input_type)) {
+            status = XF86OutputStatusConnected;
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Detected a monitor connected to DVI.\n");
+            xf86OutputSetEDID(output, mon);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Could not obtain EDID from a monitor "
+                        "connected to DVI.\n");
+        }
+    }
+
+exit:
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_detect.\n"));
+    return status;
+}
+
+#ifdef RANDR_12_INTERFACE
+static Bool
+via_tmds_set_property(xf86OutputPtr output, Atom property,
+                     RRPropertyValuePtr value)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_set_property.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_set_property.\n"));
+    return TRUE;
+}
+#endif
+
+#ifdef RANDR_13_INTERFACE
+static Bool
+via_tmds_get_property(xf86OutputPtr output, Atom property)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_get_property.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_get_property.\n"));
+    return FALSE;
+}
+#endif
+
+static void
+via_tmds_destroy(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tmds_destroy.\n"));
+
+    if (output->driver_private) {
+        free(output->driver_private);
+    }
+
+    output->driver_private = NULL;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tmds_destroy.\n"));
+}
+
+
+
+
+static const xf86OutputFuncsRec via_tmds_funcs = {
+    .create_resources   = via_tmds_create_resources,
+    .dpms               = via_tmds_dpms,
+    .save               = via_tmds_save,
+    .restore            = via_tmds_restore,
+    .mode_valid         = via_tmds_mode_valid,
+    .mode_fixup         = via_tmds_mode_fixup,
+    .prepare            = via_tmds_prepare,
+    .commit             = via_tmds_commit,
+    .mode_set           = via_tmds_mode_set,
+    .detect             = via_tmds_detect,
+    .get_modes          = xf86OutputGetEDIDModes,
+#ifdef RANDR_12_INTERFACE
+    .set_property       = via_tmds_set_property,
+#endif
+#ifdef RANDR_13_INTERFACE
+    .get_property       = via_tmds_get_property,
+#endif
+    .destroy            = via_tmds_destroy,
+};
+
+
+Bool
+viaTMDSInit(ScrnInfoPtr pScrn)
+{
+    xf86OutputPtr output;
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    VIATMDSRecPtr pVIATMDSRec = NULL;
+    CARD8 sr13, sr5a, cr3e;
+    Bool status = FALSE;
+    char outputNameBuffer[32];
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTMDSInit.\n"));
+
+    sr5a = hwp->readSeq(hwp, 0x5A);
+    ViaSeqMask(hwp, 0x5A, sr5a | 0x01, 0x01);
+
+    /* 3C5.13[7:6] - Integrated LVDS / DVI Mode Select
+     *               (DVP1D15-14 pin strapping)
+     *               00: LVDS1 + LVDS2
+     *               01: DVI + LVDS2
+     *               10: Dual LVDS Channel (High Resolution Panel)
+     *               11: One DVI only (decrease the clock jitter) */
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    hwp->writeSeq(hwp, 0x5A, sr5a);
+    sr13 &= 0xC0;
+    if ((sr13 == 0x40) || (sr13 == 0xC0)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "Integrated TMDS transmitter found via pin strapping.\n");
+    } else {
+        /* 3X5.3E[5] supposedly signals the presence of
+         * a DVI connector coming from an integrated TMDS transmitter.
+         * This check is done if the pin strapping does not indicate
+         * the presence of a DVI connector. Note that 3X5.3E is set by
+         * VIA Technologies VGA BIOS. */
+        cr3e = hwp->readCrtc(hwp, 0x3E);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "CR3E: 0x%02X\n", cr3e));
+        if (cr3e & 0x20) {
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Integrated TMDS transmitter found via "
+                        "VIA Technologies VGA BIOS scratch pad register.\n");
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Integrated TMDS transmitter not found.\n");
+            goto exit;
+        }
+    }
+
+    pVIATMDSRec = xnfcalloc(1, sizeof(VIATMDSRec));
+    if (!pVIATMDSRec) {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to allocate working storage for integrated "
+                    "TMDS transmitter.\n");
+        goto exit;
+    }
+
+    /* The code to dynamically designate the particular DVI (i.e., DVI-1,
+     * DVI-2, etc.) for xrandr was borrowed from xf86-video-r128 DDX. */
+    sprintf(outputNameBuffer, "DVI-%d", (pVia->numberDVI + 1));
+    output = xf86OutputCreate(pScrn, &via_tmds_funcs, outputNameBuffer);
+    if (!output) {
+        free(pVIATMDSRec);
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to allocate X Server display output record for "
+                    "integrated TMDS transmitter.\n");
+        goto exit;
+    }
+
+    output->driver_private = pVIATMDSRec;
+
+    /* Since there are two (2) display controllers registered with the
+     * X.Org Server and both IGA1 and IGA2 can handle DVI without any
+     * limitations, possible_crtcs should be set to 0x3 (0b11) so that
+     * either display controller can get assigned to handle DVI. */
+    output->possible_crtcs = (1 << 1) | (1 << 0);
+
+    output->possible_clones = 0;
+    output->interlaceAllowed = FALSE;
+    output->doubleScanAllowed = FALSE;
+
+    pVia->numberDVI++;
+    status = TRUE;
+exit:
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTMDSInit.\n"));
+    return status;
+}
+
+void
+via_dvi_init(ScrnInfoPtr pScrn)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_dvi_init.\n"));
+
+    if (!pVia->pI2CBus2 || !pVia->pI2CBus3) {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "I2C Bus 2 or I2C Bus 3 does not exist.\n");
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "Exiting via_dvi_init.\n"));
+        return;
+    }
+
+    /* Check to see if we are dealing with the latest VIA chipsets. */
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        if (!viaTMDSInit(pScrn)) {
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Integrated TMDS transmitter for DVI not found.\n");
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Integrated TMDS transmitter for DVI was "
+                        "initialized successfully.\n");
+        }
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Probing I2C Bus 2 for VT1632.\n");
+    if (!viaVT1632Init(pScrn, pVia->pI2CBus2)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "I2C Bus 2 was not initialized for DVI use.\n");
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "VT1632 attached to I2C Bus 2 was initialized "
+                    "successfully for DVI use.\n");
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Probing I2C Bus 3 for VT1632.\n");
+    if (!viaVT1632Init(pScrn, pVia->pI2CBus3)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "I2C Bus 3 was not initialized for DVI use.\n");
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "VT1632 attached to I2C Bus 3 was initialized "
+                    "successfully for DVI use.\n");
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Probing I2C Bus 2 for SiI 164.\n");
+    if (!viaSiI164Init(pScrn, pVia->pI2CBus2)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "I2C Bus 2 was not initialized for DVI use.\n");
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "SiI 164 attached to I2C Bus 2 was initialized "
+                    "successfully for DVI use.\n");
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Probing I2C Bus 3 for SiI 164.\n");
+    if (!viaSiI164Init(pScrn, pVia->pI2CBus3)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "I2C Bus 3 was not initialized for DVI use.\n");
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                    "SiI 164 attached to I2C Bus 3 was initialized "
+                    "successfully for DVI use.\n");
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_dvi_init.\n"));
+}
diff -ruN xf86-video-openchrome-0.5.0/src/via_tv.c xf86-video-openchrome/src/via_tv.c
--- xf86-video-openchrome-0.5.0/src/via_tv.c	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/via_tv.c	2016-09-09 20:39:48.271433578 +0300
@@ -0,0 +1,668 @@
+/*
+ * Copyright 2005-2016 The OpenChrome Project
+ *                     [http://www.freedesktop.org/wiki/Openchrome]
+ * Copyright 2004-2005 The Unichrome Project  [unichrome.sf.net]
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * via_tv.c
+ *
+ * Handles the initialization and management of TV output related
+ * resources.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "via_driver.h"
+#include <unistd.h>
+
+static void
+viaTVSetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
+{
+
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 sr12, sr13, sr5a;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTVSetDisplaySource.\n"));
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        sr5a = hwp->readSeq(hwp, 0x5A);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "SR5A: 0x%02X\n", sr5a));
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Setting 3C5.5A[0] to 0.\n"));
+        ViaSeqMask(hwp, 0x5A, sr5a & 0xFE, 0x01);
+    }
+
+    sr12 = hwp->readSeq(hwp, 0x12);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR12: 0x%02X\n", sr12));
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+        /* 3C5.12[5] - FPD18 pin strapping
+         *             0: DIP0 (Digital Interface Port 0) is used by
+         *                a TMDS transmitter (DVI)
+         *             1: DIP0 (Digital Interface Port 0) is used by
+         *                a TV encoder */
+        if (sr12 & 0x20) {
+            viaDIP0SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DIP0 was not set up for "
+                        "an external TV encoder use.\n");
+        }
+
+        break;
+    case VIA_KM400:
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+        /* 3C5.13[3] - DVP0D8 pin strapping
+         *             0: AGP pins are used for AGP
+         *             1: AGP pins are used by FPDP
+         *                (Flat Panel Display Port)
+         * 3C5.12[6] - DVP0D6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - DVP0D5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - DVP0D4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP  (Flat Panel Display Port) */
+        if ((sr12 & 0x40) && (sr12 & 0x20)) {
+            viaDVP0SetDisplaySource(pScrn, displaySource);
+        } else if ((sr13 & 0x08) && (!(sr12 & 0x10))) {
+            viaDFPLowSetDisplaySource(pScrn, displaySource);
+        } else if (sr13 & 0x08) {
+            viaDVP1SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "external TV encoder use.\n");
+        }
+
+        break;
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+        /* 3C5.12[6] - FPD6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - FPD5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - FPD4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP  (Flat Panel Display Port) */
+        if ((sr12 & 0x40) & (sr12 & 0x20) &(!(sr12 & 0x10))) {
+            viaDVP0SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "Unrecognized external TV encoder use.\n"
+                        "Contact the developer for assistance.\n");
+        }
+
+        break;
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.13[6] - DVP1 DVP / capture port selection
+         *             0: DVP1 is used as a DVP (Digital Video Port)
+         *             1: DVP1 is used as a capture port
+         */
+        if (!(sr13 & 0x40)) {
+            viaDVP1SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DVP1 is not set up for external TV "
+                        "encoder use.\n");
+        }
+
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Unrecognized IGP for "
+                    "an external TV encoder use.\n");
+        break;
+    }
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        hwp->writeSeq(hwp, 0x5A, sr5a);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Restoring 3C5.5A[0].\n"));
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTVSetDisplaySource.\n"));
+}
+
+static void
+viaTVEnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
+{
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 sr12, sr13, sr5a;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaTVEnableIOPads.\n"));
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        sr5a = hwp->readSeq(hwp, 0x5A);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "SR5A: 0x%02X\n", sr5a));
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Setting 3C5.5A[0] to 0.\n"));
+        ViaSeqMask(hwp, 0x5A, sr5a & 0xFE, 0x01);
+    }
+
+    sr12 = hwp->readSeq(hwp, 0x12);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR12: 0x%02X\n", sr12));
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+        /* 3C5.12[5] - FPD18 pin strapping
+         *             0: DIP0 (Digital Interface Port 0) is used by
+         *                a TMDS transmitter (DVI)
+         *             1: DIP0 (Digital Interface Port 0) is used by
+         *                a TV encoder */
+        if (sr12 & 0x20) {
+            viaDIP0EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DIP0 is not set up for "
+                        "an external TV encoder use.\n");
+        }
+
+        break;
+    case VIA_KM400:
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+        /* 3C5.13[3] - DVP0D8 pin strapping
+         *             0: AGP pins are used for AGP
+         *             1: AGP pins are used by FPDP
+         *                (Flat Panel Display Port)
+         * 3C5.12[6] - DVP0D6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - DVP0D5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - DVP0D4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP (Flat Panel Display Port) */
+        if ((sr12 & 0x40) && (sr12 & 0x20)) {
+            viaDVP0EnableIOPads(pScrn, ioPadState);
+        } else if ((sr13 & 0x08) && (!(sr12 & 0x10))) {
+            viaDFPLowEnableIOPads(pScrn, ioPadState);
+        } else if (sr13 & 0x08) {
+            viaDVP1EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "external TV encoder use.\n");
+        }
+
+        break;
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+        /* 3C5.12[6] - FPD6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - FPD5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - FPD4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP (Flat Panel Display Port) */
+        if ((sr12 & 0x40) & (sr12 & 0x20) &(!(sr12 & 0x10))) {
+            viaDVP0EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "Unrecognized external TV encoder use.\n"
+                        "Contact the developer for assistance.\n");
+        }
+
+        break;
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.13[6] - DVP1 DVP / capture port selection
+         *             0: DVP1 is used as a DVP (Digital Video Port)
+         *             1: DVP1 is used as a capture port
+         */
+        if (!(sr13 & 0x40)) {
+            viaDVP1EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DVP1 is not set up for external TV "
+                        "encoder use.\n");
+        }
+
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Unrecognized IGP for "
+                    "an external TV encoder use.\n");
+        break;
+    }
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        hwp->writeSeq(hwp, 0x5A, sr5a);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Restoring 3C5.5A[0].\n"));
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaTVEnableIOPads.\n"));
+}
+
+static void
+ViaTVSave(ScrnInfoPtr pScrn)
+{
+    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
+
+    if (pBIOSInfo->TVSave)
+        pBIOSInfo->TVSave(pScrn);
+}
+
+static void
+ViaTVRestore(ScrnInfoPtr pScrn)
+{
+    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
+
+    if (pBIOSInfo->TVRestore)
+        pBIOSInfo->TVRestore(pScrn);
+}
+
+static Bool
+ViaTVDACSense(ScrnInfoPtr pScrn)
+{
+    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
+
+    if (pBIOSInfo->TVDACSense)
+        return pBIOSInfo->TVDACSense(pScrn);
+    return FALSE;
+}
+
+static void
+ViaTVSetMode(xf86CrtcPtr crtc, DisplayModePtr mode)
+{
+    ScrnInfoPtr pScrn = crtc->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
+
+    if (pBIOSInfo->TVModeI2C)
+        pBIOSInfo->TVModeI2C(pScrn, mode);
+
+    if (pBIOSInfo->TVModeCrtc)
+        pBIOSInfo->TVModeCrtc(crtc, mode);
+
+    /* TV reset. */
+    xf86I2CWriteByte(pBIOSInfo->TVI2CDev, 0x1D, 0x00);
+    xf86I2CWriteByte(pBIOSInfo->TVI2CDev, 0x1D, 0x80);
+}
+
+static void
+ViaTVPower(ScrnInfoPtr pScrn, Bool On)
+{
+    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
+
+#ifdef HAVE_DEBUG
+    if (On)
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaTVPower: On.\n");
+    else
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaTVPower: Off.\n");
+#endif
+
+    if (pBIOSInfo->TVPower)
+        pBIOSInfo->TVPower(pScrn, On);
+}
+
+#ifdef HAVE_DEBUG
+void
+ViaTVPrintRegs(ScrnInfoPtr pScrn)
+{
+    VIABIOSInfoPtr pBIOSInfo = VIAPTR(pScrn)->pBIOSInfo;
+
+    if (pBIOSInfo->TVPrintRegs)
+        pBIOSInfo->TVPrintRegs(pScrn);
+}
+#endif /* HAVE_DEBUG */
+
+static void
+via_tv_create_resources(xf86OutputPtr output)
+{
+}
+
+#ifdef RANDR_12_INTERFACE
+static Bool
+via_tv_set_property(xf86OutputPtr output, Atom property,
+                    RRPropertyValuePtr value)
+{
+    return TRUE;
+}
+
+static Bool
+via_tv_get_property(xf86OutputPtr output, Atom property)
+{
+    return FALSE;
+}
+#endif
+
+static void
+via_tv_dpms(xf86OutputPtr output, int mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    switch (mode) {
+    case DPMSModeOn:
+        ViaTVPower(pScrn, TRUE);
+        break;
+
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+    case DPMSModeOff:
+        ViaTVPower(pScrn, FALSE);
+        break;
+    }
+}
+
+static void
+via_tv_save(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    ViaTVSave(pScrn);
+}
+
+static void
+via_tv_restore(xf86OutputPtr output)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+
+    ViaTVRestore(pScrn);
+}
+
+static int
+via_tv_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    int ret = MODE_OK;
+
+    if (!ViaModeDotClockTranslate(pScrn, pMode))
+        return MODE_NOCLOCK;
+
+    return ret;
+}
+
+static Bool
+via_tv_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
+                  DisplayModePtr adjusted_mode)
+{
+    return TRUE;
+}
+
+static void
+via_tv_prepare(xf86OutputPtr output)
+{
+    via_tv_dpms(output, DPMSModeOff);
+}
+
+static void
+via_tv_commit(xf86OutputPtr output)
+{
+    via_tv_dpms(output, DPMSModeOn);
+}
+
+static void
+via_tv_mode_set(xf86OutputPtr output, DisplayModePtr mode,
+                DisplayModePtr adjusted_mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
+    VIAPtr pVia = VIAPTR(pScrn);
+
+    /* TV on FirstCrtc */
+    if (output->crtc) {
+        viaTVSetDisplaySource(pScrn, iga->index ? 0x01 : 0x00);
+
+        /* Set I/O pads to automatic on / off mode. */
+        viaTVEnableIOPads(pScrn, 0x03);
+        ViaTVSetMode(output->crtc, adjusted_mode);
+    }
+
+    pVia->FirstInit = FALSE;
+}
+
+static xf86OutputStatus
+via_tv_detect(xf86OutputPtr output)
+{
+    xf86OutputStatus status = XF86OutputStatusDisconnected;
+    ScrnInfoPtr pScrn = output->scrn;
+
+    if (ViaTVDACSense(pScrn))
+        status = XF86OutputStatusConnected;
+    return status;
+}
+
+static DisplayModePtr
+via_tv_get_modes(xf86OutputPtr output)
+{
+    DisplayModePtr modes = NULL, mode = NULL;
+    ScrnInfoPtr pScrn = output->scrn;
+    VIAPtr pVia = VIAPTR(pScrn);
+    int i;
+
+    for (i = 0; i < pVia->pBIOSInfo->TVNumModes; i++) {
+        mode = xf86DuplicateMode(&pVia->pBIOSInfo->TVModes[i]);
+        modes = xf86ModesAdd(modes, mode);
+    }
+    return modes;
+}
+
+static void
+via_tv_destroy(xf86OutputPtr output)
+{
+}
+
+static const xf86OutputFuncsRec via_tv_funcs = {
+    .create_resources   = via_tv_create_resources,
+#ifdef RANDR_12_INTERFACE
+    .set_property       = via_tv_set_property,
+#endif
+#ifdef RANDR_13_INTERFACE
+    .get_property       = via_tv_get_property,
+#endif
+    .dpms               = via_tv_dpms,
+    .save               = via_tv_save,
+    .restore            = via_tv_restore,
+    .mode_valid         = via_tv_mode_valid,
+    .mode_fixup         = via_tv_mode_fixup,
+    .prepare            = via_tv_prepare,
+    .commit             = via_tv_commit,
+    .mode_set           = via_tv_mode_set,
+    .detect             = via_tv_detect,
+    .get_modes          = via_tv_get_modes,
+    .destroy            = via_tv_destroy,
+};
+
+/*
+ *
+ */
+Bool
+via_tv_init(ScrnInfoPtr pScrn)
+{
+    VIAPtr pVia = VIAPTR(pScrn);
+    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
+    xf86OutputPtr output = NULL;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_tv_init.\n"));
+
+    /* preset some pBIOSInfo TV related values -- move up */
+    pBIOSInfo->TVEncoder = VIA_NONETV;
+    pBIOSInfo->TVI2CDev = NULL;
+    pBIOSInfo->TVSave = NULL;
+    pBIOSInfo->TVRestore = NULL;
+    pBIOSInfo->TVDACSense = NULL;
+    pBIOSInfo->TVModeValid = NULL;
+    pBIOSInfo->TVModeI2C = NULL;
+    pBIOSInfo->TVModeCrtc = NULL;
+    pBIOSInfo->TVPower = NULL;
+    pBIOSInfo->TVModes = NULL;
+    pBIOSInfo->TVPrintRegs = NULL;
+    pBIOSInfo->LCDPower = NULL;
+    pBIOSInfo->TVNumRegs = 0;
+
+    /*
+     * On an SK43G (KM400/Ch7011), false positive detections at a VT162x
+     * chip were observed, so try to detect the Ch7011 first.
+     */
+    if (pVia->pI2CBus2 && xf86I2CProbeAddress(pVia->pI2CBus2, 0xEC))
+        pBIOSInfo->TVI2CDev = ViaCH7xxxDetect(pScrn, pVia->pI2CBus2, 0xEC);
+    else if (pVia->pI2CBus2 && xf86I2CProbeAddress(pVia->pI2CBus2, 0x40))
+        pBIOSInfo->TVI2CDev = ViaVT162xDetect(pScrn, pVia->pI2CBus2, 0x40);
+    else if (pVia->pI2CBus3 && xf86I2CProbeAddress(pVia->pI2CBus3, 0x40))
+        pBIOSInfo->TVI2CDev = ViaVT162xDetect(pScrn, pVia->pI2CBus3, 0x40);
+    else if (pVia->pI2CBus2 && xf86I2CProbeAddress(pVia->pI2CBus2, 0xEA))
+        pBIOSInfo->TVI2CDev = ViaCH7xxxDetect(pScrn, pVia->pI2CBus2, 0xEA);
+    else if (pVia->pI2CBus3 && xf86I2CProbeAddress(pVia->pI2CBus3, 0xEA))
+        pBIOSInfo->TVI2CDev = ViaCH7xxxDetect(pScrn, pVia->pI2CBus3, 0xEA);
+
+    if (!pBIOSInfo->TVI2CDev) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "Did not detect a TV encoder.\n");
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Exiting via_tv_init.\n"));
+
+        return FALSE;
+    }
+
+    switch (pBIOSInfo->TVEncoder) {
+        case VIA_VT1621:
+        case VIA_VT1622:
+        case VIA_VT1623:
+        case VIA_VT1625:
+            ViaVT162xInit(pScrn);
+            break;
+        case VIA_CH7011:
+        case VIA_CH7019A:
+        case VIA_CH7019B:
+            ViaCH7xxxInit(pScrn);
+            break;
+        default:
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "Was not able to initialize a known TV encoder.\n");
+            DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                                "Exiting via_tv_init.\n"));
+            return FALSE;
+            break;
+    }
+
+    if (!pBIOSInfo->TVSave || !pBIOSInfo->TVRestore
+        || !pBIOSInfo->TVDACSense || !pBIOSInfo->TVModeValid
+        || !pBIOSInfo->TVModeI2C || !pBIOSInfo->TVModeCrtc
+        || !pBIOSInfo->TVPower || !pBIOSInfo->TVModes
+        || !pBIOSInfo->TVPrintRegs) {
+
+        xf86DestroyI2CDevRec(pBIOSInfo->TVI2CDev, TRUE);
+
+        pBIOSInfo->TVI2CDev = NULL;
+        pBIOSInfo->TVOutput = TVOUTPUT_NONE;
+        pBIOSInfo->TVEncoder = VIA_NONETV;
+        pBIOSInfo->TVI2CDev = NULL;
+        pBIOSInfo->TVSave = NULL;
+        pBIOSInfo->TVRestore = NULL;
+        pBIOSInfo->TVDACSense = NULL;
+        pBIOSInfo->TVModeValid = NULL;
+        pBIOSInfo->TVModeI2C = NULL;
+        pBIOSInfo->TVModeCrtc = NULL;
+        pBIOSInfo->TVPower = NULL;
+        pBIOSInfo->TVModes = NULL;
+        pBIOSInfo->TVPrintRegs = NULL;
+        pBIOSInfo->TVNumRegs = 0;
+
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                   "TV encoder was not properly initialized.\n");
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Exiting via_tv_init.\n"));
+        return FALSE;
+    }
+
+    output = xf86OutputCreate(pScrn, &via_tv_funcs, "TV-1");
+    pVia->FirstInit = TRUE;
+
+    if (output) {
+        /* Allow tv output on both crtcs, set bit 0 and 1. */
+        output->possible_crtcs = 0x3;
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                   "Failed to register TV-1.\n");
+    }
+
+    pBIOSInfo->tv = output;
+    /* Save now */
+    pBIOSInfo->TVSave(pScrn);
+
+#ifdef HAVE_DEBUG
+    if (VIAPTR(pScrn)->PrintTVRegs)
+        pBIOSInfo->TVPrintRegs(pScrn);
+#endif
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_tv_init.\n"));
+    return TRUE;
+}
diff -ruN xf86-video-openchrome-0.5.0/src/via_ums.c xf86-video-openchrome/src/via_ums.c
--- xf86-video-openchrome-0.5.0/src/via_ums.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_ums.c	2016-09-09 20:39:48.271833927 +0300
@@ -186,7 +186,7 @@
 
     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
                "Mapping the frame buffer at address 0x%lX with "
-               "size %u KB.\n",
+               "size %lu KB.\n",
                pVia->FrameBufferBase, pVia->videoRambytes / 1024);
 
 #ifdef HAVE_PCIACCESS
@@ -277,9 +277,6 @@
 
     viaMMIOEnable(pScrn);
 
-    /* Unlock CRTC. */
-    ViaCrtcMask(hwp, 0x47, 0x00, 0x01);
-
     vgaHWGetIOBase(hwp);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -1018,36 +1015,6 @@
     iga2_rec->index = 1;
     iga2->driver_private = iga2_rec;
 
-    /* Init HI_X0 for cursor */
-    switch (pVia->Chipset) {
-    case VIA_CX700:
-    /* case VIA_CN750: */
-    case VIA_P4M890:
-    case VIA_P4M900:
-    case VIA_VX800:
-    case VIA_VX855:
-    case VIA_VX900:
-        /* set 0 as transparent color key for IGA 2 */
-        VIASETREG(HI_TRANSPARENT_COLOR, 0);
-        VIASETREG(HI_INVTCOLOR, 0X00FFFFFF);
-        VIASETREG(ALPHA_V3_PREFIFO_CONTROL, 0xE0000);
-        VIASETREG(ALPHA_V3_FIFO_CONTROL, 0xE0F0000);
-
-        /* set 0 as transparent color key for IGA 1 */
-        VIASETREG(PRIM_HI_TRANSCOLOR, 0);
-        VIASETREG(PRIM_HI_FIFO, 0x0D000D0F);
-        VIASETREG(PRIM_HI_INVTCOLOR, 0x00FFFFFF);
-        VIASETREG(V327_HI_INVTCOLOR, 0x00FFFFFF);
-        break;
-
-    default:
-        VIASETREG(HI_TRANSPARENT_COLOR, 0);
-        VIASETREG(HI_INVTCOLOR, 0X00FFFFFF);
-        VIASETREG(ALPHA_V3_PREFIFO_CONTROL, 0xE0000);
-        VIASETREG(ALPHA_V3_FIFO_CONTROL, 0xE0F0000);
-        break;
-    }
-
     /*
      * CLE266A:
      *   Max Line Pitch: 4080, (FB corruption when higher, driver problem?)
diff -ruN xf86-video-openchrome-0.5.0/src/via_ums.h xf86-video-openchrome/src/via_ums.h
--- xf86-video-openchrome-0.5.0/src/via_ums.h	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_ums.h	2016-09-09 20:39:48.272051489 +0300
@@ -116,11 +116,21 @@
 #define     VIA_DI_PORT_DVP0        0x1
 #define     VIA_DI_PORT_DVP1        0x2
 #define     VIA_DI_PORT_DFPLOW      0x4
+#define     VIA_DI_PORT_LVDS1       0x4
+#define     VIA_DI_PORT_TMDS        0x4
 #define     VIA_DI_PORT_DFPHIGH     0x8
+#define     VIA_DI_PORT_LVDS2       0x8
+
+/* External TMDS (DVI) Transmitter Type */
+#define     VIA_TMDS_NONE           0x0
+#define     VIA_TMDS_VT1632         0x1
+
 
 typedef struct ViaPanelMode {
-    int Width ;
-    int Height ;
+    int Width;
+    int Height;
+    Bool useDualEdge;
+    Bool useDithering;
 } ViaPanelModeRec, *ViaPanelModePtr ;
 
 typedef struct ViaPanelInfo {
@@ -128,6 +138,9 @@
     /* Native physical resolution */
     int NativeHeight;
     int NativeWidth;
+    Bool useDualEdge;
+    Bool useDithering;
+
     /* Native resolution index, see via_panel.c */
     CARD8 NativeModeIndex;
     /* Determine if we must use the hardware scaler
@@ -163,7 +176,6 @@
     int         TVDeflicker;
     CARD8       TVRegs[0xFF];
     int         TVNumRegs;
-    int         TVDIPort;
 
     /* TV Callbacks */
     void (*TVSave) (ScrnInfoPtr pScrn);
@@ -180,6 +192,14 @@
 
 } VIABIOSInfoRec, *VIABIOSInfoPtr;
 
+
+typedef struct _VIATMDSRec {
+    I2CBusPtr pVIATMDSI2CBus;
+} VIATMDSRec, *VIATMDSRecPtr;
+
+
+
+
 /* via_ums.c */
 void viaUnmapMMIO(ScrnInfoPtr pScrn);
 void viaDisableVQ(ScrnInfoPtr pScrn);
@@ -189,16 +209,17 @@
 Bool umsCrtcInit(ScrnInfoPtr pScrn);
 
 /* via_output.c */
+void viaDIP0SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource);
+void viaDIP0EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState);
+void viaDVP0SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource);
+void viaDVP0EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState);
+void viaDVP1SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource);
+void viaDVP1EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState);
+void viaDFPLowSetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource);
+void viaDFPLowEnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState);
 void viaOutputDetect(ScrnInfoPtr pScrn);
 CARD32 ViaGetMemoryBandwidth(ScrnInfoPtr pScrn);
 CARD32 ViaModeDotClockTranslate(ScrnInfoPtr pScrn, DisplayModePtr mode);
-void viaTMDSPower(ScrnInfoPtr pScrn, Bool On);
-void ViaTVPower(ScrnInfoPtr pScrn, Bool On);
-void ViaTVSave(ScrnInfoPtr pScrn);
-void ViaTVRestore(ScrnInfoPtr pScrn);
-#ifdef HAVE_DEBUG
-void ViaTVPrintRegs(ScrnInfoPtr pScrn);
-#endif
 void viaProbePinStrapping(ScrnInfoPtr pScrn);
 void ViaSetPrimaryDotclock(ScrnInfoPtr pScrn, CARD32 clock);
 void ViaSetSecondaryDotclock(ScrnInfoPtr pScrn, CARD32 clock);
@@ -224,9 +245,21 @@
 void viaIGA2Restore(ScrnInfoPtr pScrn);
 void ViaShadowCRTCSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode);
 
+/* via_analog.c */
+void via_analog_init(ScrnInfoPtr pScrn);
+
 /* via_lvds.c */
 void via_lvds_init(ScrnInfoPtr pScrn);
 
+/* via_tmds.c */
+void via_dvi_init(ScrnInfoPtr pScrn);
+
+/*via_tv.c */
+#ifdef HAVE_DEBUG
+void ViaTVPrintRegs(ScrnInfoPtr pScrn);
+#endif
+Bool via_tv_init(ScrnInfoPtr pScrn);
+
 /* in via_bandwidth.c */
 void ViaSetPrimaryFIFO(ScrnInfoPtr pScrn, DisplayModePtr mode);
 void ViaSetSecondaryFIFO(ScrnInfoPtr pScrn, DisplayModePtr mode);
diff -ruN xf86-video-openchrome-0.5.0/src/via_vt162x.c xf86-video-openchrome/src/via_vt162x.c
--- xf86-video-openchrome-0.5.0/src/via_vt162x.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_vt162x.c	2016-09-09 20:39:48.272887356 +0300
@@ -48,18 +48,15 @@
                 case VIA_CX700:
                 case VIA_VX800:
                 case VIA_VX855:
-					/* IGA1 */
+                case VIA_VX900:
+                    /* IGA1 */
                     if (!iga->index) {
-                        if(pBIOSInfo->TVDIPort == VIA_DI_PORT_DVP1)
-                            ViaCrtcMask(hwp, 0x6C, 0xB0, 0xF0);
-                        else if(pBIOSInfo->TVDIPort == VIA_DI_PORT_DVP0)
-                            ViaCrtcMask(hwp, 0x6C, 0x90, 0xF0);
+                        /* Fixing it to DVP1 for IGA1. */
+                        ViaCrtcMask(hwp, 0x6C, 0xB0, 0xF0);
+                    /* IGA2 */
                     } else {
-                        /* IGA2 */
-                        if(pBIOSInfo->TVDIPort == VIA_DI_PORT_DVP1)
-                            ViaCrtcMask(hwp, 0x6C, 0x0B, 0x0F);
-                        else if(pBIOSInfo->TVDIPort == VIA_DI_PORT_DVP0)
-                            ViaCrtcMask(hwp, 0x6C, 0x09, 0x0F);
+                        /* Fixing it to DVP1 for IGA2. */
+                        ViaCrtcMask(hwp, 0x6C, 0x0B, 0x0F);
                     }
                     break;
                 default:
diff -ruN xf86-video-openchrome-0.5.0/src/via_vt1632.c xf86-video-openchrome/src/via_vt1632.c
--- xf86-video-openchrome-0.5.0/src/via_vt1632.c	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_vt1632.c	2016-09-10 02:42:52.036618308 +0300
@@ -1,5 +1,9 @@
 /*
+ * Copyright 2016 Kevin Brace
+ * Copyright 2016 The OpenChrome Project
+ *                [http://www.freedesktop.org/wiki/Openchrome]
  * Copyright 2014 SHS SERVICES GmbH
+ * Copyright 2006-2009 Luc Verhaegen.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -28,20 +32,268 @@
 #include "via_driver.h"
 #include "via_vt1632.h"
 
-static Bool
-xf86I2CMaskByte(I2CDevPtr d, I2CByte subaddr, I2CByte value, I2CByte mask)
+static void
+viaVT1632SetDisplaySource(ScrnInfoPtr pScrn, CARD8 displaySource)
 {
-    I2CByte tmp;
-    Bool ret;
 
-    ret = xf86I2CReadByte(d, subaddr, &tmp);
-    if (!ret)
-        return FALSE;
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 sr12, sr13, sr5a;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaVT1632SetDisplaySource.\n"));
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        sr5a = hwp->readSeq(hwp, 0x5A);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "SR5A: 0x%02X\n", sr5a));
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Setting 3C5.5A[0] to 0.\n"));
+        ViaSeqMask(hwp, 0x5A, sr5a & 0xFE, 0x01);
+    }
+
+    sr12 = hwp->readSeq(hwp, 0x12);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR12: 0x%02X\n", sr12));
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+        /* 3C5.12[5] - FPD18 pin strapping
+         *             0: DIP0 (Digital Interface Port 0) is used by
+         *                a TMDS transmitter (DVI)
+         *             1: DIP0 (Digital Interface Port 0) is used by
+         *                a TV encoder */
+        if (!(sr12 & 0x20)) {
+            viaDIP0SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DIP0 was not set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_KM400:
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+        /* 3C5.13[3] - DVP0D8 pin strapping
+         *             0: AGP pins are used for AGP
+         *             1: AGP pins are used by FPDP
+         *                (Flat Panel Display Port)
+         * 3C5.12[6] - DVP0D6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - DVP0D5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - DVP0D4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP (Flat Panel Display Port) */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0SetDisplaySource(pScrn, displaySource);
+        } else if ((sr13 & 0x08) && (!(sr12 & 0x10))) {
+            viaDFPLowSetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+        /* 3C5.12[6] - FPD6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - FPD5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0SetDisplaySource(pScrn, displaySource);
+        } else if (!(sr12 & 0x10)) {
+            viaDFPLowSetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.13[6] - DVP1 DVP / capture port selection
+         *             0: DVP1 is used as a DVP (Digital Video Port)
+         *             1: DVP1 is used as a capture port
+         */
+        if (!(sr13 & 0x40)) {
+            viaDVP1SetDisplaySource(pScrn, displaySource);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DVP1 is not set up for TMDS "
+                        "transmitter use.\n");
+        }
+
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Unrecognized IGP for "
+                    "TMDS transmitter use.\n");
+        break;
+    }
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        hwp->writeSeq(hwp, 0x5A, sr5a);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Restoring 3C5.5A[0].\n"));
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632SetDisplaySource.\n"));
+}
+
+static void
+viaVT1632EnableIOPads(ScrnInfoPtr pScrn, CARD8 ioPadState)
+{
+
+    vgaHWPtr hwp = VGAHWPTR(pScrn);
+    VIAPtr pVia = VIAPTR(pScrn);
+    CARD8 sr12, sr13, sr5a;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaVT1632EnableIOPads.\n"));
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        sr5a = hwp->readSeq(hwp, 0x5A);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "SR5A: 0x%02X\n", sr5a));
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Setting 3C5.5A[0] to 0.\n"));
+        ViaSeqMask(hwp, 0x5A, sr5a & 0xFE, 0x01);
+    }
 
-    tmp &= ~mask;
-    tmp |= (value & mask);
+    sr12 = hwp->readSeq(hwp, 0x12);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR12: 0x%02X\n", sr12));
+    sr13 = hwp->readSeq(hwp, 0x13);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "SR13: 0x%02X\n", sr13));
+    switch (pVia->Chipset) {
+    case VIA_CLE266:
+        /* 3C5.12[5] - FPD18 pin strapping
+         *             0: DIP0 (Digital Interface Port 0) is used by
+         *                a TMDS transmitter (DVI)
+         *             1: DIP0 (Digital Interface Port 0) is used by
+         *                a TV encoder */
+        if (!(sr12 & 0x20)) {
+            viaDIP0EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DIP0 was not set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_KM400:
+    case VIA_K8M800:
+    case VIA_PM800:
+    case VIA_P4M800PRO:
+        /* 3C5.13[3] - DVP0D8 pin strapping
+         *             0: AGP pins are used for AGP
+         *             1: AGP pins are used by FPDP
+         *                (Flat Panel Display Port)
+         * 3C5.12[6] - DVP0D6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - DVP0D5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder
+         * 3C5.12[4] - DVP0D4 pin strapping
+         *             0: Dual 12-bit FPDP (Flat Panel Display Port)
+         *             1: 24-bit FPDP (Flat Panel Display Port) */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0EnableIOPads(pScrn, ioPadState);
+        } else if ((sr13 & 0x08) && (!(sr12 & 0x10))) {
+            viaDFPLowEnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_P4M890:
+    case VIA_K8M890:
+    case VIA_P4M900:
+        /* 3C5.12[6] - FPD6 pin strapping
+         *             0: Disable DVP0 (Digital Video Port 0)
+         *             1: Enable DVP0 (Digital Video Port 0)
+         * 3C5.12[5] - FPD5 pin strapping
+         *             0: DVP0 is used by a TMDS transmitter (DVI)
+         *             1: DVP0 is used by a TV encoder */
+        if ((sr12 & 0x40) && (!(sr12 & 0x20))) {
+            viaDVP0EnableIOPads(pScrn, ioPadState);
+        } else if (!(sr12 & 0x10)) {
+            viaDFPLowEnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "None of the external ports were set up for "
+                        "TMDS transmitter use.\n");
+        }
+
+        break;
+    case VIA_CX700:
+    case VIA_VX800:
+    case VIA_VX855:
+    case VIA_VX900:
+        /* 3C5.13[6] - DVP1 DVP / capture port selection
+         *             0: DVP1 is used as a DVP (Digital Video Port)
+         *             1: DVP1 is used as a capture port
+         */
+        if (!(sr13 & 0x40)) {
+            viaDVP1EnableIOPads(pScrn, ioPadState);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                        "DVP1 is not set up for TMDS "
+                        "transmitter use.\n");
+        }
+
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Unrecognized IGP for "
+                    "TMDS transmitter use.\n");
+        break;
+    }
+
+    if ((pVia->Chipset == VIA_CX700)
+        || (pVia->Chipset == VIA_VX800)
+        || (pVia->Chipset == VIA_VX855)
+        || (pVia->Chipset == VIA_VX900)) {
+
+        hwp->writeSeq(hwp, 0x5A, sr5a);
+        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                            "Restoring 3C5.5A[0].\n"));
+    }
 
-    return xf86I2CWriteByte(d, subaddr, tmp);
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632EnableIOPads.\n"));
 }
 
 static void
@@ -63,239 +315,443 @@
                         "Exiting via_vt1632_dump_registers.\n"));
 }
 
+static void
+viaVT1632InitRegisters(ScrnInfoPtr pScrn, I2CDevPtr pDev)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaVT1632InitRegisters.\n"));
+
+    /* For Wyse C00X VX855 chipset DVP1 (Digital Video Port 1), use
+     * 12-bit mode with dual edge transfer, along with rising edge
+     * data capture first mode. This is likely true for CX700, VX700,
+     * VX800, and VX900 chipsets as well. */
+    xf86I2CWriteByte(pDev, 0x08,
+                        VIA_VT1632_VEN | VIA_VT1632_HEN |
+                        VIA_VT1632_DSEL |
+                        VIA_VT1632_EDGE | VIA_VT1632_PDB);
+
+    /* Route receiver detect bit (Offset 0x09[2]) as the output of
+     * MSEN pin. */
+    xf86I2CWriteByte(pDev, 0x09, 0x20);
+
+    /* Turning on deskew feature caused screen display issues.
+     * This was observed with Wyse C00X. */
+    xf86I2CWriteByte(pDev, 0x0A, 0x00);
+
+    /* While VIA Technologies VT1632A datasheet insists on setting this
+     * register to 0x89 as the recommended setting, in practice, this
+     * leads to a blank screen on the display with Wyse C00X. According to
+     * Silicon Image SiI 164 datasheet (VT1632A is a pin and mostly
+     * register compatible chip), offset 0x0C is for PLL filter enable,
+     * PLL filter setting, and continuous SYNC enable bits. All of these are
+     * turned off for proper operation. */
+    xf86I2CWriteByte(pDev, 0x0C, 0x00);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632InitRegisters.\n"));
+}
 
-void
-via_vt1632_power(xf86OutputPtr output, Bool powerState)
+/*
+ * Returns TMDS receiver detection state for VIA Technologies VT1632
+ * external TMDS transmitter.
+ */
+static Bool
+viaVT1632Sense(ScrnInfoPtr pScrn, I2CDevPtr pDev)
 {
-    ViaVT1632Ptr Private = output->driver_private;
-    ScrnInfoPtr pScrn = output->scrn;
+    CARD8 tmp;
+    Bool receiverDetected = FALSE;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_vt1632_power.\n"));
+                        "Entered viaVT1632Sense.\n"));
+
+    xf86I2CReadByte(pDev, 0x09, &tmp);
+    if (tmp & 0x04) {
+        receiverDetected = TRUE;
+    }
 
-    xf86I2CMaskByte(Private->VT1632I2CDev, 0x08, powerState ? 0x01 : 0x00, 0x01);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                "VT1632A Power: %s\n",
+                "VT1632 %s a TMDS receiver.\n",
+                receiverDetected ? "detected" : "did not detect");
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632Sense.\n"));
+    return receiverDetected;
+}
+
+static void
+viaVT1632Power(ScrnInfoPtr pScrn, I2CDevPtr pDev, Bool powerState)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaVT1632Power.\n"));
+
+    xf86I2CMaskByte(pDev, 0x08, powerState ? 0x01 : 0x00, 0x01);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VT1632 (DVI) Power: %s\n",
                 powerState ? "On" : "Off");
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_vt1632_power.\n"));
+                        "Exiting viaVT1632Power.\n"));
+}
+
+static void
+viaVT1632SaveRegisters(ScrnInfoPtr pScrn, I2CDevPtr pDev,
+                        viaVT1632RecPtr pVIAVT1632Rec)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaVT1632SaveRegisters.\n"));
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "Saving VT1632 registers.\n");
+    xf86I2CReadByte(pDev, 0x08, &pVIAVT1632Rec->Register08);
+    xf86I2CReadByte(pDev, 0x09, &pVIAVT1632Rec->Register09);
+    xf86I2CReadByte(pDev, 0x0A, &pVIAVT1632Rec->Register0A);
+    xf86I2CReadByte(pDev, 0x0C, &pVIAVT1632Rec->Register0C);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632SaveRegisters.\n"));
+}
+
+static void
+viaVT1632RestoreRegisters(ScrnInfoPtr pScrn, I2CDevPtr pDev,
+                            viaVT1632RecPtr pVIAVT1632Rec)
+{
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered viaVT1632RestoreRegisters.\n"));
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Restoring VT1632 registers.\n"));
+    xf86I2CWriteByte(pDev, 0x08, pVIAVT1632Rec->Register08);
+    xf86I2CWriteByte(pDev, 0x09, pVIAVT1632Rec->Register09);
+    xf86I2CWriteByte(pDev, 0x0A, pVIAVT1632Rec->Register0A);
+    xf86I2CWriteByte(pDev, 0x0C, pVIAVT1632Rec->Register0C);
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632RestoreRegisters.\n"));
+}
+
+static int
+viaVT1632CheckModeValidity(xf86OutputPtr output, DisplayModePtr pMode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    viaVT1632RecPtr pVIAVT1632Rec = output->driver_private;
+    int status = MODE_OK;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
+                        "Entered viaVT1632CheckModeValidity.\n"));
+
+    if (pMode->Clock < pVIAVT1632Rec->DotclockMin) {
+        status = MODE_CLOCK_LOW;
+        goto exit;
+    }
+
+    if (pMode->Clock > pVIAVT1632Rec->DotclockMax) {
+        status = MODE_CLOCK_HIGH;
+    }
+
+exit:
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting viaVT1632CheckModeValidity.\n"));
+    return status;
+}
+
+static void
+via_vt1632_create_resources(xf86OutputPtr output)
+{
 }
 
-void
+static void
+via_vt1632_dpms(xf86OutputPtr output, int mode)
+{
+    ScrnInfoPtr pScrn = output->scrn;
+    viaVT1632RecPtr pVIAVT1632Rec = output->driver_private;
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Entered via_vt1632_dpms.\n"));
+
+    switch (mode) {
+    case DPMSModeOn:
+        viaVT1632Power(pScrn, pVIAVT1632Rec->VT1632I2CDev, TRUE);
+        break;
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+    case DPMSModeOff:
+        viaVT1632Power(pScrn, pVIAVT1632Rec->VT1632I2CDev, FALSE);
+        break;
+    default:
+        break;
+    }
+
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Exiting via_vt1632_dpms.\n"));
+}
+
+static void
 via_vt1632_save(xf86OutputPtr output)
 {
-    ViaVT1632Ptr Private = output->driver_private;
     ScrnInfoPtr pScrn = output->scrn;
+    viaVT1632RecPtr pVIAVT1632Rec = output->driver_private;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered via_vt1632_save.\n"));
 
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "VT1632A: Saving the content of registers "
-                        "0x08, 0x09, 0x0A, and 0x0C.\n"));
-    xf86I2CReadByte(Private->VT1632I2CDev, 0x08, &Private->Register08);
-    xf86I2CReadByte(Private->VT1632I2CDev, 0x09, &Private->Register09);
-    xf86I2CReadByte(Private->VT1632I2CDev, 0x0A, &Private->Register0A);
-    xf86I2CReadByte(Private->VT1632I2CDev, 0x0C, &Private->Register0C);
+    viaVT1632SaveRegisters(pScrn, pVIAVT1632Rec->VT1632I2CDev, pVIAVT1632Rec);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting via_vt1632_save.\n"));
 }
 
-void
+static void
 via_vt1632_restore(xf86OutputPtr output)
 {
-    ViaVT1632Ptr Private = output->driver_private;
     ScrnInfoPtr pScrn = output->scrn;
+    viaVT1632RecPtr pVIAVT1632Rec = output->driver_private;
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered via_vt1632_restore.\n"));
 
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "VT1632A: Restoring registers 0x08, 0x09, "
-                        "0x0A, and 0x0C.\n"));
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x08, Private->Register08);
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x09, Private->Register09);
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x0A, Private->Register0A);
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x0C, Private->Register0C);
+    viaVT1632RestoreRegisters(pScrn, pVIAVT1632Rec->VT1632I2CDev,
+                                pVIAVT1632Rec);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Exiting via_vt1632_restore.\n"));
 }
 
-int
+static int
 via_vt1632_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
 {
-    ViaVT1632Ptr Private = output->driver_private;
-    ScrnInfoPtr pScrn = output->scrn;
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
-                        "Entered via_vt1632_mode_valid.\n"));
+    return viaVT1632CheckModeValidity(output, pMode);
+}
 
-    if (pMode->Clock < Private->DotclockMin) {
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_vt1632_mode_valid.\n"));
-        return MODE_CLOCK_LOW;
-    }
+static Bool
+via_vt1632_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
+                   DisplayModePtr adjusted_mode)
+{
+    return TRUE;
+}
 
-    if (pMode->Clock > Private->DotclockMax) {
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_vt1632_mode_valid.\n"));
-        return MODE_CLOCK_HIGH;
-    }
+static void
+via_vt1632_prepare(xf86OutputPtr output)
+{
+}
 
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_vt1632_mode_valid.\n"));
-    return MODE_OK;
+static void
+via_vt1632_commit(xf86OutputPtr output)
+{
 }
 
-void
+static void
 via_vt1632_mode_set(xf86OutputPtr output, DisplayModePtr mode,
                     DisplayModePtr adjusted_mode)
 {
-    ViaVT1632Ptr Private = output->driver_private;
     ScrnInfoPtr pScrn = output->scrn;
+    drmmode_crtc_private_ptr iga = output->crtc->driver_private;
+    VIAPtr pVia = VIAPTR(pScrn);
+    viaVT1632RecPtr pVIAVT1632Rec = output->driver_private;
 
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                         "Entered via_vt1632_mode_set.\n"));
 
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                "VT1632A: Enabling DVI.\n");
-
-    via_vt1632_dump_registers(pScrn, Private->VT1632I2CDev);
-
-    /* For Wyse C00X VX855 chipset DVP1 (Digital Video Port 1), use
-     * 12-bit mode with dual edge transfer, along with rising edge
-     * data capture first mode. This is likely true for CX700, VX700,
-     * VX800, and VX900 chipsets as well. */
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x08,
-                        VIA_VT1632_VEN | VIA_VT1632_HEN |
-                        VIA_VT1632_DSEL |
-                        VIA_VT1632_EDGE | VIA_VT1632_PDB);
-
-    /* Route receiver detect bit (Offset 0x09[2]) as the output of
-     * MSEN pin. */
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x09, 0x20);
+    viaVT1632SetDisplaySource(pScrn, iga->index ? 0x01 : 0x00);
+    viaVT1632EnableIOPads(pScrn, 0x03);
 
-    /* Turning on deskew feature caused screen display issues.
-     * This was observed with Wyse C00X. */
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x0A, 0x00);
+    via_vt1632_dump_registers(pScrn, pVIAVT1632Rec->VT1632I2CDev);
 
-    /* While VIA Technologies VT1632A datasheet insists on setting this
-     * register to 0x89 as the recommended setting, in practice, this
-     * leads to a blank screen on the display with Wyse C00X. According to
-     * Silicon Image SiI 164 datasheet (VT1632A is a pin and mostly
-     * register compatible chip), offset 0x0C is for PLL filter enable,
-     * PLL filter setting, and continuous SYNC enable bits. All of these are
-     * turned off for proper operation. */
-    xf86I2CWriteByte(Private->VT1632I2CDev, 0x0C, 0x00);
+    viaVT1632InitRegisters(pScrn, pVIAVT1632Rec->VT1632I2CDev);
 
-    via_vt1632_dump_registers(pScrn, Private->VT1632I2CDev);
+    via_vt1632_dump_registers(pScrn, pVIAVT1632Rec->VT1632I2CDev);
 
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                 "Exiting via_vt1632_mode_set.\n"));
 }
 
-xf86OutputStatus
+static xf86OutputStatus
 via_vt1632_detect(xf86OutputPtr output)
 {
-    ViaVT1632Ptr Private = output->driver_private;
-    xf86OutputStatus status;
+    xf86MonPtr mon;
+    xf86OutputStatus status = XF86OutputStatusDisconnected;
     ScrnInfoPtr pScrn = output->scrn;
-    CARD8 tmp;
-
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
-                        "Entered via_vt1632_detect.\n"));
+    viaVT1632RecPtr pVIAVT1632Rec = output->driver_private;
 
-    xf86I2CReadByte(Private->VT1632I2CDev, 0x09, &tmp);
-    if (tmp & 0x04) {
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
-                    "VT1632A: DVI device is detected.\n");
-        status = XF86OutputStatusConnected;
-    } else {
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                    "VT1632A: DVI device was not detected.\n");
-        status = XF86OutputStatusDisconnected;
+    /* Check for the DVI presence via VT1632 first before accessing
+     * I2C bus. */
+    if (viaVT1632Sense(pScrn, pVIAVT1632Rec->VT1632I2CDev)) {
+
+        /* Since DVI presence was established, access the I2C bus
+         * assigned to DVI. */
+        mon = xf86OutputGetEDID(output, pVIAVT1632Rec->VT1632I2CDev->pI2CBus);
+
+        /* Is the interface type digital? */
+        if (mon && DIGITAL(mon->features.input_type)) {
+            status = XF86OutputStatusConnected;
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Detected a monitor connected to DVI.\n");
+            xf86OutputSetEDID(output, mon);
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                        "Could not obtain EDID from a monitor "
+                        "connected to DVI.\n");
+        }
     }
 
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_vt1632_detect.\n"));
     return status;
 }
 
-BOOL
-via_vt1632_probe(ScrnInfoPtr pScrn, I2CDevPtr pDev) {
-    CARD8 buf = 0;
-    CARD16 VendorID = 0;
-    CARD16 DeviceID = 0;
+#ifdef RANDR_12_INTERFACE
+static Bool
+via_vt1632_set_property(xf86OutputPtr output, Atom property,
+                     RRPropertyValuePtr value)
+{
+    return TRUE;
+}
 
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
-                        "Entered via_vt1632_probe.\n"));
+static Bool
+via_vt1632_get_property(xf86OutputPtr output, Atom property)
+{
+    return FALSE;
+}
+#endif
 
-    xf86I2CReadByte(pDev, 0, &buf);
-    VendorID = buf;
-    xf86I2CReadByte(pDev, 1, &buf);
-    VendorID |= buf << 8;
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Vendor ID: 0x%04x\n", VendorID));
+static void
+via_vt1632_destroy(xf86OutputPtr output)
+{
+}
+
+const xf86OutputFuncsRec via_vt1632_funcs = {
+    .create_resources   = via_vt1632_create_resources,
+    .dpms               = via_vt1632_dpms,
+    .save               = via_vt1632_save,
+    .restore            = via_vt1632_restore,
+    .mode_valid         = via_vt1632_mode_valid,
+    .mode_fixup         = via_vt1632_mode_fixup,
+    .prepare            = via_vt1632_prepare,
+    .commit             = via_vt1632_commit,
+    .mode_set           = via_vt1632_mode_set,
+    .detect             = via_vt1632_detect,
+    .get_modes          = xf86OutputGetEDIDModes,
+#ifdef RANDR_12_INTERFACE
+    .set_property       = via_vt1632_set_property,
+#endif
+#ifdef RANDR_13_INTERFACE
+    .get_property       = via_vt1632_get_property,
+#endif
+    .destroy            = via_vt1632_destroy,
+};
+
+Bool
+viaVT1632Init(ScrnInfoPtr pScrn, I2CBusPtr pI2CBus)
+{
+    xf86OutputPtr output;
+    VIAPtr pVia = VIAPTR(pScrn);
+    viaVT1632RecPtr pVIAVT1632Rec = NULL;
+    I2CDevPtr pI2CDevice = NULL;
+    I2CSlaveAddr i2cAddr = 0x10;
+    CARD8 buf;
+    CARD16 vendorID, deviceID;
+    Bool status = FALSE;
+    char outputNameBuffer[32];
 
-    xf86I2CReadByte(pDev, 2, &buf);
-    DeviceID = buf;
-    xf86I2CReadByte(pDev, 3, &buf);
-    DeviceID |= buf << 8;
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Device ID: 0x%04x\n", DeviceID));
+                        "Entered viaVT1632Init.\n"));
 
-    if ((VendorID != 0x1106) || (DeviceID != 0x3192)) {
+    if (!xf86I2CProbeAddress(pI2CBus, i2cAddr)) {
         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                    "VT1632A DVI transmitter not detected.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_vt1632_probe.\n"));
-        return FALSE;
+                    "I2C device not found.\n");
+        goto exit;
     }
 
-    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                "VT1632A DVI transmitter detected.\n");
-    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_vt1632_probe.\n"));
-    return TRUE;
-}
+    pI2CDevice = xf86CreateI2CDevRec();
+    if (!pI2CDevice) {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to create an I2C bus device record.\n");
+        goto exit;
+    }
 
-ViaVT1632Ptr
-via_vt1632_init(ScrnInfoPtr pScrn, I2CDevPtr pDev)
-{
-    VIAPtr pVia = VIAPTR(pScrn);
-    ViaVT1632Ptr Private = NULL;
-    CARD8 buf = 0;
+    pI2CDevice->DevName = "VT1632";
+    pI2CDevice->SlaveAddr = i2cAddr;
+    pI2CDevice->pI2CBus = pI2CBus;
+    if (!xf86I2CDevInit(pI2CDevice)) {
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to initialize a device on I2C bus.\n");
+        goto exit;
+    }
 
+    xf86I2CReadByte(pI2CDevice, 0, &buf);
+    vendorID = buf;
+    xf86I2CReadByte(pI2CDevice, 1, &buf);
+    vendorID |= buf << 8;
+    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                        "Vendor ID: 0x%04x\n", vendorID));
+
+    xf86I2CReadByte(pI2CDevice, 2, &buf);
+    deviceID = buf;
+    xf86I2CReadByte(pI2CDevice, 3, &buf);
+    deviceID |= buf << 8;
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Entered via_vt1632_init.\n"));
+                        "Device ID: 0x%04x\n", deviceID));
 
-    Private = xnfcalloc(1, sizeof(ViaVT1632Rec));
-    if (!Private) {
+    if ((vendorID != 0x1106) || (deviceID != 0x3192)) {
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                    "VT1632 external TMDS transmitter not detected.\n");
+        goto exit;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                "VT1632 external TMDS transmitter detected.\n");
+
+    pVIAVT1632Rec = xnfcalloc(1, sizeof(viaVT1632Rec));
+    if (!pVIAVT1632Rec) {
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                    "Failed to allocate memory for DVI initialization.\n");
-        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                            "Exiting via_vt1632_init.\n"));
-        return NULL;
+                    "Failed to allocate working storage for VT1632.\n");
+        goto exit;
     }
-    Private->VT1632I2CDev = pDev;
 
-    xf86I2CReadByte(pDev, 0x06, &buf);
-    Private->DotclockMin = buf * 1000;
+    // Remembering which I2C bus is used for VT1632.
+    pVIAVT1632Rec->VT1632I2CDev = pI2CDevice;
+
+    xf86I2CReadByte(pI2CDevice, 0x06, &buf);
+    pVIAVT1632Rec->DotclockMin = buf * 1000;
 
-    xf86I2CReadByte(pDev, 0x07, &buf);
-    Private->DotclockMax = (buf + 65) * 1000;
+    xf86I2CReadByte(pI2CDevice, 0x07, &buf);
+    pVIAVT1632Rec->DotclockMax = (buf + 65) * 1000;
 
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VT1632A Dot Clock Range: "
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Supported VT1632 Dot Clock Range: "
                 "%d to %d MHz\n",
-                Private->DotclockMin / 1000,
-                Private->DotclockMax / 1000);
+                pVIAVT1632Rec->DotclockMin / 1000,
+                pVIAVT1632Rec->DotclockMax / 1000);
 
-    via_vt1632_dump_registers(pScrn, pDev);
+    /* The code to dynamically designate the particular DVI (i.e., DVI-1,
+     * DVI-2, etc.) for xrandr was borrowed from xf86-video-r128 DDX. */
+    sprintf(outputNameBuffer, "DVI-%d", (pVia->numberDVI + 1));
+    output = xf86OutputCreate(pScrn, &via_vt1632_funcs, outputNameBuffer);
+    if (!output) {
+        free(pVIAVT1632Rec);
+        xf86DestroyI2CDevRec(pI2CDevice, TRUE);
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                    "Failed to allocate X Server display output record for "
+                    "VT1632.\n");
+        goto exit;
+    }
+
+    output->driver_private = pVIAVT1632Rec;
+
+    /* Since there are two (2) display controllers registered with the
+     * X.Org Server and both IGA1 and IGA2 can handle DVI without any
+     * limitations, possible_crtcs should be set to 0x3 (0b11) so that
+     * either display controller can get assigned to handle DVI. */
+    output->possible_crtcs = (1 << 1) | (1 << 0);
 
+    output->possible_clones = 0;
+    output->interlaceAllowed = FALSE;
+    output->doubleScanAllowed = FALSE;
+
+    via_vt1632_dump_registers(pScrn, pI2CDevice);
+
+    pVia->numberDVI++;
+    status = TRUE;
+exit:
     DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                        "Exiting via_vt1632_init.\n"));
-    return Private;
+                        "Exiting viaVT1632Init.\n"));
+    return status;
 }
diff -ruN xf86-video-openchrome-0.5.0/src/via_vt1632.h xf86-video-openchrome/src/via_vt1632.h
--- xf86-video-openchrome-0.5.0/src/via_vt1632.h	2016-07-06 19:21:06.000000000 +0300
+++ xf86-video-openchrome/src/via_vt1632.h	2016-09-09 20:39:48.274625552 +0300
@@ -1,5 +1,6 @@
 /*
  * Copyright 2014 SHS SERVICES GmbH
+ * Copyright 2006-2009 Luc Verhaegen.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -31,7 +32,7 @@
 #define VIA_VT1632_EDGE 0x02
 #define VIA_VT1632_PDB  0x01
 
-typedef struct _ViaVT1632 {
+typedef struct _viaVT1632Rec {
 	I2CDevPtr VT1632I2CDev;
 
 	int DotclockMin;
@@ -40,15 +41,11 @@
 	CARD8 Register09;
 	CARD8 Register0A;
 	CARD8 Register0C;
-} ViaVT1632Rec, *ViaVT1632Ptr;
+} viaVT1632Rec, *viaVT1632RecPtr;
 
-void via_vt1632_power(xf86OutputPtr output, Bool powerState);
-void via_vt1632_save(xf86OutputPtr output);
-void via_vt1632_restore(xf86OutputPtr output);
-int via_vt1632_mode_valid(xf86OutputPtr output, DisplayModePtr pMode);
-void via_vt1632_mode_set(xf86OutputPtr output, DisplayModePtr mode, DisplayModePtr adjusted_mode);
-xf86OutputStatus via_vt1632_detect(xf86OutputPtr output);
-BOOL via_vt1632_probe(ScrnInfoPtr pScrn, I2CDevPtr pDev);
-ViaVT1632Ptr via_vt1632_init(ScrnInfoPtr pScrn, I2CDevPtr pDev);
+
+const xf86OutputFuncsRec via_vt1632_funcs;
+
+Bool viaVT1632Init(ScrnInfoPtr pScrn, I2CBusPtr pI2CBus);
 
 #endif /* _VIA_VT1632_H_ */
diff -ruN xf86-video-openchrome-0.5.0/src/xvmc/Imakefile xf86-video-openchrome/src/xvmc/Imakefile
--- xf86-video-openchrome-0.5.0/src/xvmc/Imakefile	1970-01-01 03:00:00.000000000 +0300
+++ xf86-video-openchrome/src/xvmc/Imakefile	2016-09-09 20:39:48.280803785 +0300
@@ -0,0 +1,59 @@
+#define DoNormalLib NormalLibXvMC
+#define DoSharedLib SharedLibXvMC
+#define DoDebugLib DebugLibXvMC
+#define DoProfileLib ProfileLibXvMC
+/*#define LibName viaXvMC*/
+#define SoRev SOXVMCREV
+#define LibHeaders NO
+
+#include <Threads.tmpl>
+
+/* Anyone know how to determine this properly?
+ * Comment out the following to build in the x tree
+ */
+#define OUTOFTREE
+
+#ifdef OUTOFTREE
+VIADRIVERSRC=../unichrome
+#else
+VIADRIVERSRC=$(XF86DRIVERSRC)/via
+#endif
+
+#ifdef SharedXvMCReqs
+REQUIREDLIBS = SharedXvMCReqs -lXv
+#endif
+
+#if Malloc0ReturnsNull
+ALLOC_DEFINES = -DMALLOC_0_RETURNS_NULL
+#endif
+
+      DEFINES = $(ALLOC_DEFINES) $(PICFLAGS) -DTRUE=1 -DFALSE=0
+     INCLUDES = -I$(XINCLUDESRC) -I$(INCLUDESRC) -I$(XLIBSRC) -I$(EXTINCSRC) \
+		-I$(XF86COMSRC) -I$(XF86OSSRC) -I$(DRMSRCDIR)/shared-core \
+		-I$(DRMSRCDIR)/shared \
+		-I$(XF86OSSRC)/linux/drm/kernel -I$(VIADRIVERSRC)
+         SRCS = viaXvMC.c viaLowLevel.c viaLowLevelPro.c xf86dri.c driDrawable.c
+         OBJS = viaXvMC.o viaLowLevel.o xf86drm.o xf86drmHash.o \
+	        xf86drmRandom.o xf86drmSL.o xf86dri.o driDrawable.o
+         OBJSPRO = viaXvMC.o viaLowLevelPro.o xf86drm.o xf86drmHash.o \
+	        xf86drmRandom.o xf86drmSL.o xf86dri.o driDrawable.o
+     LINTLIBS = $(LINTXLIB)
+
+#include <Library.tmpl>
+
+SharedLibraryTarget(viaXvMC,$(SoRev),$(OBJS) $(EXTRASHAREDOBJS),.,.)
+SharedLibraryTarget(viaXvMCPro,$(SoRev),$(OBJSPRO) $(EXTRASHAREDOBJS),.,.)
+InstallSharedLibrary(viaXvMC,$(SoRev),$(SHLIBDIR))
+InstallSharedLibrary(viaXvMCPro,$(SoRev),$(SHLIBDIR))
+
+#if defined(LinuxArchitecture)
+OS_SUBDIR = linux
+
+LinkSourceFile(xf86drm.c,$(XF86OSSRC)/$(OS_SUBDIR)/drm)
+LinkSourceFile(xf86drmHash.c,$(XF86OSSRC)/$(OS_SUBDIR)/drm)
+LinkSourceFile(xf86drmRandom.c,$(XF86OSSRC)/$(OS_SUBDIR)/drm)
+LinkSourceFile(xf86drmSL.c,$(XF86OSSRC)/$(OS_SUBDIR)/drm)
+#endif
+
+DependTarget()
+
diff -ruN xf86-video-openchrome-0.5.0/src/xvmc/Makefile.in xf86-video-openchrome/src/xvmc/Makefile.in
--- xf86-video-openchrome-0.5.0/src/xvmc/Makefile.in	2016-07-06 19:22:04.000000000 +0300
+++ xf86-video-openchrome/src/xvmc/Makefile.in	2016-09-09 20:50:14.531666385 +0300
@@ -279,7 +279,6 @@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
-LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
