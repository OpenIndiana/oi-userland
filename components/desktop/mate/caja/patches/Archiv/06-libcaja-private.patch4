--- caja-1.28.0/libcaja-private/caja-directory.c.orig	2024-02-20 01:30:36.000000000 +0100
+++ caja-1.28.0/libcaja-private/caja-directory.c	2024-02-26 08:42:41.075943421 +0100
@@ -40,6 +40,7 @@
 #include "caja-metadata.h"
 #include "caja-desktop-directory.h"
 #include "caja-vfs-directory.h"
+#include "caja-zfs.h"
 
 enum
 {
@@ -120,6 +121,8 @@
     directory->details->low_priority_queue = caja_file_queue_new ();
     directory->details->extension_queue = caja_file_queue_new ();
     directory->details->free_space = (guint64)-1;
+    directory->details->zfs_snapshots = NULL;
+    directory->details->restore_cancel = NULL;
 }
 
 CajaDirectory *
@@ -191,6 +194,16 @@
     g_assert (directory->details->file_list == NULL);
     g_hash_table_destroy (directory->details->file_hash);
 
+    if (directory->details->zfs_snapshots)
+    {
+        ts_free_snapshots (directory->details->zfs_snapshots);
+    }
+    
+    if (directory->details->restore_cancel)
+    {
+      g_cancellable_cancel (directory->details->restore_cancel);
+    }
+
     caja_file_queue_destroy (directory->details->high_priority_queue);
     caja_file_queue_destroy (directory->details->low_priority_queue);
     caja_file_queue_destroy (directory->details->extension_queue);
@@ -219,6 +232,21 @@
     caja_file_list_free (files);
 }
 
+static gboolean
+time_slider_enabled = TRUE;
+
+gboolean
+caja_is_time_slider_enabled ()
+{
+    return time_slider_enabled;
+}
+
+static void time_slider_pref_changed_callback (gpointer callback_data)
+{
+    time_slider_enabled = g_settings_get_boolean (caja_preferences,
+                         	                  CAJA_PREFERENCES_ENABLE_TIME_SLIDER);
+}
+
 static void
 collect_all_directories (gpointer key, gpointer value, gpointer callback_data)
 {
@@ -454,6 +482,7 @@
 {
     CajaDirectory *directory;
     char *uri;
+    char *path;
 
     uri = g_file_get_uri (location);
 
@@ -472,6 +501,8 @@
     else
     {
         directory = CAJA_DIRECTORY (g_object_new (CAJA_TYPE_VFS_DIRECTORY, NULL));
+        path = g_file_get_path (location);
+        g_free (path);
     }
 
     set_directory_location (directory, location);
@@ -495,6 +526,206 @@
            g_file_is_native (directory->details->location);
 }
 
+typedef struct
+{
+    CajaDirectory	*dir;
+    GCancellable    *cancel;
+    TsReadyCallback  callback;
+    gpointer         callback_user_data;
+} QuerySnapshotsAsyncData;
+
+
+static void
+snapshot_list_ready_callback (GObject *source_object,
+        GAsyncResult *res,
+        gpointer user_data)
+{
+    GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (res);
+    QuerySnapshotsAsyncData *data = (QuerySnapshotsAsyncData*) user_data;
+
+    if (!g_cancellable_is_cancelled (data->cancel))
+    {
+        data->dir->details->zfs_snapshots = g_simple_async_result_get_op_res_gpointer (simple);
+    }
+
+    data->callback (data->dir, data->cancel, data->callback_user_data);
+}
+
+void
+caja_directory_get_snapshots_async (CajaDirectory *directory, 
+        TsReadyCallback ready_callback, 
+        GCancellable *cancel, 
+        gpointer      callback_user_data)
+{
+    g_assert (CAJA_IS_DIRECTORY (directory));
+
+    if (directory->details->location == NULL) 
+        return;
+
+    if (directory->details->zfs_snapshots)
+    {
+        ts_free_snapshots (directory->details->zfs_snapshots);
+        directory->details->zfs_snapshots = NULL;
+    }
+
+    if (caja_is_time_slider_enabled ())
+    {
+        QuerySnapshotsAsyncData *data;
+        data = g_new0 (QuerySnapshotsAsyncData,1);
+        data->dir = directory;
+        data->cancel = cancel;
+        data->callback = ready_callback;
+        data->callback_user_data = callback_user_data;
+
+        ts_get_snapshots_for_dir_async (directory->details->location, 
+                snapshot_list_ready_callback, 
+                cancel,
+                data);
+    }
+}
+
+gboolean
+caja_directory_has_snapshots (CajaDirectory *directory)
+{
+    g_assert (CAJA_IS_DIRECTORY (directory));
+
+    if (directory->details->zfs_snapshots)
+        return TRUE;
+
+    return FALSE;
+}
+
+int
+caja_directory_get_num_snapshots (CajaDirectory *directory)
+{
+    g_assert (CAJA_IS_DIRECTORY (directory));
+
+    if (directory->details->zfs_snapshots)
+    {
+        int i = 0;
+        GList *tmp;
+        for (tmp = directory->details->zfs_snapshots;tmp;tmp = tmp->next)
+            i++;
+        return i;
+    }
+    return 0;
+}
+
+gboolean           
+caja_directory_is_in_snapshot (CajaDirectory *directory)
+{
+    char *directory_uri;
+    gboolean result = FALSE;
+
+    g_return_val_if_fail (CAJA_IS_DIRECTORY (directory), FALSE);
+
+    directory_uri = caja_directory_get_uri (directory);
+
+    result = ts_is_in_snapshot (directory_uri);
+
+    g_free (directory_uri);
+
+    return result;
+}
+
+GList *
+caja_directory_get_snapshots (CajaDirectory *directory)
+{
+    g_assert (CAJA_IS_DIRECTORY (directory));
+
+    return directory->details->zfs_snapshots;
+}
+
+void
+caja_directory_remove_snapshot (CajaDirectory *directory,
+                                ZfsDataSet *snap)
+{
+    if (directory->details->zfs_snapshots)
+    {
+        directory->details->zfs_snapshots = g_list_remove (directory->details->zfs_snapshots, snap);
+        ts_free_zfs_dataset (snap);
+    }
+}
+
+/* return true if snapdir dir path is a dir or subdir of refdir */
+gboolean 
+caja_directory_is_a_snapshot_dir_of (CajaDirectory *snapdir,
+                                     CajaDirectory *refdir)
+{
+
+    gboolean result = FALSE;   
+
+    if (caja_directory_is_in_snapshot (snapdir))
+    {
+        char snapdir_root_real_path [PATH_MAX+1];
+        char refdir_real_path [PATH_MAX+1];
+        CajaDirectory *snapdir_root = caja_directory_get_snap_root (snapdir);
+        GFile *snapdir_root_file = caja_directory_get_location (snapdir_root);
+        GFile *refdir_file = caja_directory_get_location (refdir);
+        char* snapdir_root_path = g_file_get_path (snapdir_root_file);
+        char* refdir_path = g_file_get_path (refdir_file);
+
+        if (ts_realpath (snapdir_root_path, snapdir_root_real_path) && 
+                ts_realpath (refdir_path, refdir_real_path))
+        {
+            if (g_strrstr (snapdir_root_real_path,refdir_real_path))
+                result = TRUE;
+        }
+
+        g_free (snapdir_root_path);
+        g_free (refdir_path);
+        g_object_unref (snapdir_root_file);
+        g_object_unref (refdir_file);
+        g_object_unref (snapdir_root);
+    }
+
+    return result;
+}
+
+CajaDirectory *
+caja_directory_get_snap_root (CajaDirectory      *directory)
+{
+    char *directory_uri, *snap_root;
+    char *zfs, *iter;
+    int count = 0;
+    CajaDirectory *new_dir;
+
+    g_assert (CAJA_IS_DIRECTORY (directory));
+
+    directory_uri = caja_directory_get_uri (directory);
+
+
+    if (!caja_directory_is_in_snapshot (directory))
+    {
+        g_free (directory_uri);
+        return directory;
+    }
+
+    /*remove .zfs/snapshot/blah/ */
+    zfs = g_strrstr (directory_uri, ".zfs/snapshot/");
+    iter = zfs;
+
+    if (iter)
+    {
+        iter += sizeof (".zfs/snapshot/");
+        while (*iter != '/' && *iter != '\0')
+            iter++;
+
+        if (*iter == '/')
+            iter++;
+
+        *zfs = '\0';
+        snap_root = g_strdup_printf ("%s%s", directory_uri, iter);
+
+        *zfs = 'a';
+        g_free (directory_uri);
+        new_dir = caja_directory_get_by_uri (snap_root);
+        g_free (snap_root);
+        return new_dir;
+    }
+    return directory;
+}
+
 gboolean
 caja_directory_is_in_trash (CajaDirectory *directory)
 {
