diff -up ./src/gnome-netstatus.ui.clean ./src/gnome-netstatus.ui
--- ./src/gnome-netstatus.ui.clean	2009-10-20 08:28:14.758668821 +0100
+++ ./src/gnome-netstatus.ui	2009-10-13 09:43:21.541049153 +0100
@@ -7,7 +7,7 @@
     <property name="resizable">False</property>
     <property name="window_position">center</property>
     <property name="default_width">300</property>
-    <property name="type_hint">dialog</property>
+    <property name="type_hint">normal</property>
     <property name="has_separator">False</property>
     <child internal-child="vbox">
       <object class="GtkVBox" id="dialog-vbox2">
@@ -46,17 +46,53 @@
                       <object class="GtkHBox" id="hbox6">
                         <property name="visible">True</property>
                         <child>
-                          <object class="GtkAlignment" id="alignment7">
+                          <object class="GtkLabel" id="label43">
                             <property name="visible">True</property>
-                            <property name="left_padding">10</property>
+                            <property name="label" translatable="yes">    </property>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkHBox" id="connection_hbox">
+                            <property name="visible">True</property>
+                            <property name="spacing">12</property>
                             <child>
                               <object class="GtkTable" id="connection_table">
                                 <property name="visible">True</property>
-                                <property name="n_rows">2</property>
+                                <property name="n_rows">3</property>
                                 <property name="n_columns">2</property>
                                 <property name="column_spacing">12</property>
                                 <property name="row_spacing">6</property>
                                 <child>
+                                  <object class="GtkComboBoxEntry" id="name_combo_box_entry">
+                                    <property name="visible">True</property>
+                                  </object>
+                                  <packing>
+                                    <property name="left_attach">1</property>
+                                    <property name="right_attach">2</property>
+                                  </packing>
+                                </child>
+                                <child>
+                                  <object class="GtkCheckButton" id="track_active_interface">
+                                    <property name="label" translatable="yes">_Track system active interface</property>
+                                    <property name="visible">True</property>
+                                    <property name="can_focus">True</property>
+                                    <property name="receives_default">False</property>
+                                    <property name="use_underline">True</property>
+                                    <property name="draw_indicator">True</property>
+                                  </object>
+                                  <packing>
+                                    <property name="left_attach">1</property>
+                                    <property name="right_attach">2</property>
+                                    <property name="top_attach">2</property>
+                                    <property name="bottom_attach">3</property>
+                                  </packing>
+                                </child>
+                                <child>
                                   <object class="GtkLabel" id="label5">
                                     <property name="visible">True</property>
                                     <property name="xalign">0</property>
@@ -98,26 +134,13 @@
                                   </packing>
                                 </child>
                                 <child>
-                                  <object class="GtkComboBoxEntry" id="name_combo_box_entry">
-                                    <property name="visible">True</property>
-                                  </object>
-                                  <packing>
-                                    <property name="left_attach">1</property>
-                                    <property name="right_attach">2</property>
-                                    <property name="x_options">GTK_FILL</property>
-                                    <property name="y_options">GTK_FILL</property>
-                                  </packing>
+                                  <placeholder/>
                                 </child>
                               </object>
+                              <packing>
+                                <property name="position">0</property>
+                              </packing>
                             </child>
-                          </object>
-                          <packing>
-                            <property name="position">0</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkHBox" id="connection_hbox">
-                            <property name="visible">True</property>
                             <child>
                               <placeholder/>
                             </child>
@@ -157,9 +180,19 @@
                       </packing>
                     </child>
                     <child>
-                      <object class="GtkAlignment" id="alignment8">
+                      <object class="GtkHBox" id="hbox8">
                         <property name="visible">True</property>
-                        <property name="left_padding">10</property>
+                        <child>
+                          <object class="GtkLabel" id="label44">
+                            <property name="visible">True</property>
+                            <property name="label" translatable="yes">    </property>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
                         <child>
                           <object class="GtkTable" id="table2">
                             <property name="visible">True</property>
@@ -213,6 +246,7 @@
                                 <property name="visible">True</property>
                                 <property name="xalign">0</property>
                                 <property name="label" translatable="yes">Sent:</property>
+                                <property name="width_chars">2</property>
                               </object>
                               <packing>
                                 <property name="top_attach">1</property>
@@ -222,6 +256,9 @@
                               </packing>
                             </child>
                           </object>
+                          <packing>
+                            <property name="position">1</property>
+                          </packing>
                         </child>
                       </object>
                       <packing>
@@ -242,7 +279,8 @@
                       <object class="GtkLabel" id="label48">
                         <property name="visible">True</property>
                         <property name="xalign">0</property>
-                        <property name="label" translatable="yes">Signal Strength</property>
+                        <property name="label" translatable="yes">&lt;b&gt;Wireless&lt;/b&gt;</property>
+                        <property name="use_markup">True</property>
                         <attributes>
                           <attribute name="weight" value="bold"/>
                         </attributes>
@@ -254,9 +292,98 @@
                       </packing>
                     </child>
                     <child>
-                      <object class="GtkAlignment" id="alignment3">
+                      <object class="GtkTable" id="table1">
                         <property name="visible">True</property>
-                        <property name="left_padding">10</property>
+                        <property name="n_rows">6</property>
+                        <property name="n_columns">2</property>
+                        <property name="column_spacing">12</property>
+                        <property name="row_spacing">6</property>
+                        <child>
+                          <object class="GtkLabel" id="essid_value_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="selectable">True</property>
+                          </object>
+                          <packing>
+                            <property name="left_attach">1</property>
+                            <property name="right_attach">2</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="bssid_value_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="selectable">True</property>
+                          </object>
+                          <packing>
+                            <property name="left_attach">1</property>
+                            <property name="right_attach">2</property>
+                            <property name="top_attach">1</property>
+                            <property name="bottom_attach">2</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="bssid_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Access Point (BSSID):</property>
+                            <property name="justify">right</property>
+                          </object>
+                          <packing>
+                            <property name="top_attach">1</property>
+                            <property name="bottom_attach">2</property>
+                            <property name="x_options">GTK_FILL</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="essid_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Network Name (ESSID):</property>
+                            <property name="justify">right</property>
+                          </object>
+                          <packing>
+                            <property name="x_options">GTK_FILL</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="label6">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Signal Strength:</property>
+                            <property name="ellipsize">middle</property>
+                          </object>
+                          <packing>
+                            <property name="top_attach">5</property>
+                            <property name="bottom_attach">6</property>
+                            <property name="x_options">GTK_FILL</property>
+                            <property name="y_options">GTK_FILL</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="auth_mode_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="yalign">0.49000000953674316</property>
+                            <property name="label" translatable="yes">Authentication Mode:</property>
+                          </object>
+                          <packing>
+                            <property name="top_attach">4</property>
+                            <property name="bottom_attach">5</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="security_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Security:</property>
+                          </object>
+                          <packing>
+                            <property name="top_attach">3</property>
+                            <property name="bottom_attach">4</property>
+                            <property name="x_options">GTK_FILL</property>
+                          </packing>
+                        </child>
                         <child>
                           <object class="GtkHBox" id="hbox15">
                             <property name="visible">True</property>
@@ -264,7 +391,6 @@
                             <child>
                               <object class="GtkProgressBar" id="signal_strength_bar">
                                 <property name="visible">True</property>
-                                <property name="pulse_step">0.10000000149</property>
                               </object>
                               <packing>
                                 <property name="position">0</property>
@@ -273,7 +399,7 @@
                             <child>
                               <object class="GtkLabel" id="signal_strength_label">
                                 <property name="visible">True</property>
-                                <property name="label">0%</property>
+                                <property name="label" translatable="yes">0%</property>
                               </object>
                               <packing>
                                 <property name="expand">False</property>
@@ -281,10 +407,67 @@
                               </packing>
                             </child>
                           </object>
+                          <packing>
+                            <property name="left_attach">1</property>
+                            <property name="right_attach">2</property>
+                            <property name="top_attach">5</property>
+                            <property name="bottom_attach">6</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="auth_mode_value_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="selectable">True</property>
+                          </object>
+                          <packing>
+                            <property name="left_attach">1</property>
+                            <property name="right_attach">2</property>
+                            <property name="top_attach">4</property>
+                            <property name="bottom_attach">5</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="security_value_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="selectable">True</property>
+                          </object>
+                          <packing>
+                            <property name="left_attach">1</property>
+                            <property name="right_attach">2</property>
+                            <property name="top_attach">3</property>
+                            <property name="bottom_attach">4</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="bss_mode_value_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="selectable">True</property>
+                          </object>
+                          <packing>
+                            <property name="left_attach">1</property>
+                            <property name="right_attach">2</property>
+                            <property name="top_attach">2</property>
+                            <property name="bottom_attach">3</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="bss_mode_label">
+                            <property name="visible">True</property>
+                            <property name="xalign">0</property>
+                            <property name="label" translatable="yes">Operational Mode (BSS):</property>
+                            <property name="justify">right</property>
+                          </object>
+                          <packing>
+                            <property name="top_attach">2</property>
+                            <property name="bottom_attach">3</property>
+                            <property name="x_options">GTK_FILL</property>
+                          </packing>
                         </child>
                       </object>
                       <packing>
-                        <property name="expand">False</property>
                         <property name="position">1</property>
                       </packing>
                     </child>
@@ -330,9 +513,19 @@
                       </packing>
                     </child>
                     <child>
-                      <object class="GtkAlignment" id="alignment4">
+                      <object class="GtkHBox" id="hbox11">
                         <property name="visible">True</property>
-                        <property name="left_padding">10</property>
+                        <child>
+                          <object class="GtkLabel" id="label45">
+                            <property name="visible">True</property>
+                            <property name="label" translatable="yes">    </property>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
                         <child>
                           <object class="GtkTable" id="inet4_table">
                             <property name="visible">True</property>
@@ -453,6 +646,9 @@
                               </packing>
                             </child>
                           </object>
+                          <packing>
+                            <property name="position">1</property>
+                          </packing>
                         </child>
                       </object>
                       <packing>
@@ -484,9 +680,19 @@
                       </packing>
                     </child>
                     <child>
-                      <object class="GtkAlignment" id="alignment6">
+                      <object class="GtkHBox" id="hbox12">
                         <property name="visible">True</property>
-                        <property name="left_padding">10</property>
+                        <child>
+                          <object class="GtkLabel" id="label46">
+                            <property name="visible">True</property>
+                            <property name="label" translatable="yes">    </property>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
                         <child>
                           <object class="GtkTable" id="table5">
                             <property name="visible">True</property>
@@ -549,6 +755,9 @@
                               </packing>
                             </child>
                           </object>
+                          <packing>
+                            <property name="position">1</property>
+                          </packing>
                         </child>
                       </object>
                       <packing>
@@ -581,9 +790,19 @@
                       </packing>
                     </child>
                     <child>
-                      <object class="GtkAlignment" id="alignment5">
+                      <object class="GtkHBox" id="hbox13">
                         <property name="visible">True</property>
-                        <property name="left_padding">10</property>
+                        <child>
+                          <object class="GtkLabel" id="label47">
+                            <property name="visible">True</property>
+                            <property name="label" translatable="yes">    </property>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
                         <child>
                           <object class="GtkTable" id="table6">
                             <property name="visible">True</property>
@@ -646,6 +865,9 @@
                               </packing>
                             </child>
                           </object>
+                          <packing>
+                            <property name="position">1</property>
+                          </packing>
                         </child>
                       </object>
                       <packing>
@@ -673,6 +895,138 @@
                 <property name="tab_fill">False</property>
               </packing>
             </child>
+            <child>
+              <object class="GtkVBox" id="vbox3">
+                <property name="visible">True</property>
+                <property name="border_width">12</property>
+                <property name="spacing">18</property>
+                <child>
+                  <object class="GtkVBox" id="vbox5">
+                    <property name="visible">True</property>
+                    <property name="spacing">6</property>
+                    <child>
+                      <object class="GtkLabel" id="label59">
+                        <property name="visible">True</property>
+                        <property name="xalign">0</property>
+                        <property name="label" translatable="yes">You may need to restart ths connection if you want to connect to a different network, or if you are experiencing connection problems.</property>
+                        <property name="wrap">True</property>
+                      </object>
+                      <packing>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkHBox" id="restart_hbox">
+                    <property name="visible">True</property>
+                    <child>
+                      <object class="GtkLabel" id="label65">
+                        <property name="visible">True</property>
+                      </object>
+                      <packing>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkVBox" id="vbox6">
+                        <property name="visible">True</property>
+                        <child>
+                          <object class="GtkButton" id="restart_button">
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="receives_default">False</property>
+                            <child>
+                              <object class="GtkAlignment" id="alignment3">
+                                <property name="visible">True</property>
+                                <property name="xscale">0</property>
+                                <property name="yscale">0</property>
+                                <child>
+                                  <object class="GtkHBox" id="hbox1">
+                                    <property name="visible">True</property>
+                                    <property name="spacing">2</property>
+                                    <child>
+                                      <object class="GtkImage" id="restart_button_image">
+                                        <property name="visible">True</property>
+                                        <property name="stock">gtk-refresh</property>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">0</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkLabel" id="restart_button_label">
+                                        <property name="visible">True</property>
+                                        <property name="label" translatable="yes">_Restart</property>
+                                        <property name="use_underline">True</property>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">1</property>
+                                      </packing>
+                                    </child>
+                                  </object>
+                                </child>
+                              </object>
+                            </child>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkLabel" id="label70">
+                            <property name="visible">True</property>
+                          </object>
+                          <packing>
+                            <property name="position">1</property>
+                          </packing>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="fill">False</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkLabel" id="label69">
+                    <property name="visible">True</property>
+                  </object>
+                  <packing>
+                    <property name="position">2</property>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="position">2</property>
+              </packing>
+            </child>
+            <child type="tab">
+              <object class="GtkLabel" id="restart_tab_label">
+                <property name="visible">True</property>
+                <property name="label" translatable="yes">Restart</property>
+              </object>
+              <packing>
+                <property name="position">2</property>
+                <property name="tab_fill">False</property>
+              </packing>
+            </child>
           </object>
           <packing>
             <property name="position">1</property>

diff -up ./src/netstatus-dialog.c.clean ./src/netstatus-dialog.c
--- ./src/netstatus-dialog.c.clean	2009-10-20 08:28:14.750343205 +0100
+++ ./src/netstatus-dialog.c	2009-10-13 09:46:14.868292341 +0100
@@ -1,6 +1,6 @@
 /* vim: set sw=2 ts=2 sts=2 et: */
 /*
- * Copyright (C) 2003 Sun Microsystems, Inc.
+ * Copyright (C) 2003-2009 Sun Microsystems, Inc.
  * Copyright (C) 2004 Red Hat Inc.
  *
  * This program is free software; you can redistribute it and/or
@@ -36,6 +36,27 @@
 #define NETWORK_CONFIG_TOOL_DIR "/apps/netstatus_applet"
 #define NETWORK_CONFIG_TOOL_KEY NETWORK_CONFIG_TOOL_DIR "/config_tool"
 
+static const gchar * IFRESTART_TAB_LABLE_NAME        = "restart_tab_label";
+static const gchar * IFRESTART_TAB_BUTTON_NAME       = "restart_button";
+static const gchar * IFRESTART_TAB_BUTTON_LABEL_NAME = "restart_button_label";
+static const gchar * IFRESTART_TAB_BUTTON_IMAGE_NAME = "restart_button_image";
+static const gchar * IFRESTART_TAB_HBOX_NAME         = "restart_hbox";
+
+static const gchar * IFRESTART_TAB_BUTTON_LABEL_RESTART = "_Restart";
+static const gchar * IFRESTART_TAB_BUTTON_LABEL_STOP    = "_Stop";
+
+static const gchar * IFRESTART_WINDOW_TITLE_FORMAT = "%s: %s";
+static const gchar * IFRESTART_WINDOW_TITLE = "Restartin Connection";
+
+static const gchar * IFRESTART_PROGRESS_FORMAT = "<b>%s</b>: <i>%s</i>";
+static const gchar * IFRESTART_PROGRESS = "Progress";
+static const gchar * IFRESTART_PROGRESS_BEGIN = "Click Restart to begin";
+static const gchar * IFRESTART_PROGRESS_RESTARTING = "Restarting...";
+static const gchar * IFRESTART_PROGRESS_COMPLETE = "Complete";
+static const gchar * IFRESTART_PROGRESS_FAILED = "Failed, click here for details";
+static const gchar * IFRESTART_WARNING = "Warning";
+static const gchar * IFRESTART_WARNING_NOLO = "Cannot restart this connection";
+
 static const char *network_config_tools[] = {
   "network-admin --configure %i",
   "redhat-config-network",
@@ -64,6 +85,11 @@ typedef struct
   GtkWidget      *signal_strength_frame;
   GtkWidget      *signal_strength_bar;
   GtkWidget      *signal_strength_label;
+  GtkWidget      *essid_value_label;
+  GtkWidget      *bssid_value_label;
+  GtkWidget      *bss_mode_value_label;
+  GtkWidget      *security_value_label;
+  GtkWidget      *auth_mode_value_label;
   GtkWidget      *configure_button;
 
   GtkWidget      *inet4_frame;
@@ -81,6 +107,13 @@ typedef struct
   GtkWidget      *dev_type;
   GtkWidget      *dev_addr;
 
+  GtkWidget      *track_active_interface_cbox;
+
+  GtkWidget      *restart_button;
+  GtkWidget      *restart_button_image;
+  GtkWidget      *restart_button_label;
+  GtkWidget      *restart_progress_expander;
+
   guint           iface_list_monitor;
   int             n_ifaces;
 } NetstatusDialogData;
@@ -184,6 +217,11 @@ netstatus_dialog_update_signal_strength 
     {
       int   signal_strength;
       char *str;
+      const char *essid;
+      const char *bssid;
+      const char *bss_mode;
+      const char *auth_mode;
+      const char *security;
 
       gtk_widget_show (data->signal_strength_frame);
 
@@ -195,6 +233,18 @@ netstatus_dialog_update_signal_strength 
       str = g_strdup_printf ("%d%%\n", signal_strength);
       gtk_label_set_text (GTK_LABEL (data->signal_strength_label), str);
       g_free (str);
+
+      essid = netstatus_iface_get_essid (data->iface);
+      bssid = netstatus_iface_get_bssid (data->iface);
+      bss_mode = netstatus_iface_get_bss_mode (data->iface);
+      security = netstatus_iface_get_security (data->iface);
+      auth_mode = netstatus_iface_get_auth_mode (data->iface);
+
+      gtk_label_set_text (GTK_LABEL (data->essid_value_label), essid?essid:"" );
+      gtk_label_set_text (GTK_LABEL (data->bssid_value_label), bssid?bssid:"" );
+      gtk_label_set_text (GTK_LABEL (data->bss_mode_value_label), bss_mode?bss_mode:"" );
+      gtk_label_set_text (GTK_LABEL (data->auth_mode_value_label), auth_mode?auth_mode:"" );
+      gtk_label_set_text (GTK_LABEL (data->security_value_label), security?security:"" );
     }
   else
     {
@@ -313,6 +363,105 @@ netstatus_dialog_update_device_support (
 }
 
 static void
+netstatus_dialog_set_track_active_interface(NetstatusDialogData *data,
+				                            GtkToggleButton     *toggle)
+{
+    gboolean track_active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->track_active_interface_cbox));
+
+    netstatus_iface_set_track_active_interface (data->iface, track_active );
+}
+
+
+static void
+netstatus_dialog_update_track_active_interface (NetstatusDialogData *data)
+{
+  GtkWidget *  widget;
+  gboolean     track_active = FALSE;
+
+  if ( data->track_active_interface_cbox == NULL ) 
+      return;
+
+  track_active = netstatus_iface_get_track_active_interface( data->iface );
+
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(data->track_active_interface_cbox), track_active );
+
+  gtk_widget_set_sensitive(GTK_WIDGET(data->name), !track_active );
+
+}
+
+static gboolean
+netstatus_dialog_ask_question(NetstatusDialogData *data, const char* message, const char* question )
+{
+  GtkWidget *dialog;
+  gint       result;
+  gboolean   ret_val = FALSE;
+
+  dialog = gtk_message_dialog_new (GTK_WINDOW (data->dialog),
+				   GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
+				   GTK_MESSAGE_QUESTION,
+				   GTK_BUTTONS_YES_NO,
+                   message );
+
+  if (question) {
+      gtk_message_dialog_format_secondary_text( dialog, question );
+  }
+
+  result = gtk_dialog_run (GTK_DIALOG (dialog));
+
+  switch (result) {
+    case GTK_RESPONSE_YES:
+        ret_val = TRUE;
+        break;
+    default:
+        break;
+  }
+
+  gtk_widget_destroy (dialog);
+
+  return( ret_val );
+}
+
+static void
+netstatus_dialog_update_restart_button (NetstatusDialogData *data)
+{
+  GtkWidget *  widget;
+  gchar *      string;
+  const char * ifname;
+
+  if (data->restart_button == NULL)
+    return;
+
+  /* Disable restart button for nothing and loopback interface */
+  ifname = netstatus_iface_get_name (data->iface);
+  if ((ifname != NULL) && (strcmp (ifname, "lo")))
+    {
+      gtk_widget_set_sensitive (data->restart_button, TRUE);
+
+      /* Set "Press button to restart" progress message */
+      string = g_strdup_printf (IFRESTART_PROGRESS_FORMAT, 
+        _(IFRESTART_PROGRESS), _(IFRESTART_PROGRESS_BEGIN));
+    }
+  else
+    {
+      gtk_widget_set_sensitive (data->restart_button, FALSE);
+
+      /* Set "Cannot restart this connection" progress message */
+      string = g_strdup_printf (IFRESTART_PROGRESS_FORMAT, 
+        _(IFRESTART_WARNING), _(IFRESTART_WARNING_NOLO));
+    }
+    gtk_expander_set_label (
+      GTK_EXPANDER (data->restart_progress_expander), string);
+    g_free (string);
+
+    /* Clean up the output of the last restart */
+    widget = gtk_bin_get_child (GTK_BIN (data->restart_progress_expander));
+    if (widget != NULL)
+      {
+        gtk_label_set_text (GTK_LABEL (widget), "");
+      }
+}
+
+static void
 netstatus_dialog_iface_state_changed (NetstatusIface      *iface,
 				      GParamSpec          *pspec,
 				      NetstatusDialogData *data)
@@ -339,12 +488,21 @@ netstatus_dialog_iface_signal_strength_c
 }
 
 static void
+netstatus_dialog_iface_track_active_interface_changed(NetstatusIface      *iface,
+				     GParamSpec          *pspec,
+				     NetstatusDialogData *data)
+{
+    netstatus_dialog_update_track_active_interface( data );
+}
+
+static void
 netstatus_dialog_iface_name_changed (NetstatusIface      *iface,
 				     GParamSpec          *pspec,
 				     NetstatusDialogData *data)
 {
   netstatus_dialog_update_name (data);
   netstatus_dialog_update_signal_strength (data);
+  netstatus_dialog_update_restart_button (data);
 }
 
 static void
@@ -364,6 +522,136 @@ netstatus_dialog_set_iface_name (Netstat
 }
 
 static void
+netstatus_dialog_restart_state_changed (
+  NetstatusIface *iface, NetstatusDialogData *data)
+{
+  GtkWidget * widget;
+  gchar *     string;
+
+  g_return_if_fail (data != NULL);
+  g_return_if_fail (data->iface != NULL);
+
+  if (netstatus_iface_restart_inprogress (data->iface))
+    {
+      /* The restart is in progress */
+      const char * ifname;
+
+      /* Save the current network interface name */
+      ifname = netstatus_iface_get_name (data->iface);
+      g_return_if_fail (ifname != NULL);
+
+      /* Disable network interface change */
+      gtk_widget_set_sensitive (data->name, FALSE);
+
+      /* Set the restart button to Stop */
+      gtk_image_set_from_stock (GTK_IMAGE (data->restart_button_image), 
+        GTK_STOCK_STOP, GTK_ICON_SIZE_BUTTON);
+      gtk_label_set_text_with_mnemonic (GTK_LABEL (data->restart_button_label), 
+        _(IFRESTART_TAB_BUTTON_LABEL_STOP));
+
+      /* Set dialog window title */
+      string = g_strdup_printf (IFRESTART_WINDOW_TITLE_FORMAT, 
+        _(IFRESTART_WINDOW_TITLE), ifname);
+      gtk_window_set_title (GTK_WINDOW (data->dialog), string);
+      g_free (string);
+
+      /* Set the progress message */
+      string = g_strdup_printf (IFRESTART_PROGRESS_FORMAT, 
+        _(IFRESTART_PROGRESS), _(IFRESTART_PROGRESS_RESTARTING));
+      gtk_expander_set_label (
+        GTK_EXPANDER (data->restart_progress_expander), string);
+      g_free (string);
+
+      /* Clean up the output of the script */
+      widget = gtk_bin_get_child (GTK_BIN (data->restart_progress_expander));
+      if (widget != NULL)
+        {
+          gtk_label_set_text (GTK_LABEL (widget), "");
+        }
+    }
+  else
+    {
+      /* The restart is completed */
+      gint state;
+
+      /* Set the restart button to Restart */
+      gtk_image_set_from_stock (GTK_IMAGE (data->restart_button_image), 
+        GTK_STOCK_REFRESH, GTK_ICON_SIZE_BUTTON);
+      gtk_label_set_text_with_mnemonic (GTK_LABEL (data->restart_button_label), 
+        _(IFRESTART_TAB_BUTTON_LABEL_RESTART));
+
+      /* Enable network interface change */
+      gtk_widget_set_sensitive (data->name, TRUE);
+
+      /* Restore dialog window title */
+      netstatus_dialog_update_name (data);
+
+      /* Set the progress message */
+      state = netstatus_iface_restart_get_status (data->iface);
+      if (state == 0)
+        {
+          /* Restart has been completed successfully */
+          string = g_strdup_printf (IFRESTART_PROGRESS_FORMAT, 
+            _(IFRESTART_PROGRESS), _(IFRESTART_PROGRESS_COMPLETE));
+        }
+      else if (state > 0)
+        {
+          /* Restart has failed */
+          string = g_strdup_printf (IFRESTART_PROGRESS_FORMAT, 
+            _(IFRESTART_PROGRESS), _(IFRESTART_PROGRESS_FAILED));
+        }
+      else
+        {
+          /* No restart has been completed or started yet */
+          string = g_strdup_printf (IFRESTART_PROGRESS_FORMAT, 
+            _(IFRESTART_PROGRESS), _(IFRESTART_PROGRESS_BEGIN));
+        }
+      gtk_expander_set_label (
+        GTK_EXPANDER (data->restart_progress_expander), string);
+      g_free (string);
+
+      /* Set the output of the script */
+      widget = gtk_bin_get_child (GTK_BIN (data->restart_progress_expander));
+      if (widget != NULL)
+        {
+          string = netstatus_iface_restart_get_output (data->iface);
+          switch (state)
+            {
+              case 9:     /* canceled by "Stop" button */
+              case 3072:  /* canceled by root password dialog */
+                string = _("Connection restart has been stopped.");
+                break;
+
+              case 19:    /* there is no ifrestart script */
+                string = _("Cannot find ifrestart script.");
+                break;
+
+              default:
+                break;
+            }
+          gtk_label_set_text (GTK_LABEL (widget), string);
+        }
+    }
+}
+
+static void
+netstatus_dialog_restart (GtkWidget *button, NetstatusDialogData *data)
+{
+  g_return_if_fail (data != NULL);
+
+  if (netstatus_iface_restart_inprogress (data->iface))
+    {
+      /* Interrupt the network interface restart */
+      netstatus_iface_restart_interrupt (data->iface);
+    }
+  else
+    {
+      /* Spawn the network interface restart */
+      netstatus_iface_restart (data->iface);
+    }
+}
+
+static void
 netstatus_dialog_response (GtkWidget *dialog,
 			   int        response)
 {
@@ -441,7 +729,11 @@ netstatus_dialog_destroy (GtkWidget *dia
   data->iface_list_monitor = 0;
 
   if (data->iface)
-    g_object_unref (data->iface);
+    {
+      g_signal_handlers_disconnect_matched (
+        data->iface, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, (gpointer) data);
+      g_object_unref (data->iface);
+    }
   data->iface = NULL;
 
   g_free (data);
@@ -603,6 +895,26 @@ netstatus_dialog_setup_configure_button 
 }
 
 static void
+netstatus_dialog_setup_track_active_interface (NetstatusDialogData *data,
+				                                       GtkBuilder *builder)
+{
+  GtkWidget *cbox;
+  
+  cbox = GTK_WIDGET (gtk_builder_get_object (builder, "track_active_interface"));
+
+  gtk_widget_show (cbox);
+
+  data->track_active_interface_cbox = cbox;
+
+  netstatus_dialog_update_track_active_interface(data);
+
+  g_signal_connect_swapped(GTK_TOGGLE_BUTTON (data->track_active_interface_cbox), "toggled",
+			    G_CALLBACK (netstatus_dialog_set_track_active_interface),
+			    data);
+
+}
+
+static void
 netstatus_dialog_setup_connection (NetstatusDialogData *data,
                                   GtkBuilder *builder)
 {
@@ -652,6 +964,11 @@ netstatus_dialog_setup_signal_strength_d
   data->signal_strength_frame = GTK_WIDGET (gtk_builder_get_object (builder, "signal_strength_frame"));
   data->signal_strength_bar   = GTK_WIDGET (gtk_builder_get_object (builder, "signal_strength_bar"));
   data->signal_strength_label = GTK_WIDGET (gtk_builder_get_object (builder, "signal_strength_label"));
+  data->essid_value_label     = GTK_WIDGET (gtk_builder_get_object (builder, "essid_value_label"));
+  data->bssid_value_label     = GTK_WIDGET (gtk_builder_get_object (builder, "bssid_value_label"));
+  data->bss_mode_value_label  = GTK_WIDGET (gtk_builder_get_object (builder, "bss_mode_value_label"));
+  data->auth_mode_value_label = GTK_WIDGET (gtk_builder_get_object (builder, "auth_mode_value_label"));
+  data->security_value_label  = GTK_WIDGET (gtk_builder_get_object (builder, "security_value_label"));
 
   netstatus_dialog_update_signal_strength (data);
 }
@@ -720,6 +1037,88 @@ netstatus_dialog_iface_list_monitor (Net
   return TRUE;
 }
 
+static void
+netstatus_dialog_setup_restart_tab (NetstatusDialogData *data, GtkBuilder *builder)
+{
+  GtkWidget * widget;
+
+  g_return_if_fail (data != NULL);
+  g_return_if_fail (builder != NULL);
+
+  /* Network interface restart tab */
+  if (netstatus_iface_restart_available (data->iface))
+    {
+      /* Restart button */
+      data->restart_button = GTK_WIDGET (
+        gtk_builder_get_object (builder, IFRESTART_TAB_BUTTON_NAME));
+      if (data->restart_button != NULL)
+        {
+          /* Button image */
+          data->restart_button_image = GTK_WIDGET (
+            gtk_builder_get_object (builder, IFRESTART_TAB_BUTTON_IMAGE_NAME));
+          /* Button label */
+          data->restart_button_label = GTK_WIDGET (
+            gtk_builder_get_object (builder, IFRESTART_TAB_BUTTON_LABEL_NAME));
+          /* Clicked signal handler */
+          g_signal_connect (G_OBJECT (data->restart_button), "clicked", 
+            G_CALLBACK (netstatus_dialog_restart), (gpointer) data);
+        }
+      /* Add progress expander */
+      widget = GTK_WIDGET (
+            gtk_builder_get_object (builder, IFRESTART_TAB_HBOX_NAME));
+      if (widget != NULL)
+        {
+          gtk_box_set_spacing (GTK_BOX (widget), 2);
+          data->restart_progress_expander = gtk_expander_new ("");
+          gtk_expander_set_use_markup (
+            GTK_EXPANDER (data->restart_progress_expander), TRUE);
+          gtk_box_pack_start (GTK_BOX (widget), 
+            data->restart_progress_expander, FALSE, FALSE, 0);
+          gtk_box_reorder_child (GTK_BOX (widget),
+            data->restart_progress_expander, 0);
+          widget = gtk_label_new ("");
+          gtk_label_set_selectable (GTK_LABEL (widget), TRUE);
+          gtk_container_add (
+            GTK_CONTAINER (data->restart_progress_expander), widget);
+          gtk_widget_show_all (data->restart_progress_expander);
+        }
+
+      netstatus_dialog_restart_state_changed (data->iface, data);
+      netstatus_dialog_update_restart_button (data);
+
+      g_signal_connect (
+        data->iface, NETSTATUS_IFACE_SIGNAL_RESTART_STATE,
+        G_CALLBACK (netstatus_dialog_restart_state_changed), data);
+    }
+  else
+    {
+      GtkNotebook * notebook;
+      const gchar * name;
+      gint          idx;
+
+      /* Remove the restart tab */
+      notebook = GTK_NOTEBOOK (
+        GTK_WIDGET (gtk_builder_get_object (builder, "notebook1")));
+      if (notebook != NULL)
+        {
+          for (idx = 0; idx < gtk_notebook_get_n_pages (notebook); idx++)
+            {
+              widget = gtk_notebook_get_nth_page (notebook, idx);
+              widget = gtk_notebook_get_tab_label (notebook, widget);
+              if (widget != NULL)
+                {
+                  name   = gtk_widget_get_name (widget);
+                  if (!strcmp (name, IFRESTART_TAB_LABLE_NAME))
+                    {
+                      gtk_notebook_remove_page (notebook, idx);
+                      break;
+                    }
+                }
+            }
+        }
+    }
+}
+
 GtkWidget *
 netstatus_dialog_new (NetstatusIface *iface)
 {
@@ -743,7 +1142,7 @@ netstatus_dialog_new (NetstatusIface *if
   data->dialog = GTK_WIDGET (gtk_builder_get_object (builder, "network_status_dialog"));
   g_object_set_data (G_OBJECT (data->dialog), "netstatus-dialog-data", data);
 
-  gtk_window_set_icon_name(GTK_WINDOW (data->dialog), "gnome-netstatus-tx");	
+  gtk_window_set_icon_name(GTK_WINDOW (data->dialog), "network-transmit");	
 
   data->iface = g_object_ref (iface);
   netstatus_connect_signal_while_alive (data->iface,
@@ -771,11 +1170,23 @@ netstatus_dialog_new (NetstatusIface *if
 					data->dialog);
 
   netstatus_connect_signal_while_alive (data->iface,
+					"notify::connected",
+					G_CALLBACK (netstatus_dialog_iface_signal_strength_changed),
+					data,
+					data->dialog);
+
+  netstatus_connect_signal_while_alive (data->iface,
 					"notify::signal-strength",
 					G_CALLBACK (netstatus_dialog_iface_signal_strength_changed),
 					data,
 					data->dialog);
 
+  netstatus_connect_signal_while_alive (data->iface,
+					"notify::track-active-inteface",
+					G_CALLBACK (netstatus_dialog_iface_track_active_interface_changed),
+					data,
+					data->dialog);
+  
   g_signal_connect (data->dialog, "response",
 		    G_CALLBACK (netstatus_dialog_response), NULL);
 
@@ -783,11 +1194,13 @@ netstatus_dialog_new (NetstatusIface *if
 		    G_CALLBACK (netstatus_dialog_destroy), NULL);
 
   netstatus_dialog_setup_connection (data, builder);
+  netstatus_dialog_setup_track_active_interface (data, builder);
   netstatus_dialog_setup_activity (data, builder);
   netstatus_dialog_setup_signal_strength_details (data, builder);
   netstatus_dialog_setup_inet4_support (data, builder);
   netstatus_dialog_setup_device_support (data, builder);
   netstatus_dialog_setup_configure_button (data, builder);
+  netstatus_dialog_setup_restart_tab (data, builder);
 
   data->iface_list_monitor = g_timeout_add (2 * 1000,
 					    (GSourceFunc) netstatus_dialog_iface_list_monitor,

diff -up gnome-netstatus-2.28.0/src/netstatus-iface.c.clean gnome-netstatus-2.28.0/src/netstatus-iface.c
--- gnome-netstatus-2.28.0/src/netstatus-iface.c.clean	2009-10-20 09:03:50.548097159 +0100
+++ gnome-netstatus-2.28.0/src/netstatus-iface.c	2009-10-20 09:02:30.415021784 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003 Sun Microsystems, Inc.
+ * Copyright (C) 2003-2009 Sun Microsystems, Inc.
  * Copyright (C) 2004 Red Hat Inc.
  *
  * This program is free software; you can redistribute it and/or
@@ -47,6 +47,9 @@
 #include <errno.h>
 #include <unistd.h>
 #include <string.h>
+#include <signal.h>
+
+#include <libscf.h>
 
 #include "netstatus-sysdeps.h"
 #include "netstatus-enums.h"
@@ -55,6 +58,11 @@
 #define NETSTATUS_IFACE_POLLS_IN_ERROR   10   /* no. of polls in error before increasing delay */
 #define NETSTATUS_IFACE_ERROR_POLL_DELAY 5000 /* delay to use when in error state */
 
+#define NWAM_AUTOMATIC_SELECTION_STRING ("Automatic Selection")
+
+#define NETSTATUS_IFACE_RESTART_SCRIPT_TESTFLAGS (G_FILE_TEST_EXISTS | G_FILE_TEST_IS_SYMLINK | G_FILE_TEST_IS_EXECUTABLE)
+static const gchar * NETSTATUS_IFACE_RESTART_SCRIPT = "/usr/bin/ifrestart";
+
 enum
 {
   PROP_0,
@@ -63,23 +71,54 @@ enum
   PROP_STATS,
   PROP_WIRELESS,
   PROP_SIGNAL_STRENGTH,
+  PROP_ESSID,
+  PROP_BSSID,
+  PROP_BSS_MODE,
+  PROP_MODE,
+  PROP_CONNECTED,
+  PROP_SECURITY,
+  PROP_AUTH_MODE,
+  PROP_TRACK_ACTIVE_INTERFACE,
   PROP_ERROR
 };
 
+enum
+{
+  RESTART_STATE,
+  LAST_SIGNAL
+};
+
 struct _NetstatusIfacePrivate
 {
   char           *name;
 
   NetstatusState  state;
   NetstatusStats  stats;
-  int             signal_strength;
   GError         *error;
 
+  
+  gboolean        connected;
+  char           *essid;
+  char           *bssid;
+  char           *bss_mode;
+  char           *mode;
+  char           *security;
+  char           *auth_mode;
+  int             signal_strength;
+
   int             sockfd;
   guint           monitor_id;
 
   guint           error_polling : 1;
   guint           is_wireless : 1;
+  gchar          *active_interface;
+  gboolean        track_active_interface;
+  gchar          *restart_output;
+  GPid            restart_pid;
+  gint            restart_status;
+  GIOChannel     *restart_outioc;
+  GIOChannel     *restart_errioc;
+  guint           restart_cwsource;
 };
 
 static void     netstatus_iface_instance_init   (NetstatusIface      *iface,
@@ -97,10 +136,12 @@ static void     netstatus_iface_get_prop
 static gboolean netstatus_iface_monitor_timeout (NetstatusIface      *iface);
 static void     netstatus_iface_init_monitor    (NetstatusIface      *iface);
 
-
+static gboolean netstatus_iface_restart_collect_output (NetstatusIface *iface);
 
 static GObjectClass *parent_class;
 
+static guint netstatus_iface_signals[LAST_SIGNAL] = { 0 };
+
 GType
 netstatus_iface_get_type (void)
 {
@@ -128,14 +169,24 @@ netstatus_iface_get_type (void)
   return type;
 }
 
-
 static void
 netstatus_iface_instance_init (NetstatusIface      *iface,
 			       NetstatusIfaceClass *klass)
 {
+  GError *err = NULL;
+
   iface->priv = g_new0 (NetstatusIfacePrivate, 1);
   
   iface->priv->state = NETSTATUS_STATE_DISCONNECTED;
+
+  iface->priv->restart_status  = -1;    /* never restarted */
+  iface->priv->restart_output  = NULL;
+  iface->priv->restart_outioc  = NULL;
+  iface->priv->restart_errioc  = NULL;
+
+  iface->priv->track_active_interface = FALSE;
+
+  iface->priv->active_interface = NULL;
 }
 
 static void
@@ -183,6 +234,86 @@ netstatus_iface_class_init (NetstatusIfa
 							 G_PARAM_READABLE));
 
   g_object_class_install_property (gobject_class,
+				   PROP_TRACK_ACTIVE_INTERFACE,
+				   g_param_spec_boolean ("track_active_interface",
+							 /* SUN_BRANDING */
+							 _("Track Active Interface"),
+							 /* SUN_BRANDING */
+							 _("Whether to track the system's active interface"),
+							 FALSE,
+							G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_ESSID,
+				   g_param_spec_string ("essid",
+						     /* SUN_BRANDING */
+						     _("ESSID"),
+						     /* SUN_BRANDING */
+						     _("Wireless ESSID"),
+						     NULL,
+						     G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_BSSID,
+				   g_param_spec_string ("bssid",
+						     /* SUN_BRANDING */
+						     _("BSSID"),
+						     /* SUN_BRANDING */
+						     _("Wireless BSSID"),
+						     NULL,
+						     G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_BSS_MODE,
+				   g_param_spec_string ("bss_mode",
+						     /* SUN_BRANDING */
+						     _("BSS_MODE"),
+						     /* SUN_BRANDING */
+						     _("Wireless BSS_Mode"),
+						     NULL,
+						     G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_CONNECTED,
+				   g_param_spec_boolean ("connected",
+							 /* SUN_BRANDING */
+							 _("Wireless CONNECTED"),
+							 /* SUN_BRANDING */
+							 _("Whether the interface is connected"),
+							 FALSE,
+							 G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_MODE,
+				   g_param_spec_string ("mode",
+						     /* SUN_BRANDING */
+						     _("MODE"),
+						     /* SUN_BRANDING */
+						     _("Wireless MODE"),
+						     NULL,
+						     G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_SECURITY,
+				   g_param_spec_string ("security",
+						     /* SUN_BRANDING */
+						     _("SECURITY"),
+						     /* SUN_BRANDING */
+						     _("Wireless SECURITY"),
+						     NULL,
+						     G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
+				   PROP_AUTH_MODE,
+				   g_param_spec_string ("auth_mode",
+						     /* SUN_BRANDING */
+						     _("AUTH_MODE"),
+						     /* SUN_BRANDING */
+						     _("Wireless AUTH_MODE"),
+						     NULL,
+						     G_PARAM_READABLE));
+
+  g_object_class_install_property (gobject_class,
 				   PROP_SIGNAL_STRENGTH,
 				   g_param_spec_int ("signal-strength",
 						     _("Signal"),
@@ -199,6 +330,16 @@ netstatus_iface_class_init (NetstatusIfa
 						       _("The current error condition"),
 						       NETSTATUS_TYPE_G_ERROR,
 						       G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+
+  netstatus_iface_signals[RESTART_STATE] = g_signal_new (
+    NETSTATUS_IFACE_SIGNAL_RESTART_STATE, 
+    G_TYPE_FROM_CLASS (gobject_class),
+    G_SIGNAL_RUN_CLEANUP | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,
+    G_STRUCT_OFFSET (NetstatusIfaceClass, restart_complete),
+    NULL, /* accumulator */
+    NULL, /* accumulator data */
+    g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+
 }
 
 static void
@@ -221,6 +362,29 @@ netstatus_iface_finalize (GObject *objec
   g_free (iface->priv->name);
   iface->priv->name = NULL;
 
+  g_free (iface->priv->essid);
+  iface->priv->essid = NULL;
+
+  g_free (iface->priv->bssid);
+  iface->priv->bssid = NULL;
+
+  g_free (iface->priv->bss_mode);
+  iface->priv->bss_mode = NULL;
+
+  g_free (iface->priv->mode);
+  iface->priv->mode = NULL;
+
+  g_free (iface->priv->security);
+  iface->priv->security = NULL;
+
+  g_free (iface->priv->auth_mode);
+  iface->priv->auth_mode = NULL;
+
+  netstatus_iface_restart_collect_output (iface);
+  if (iface->priv->restart_output != NULL)
+    g_free (iface->priv->restart_output);
+  iface->priv->restart_output = NULL;
+
   g_free (iface->priv);
   iface->priv = NULL;
 
@@ -240,6 +404,9 @@ netstatus_iface_set_property (GObject   
     case PROP_NAME:
       netstatus_iface_set_name (iface, g_value_get_string (value));
       break;
+    case PROP_TRACK_ACTIVE_INTERFACE:
+      netstatus_iface_set_track_active_interface(iface, g_value_get_boolean (value));
+      break;
     case PROP_ERROR:
       netstatus_iface_set_error (iface, g_value_get_boxed (value));
       break;
@@ -271,9 +438,33 @@ netstatus_iface_get_property (GObject   
     case PROP_WIRELESS:
       g_value_set_boolean (value, iface->priv->is_wireless);
       break;
+    case PROP_TRACK_ACTIVE_INTERFACE:
+      g_value_set_boolean (value, iface->priv->track_active_interface);
+      break;
+    case PROP_ESSID:
+      g_value_set_string (value, iface->priv->essid);
+      break;
     case PROP_SIGNAL_STRENGTH:
       g_value_set_int (value, iface->priv->signal_strength);
       break;
+    case PROP_BSSID:
+      g_value_set_string (value, iface->priv->bssid);
+      break;
+    case PROP_BSS_MODE:
+      g_value_set_string (value, iface->priv->bss_mode);
+      break;
+    case PROP_MODE:
+      g_value_set_string (value, iface->priv->mode);
+      break;
+    case PROP_CONNECTED:
+      g_value_set_boolean (value, iface->priv->connected);
+      break;
+    case PROP_SECURITY:
+      g_value_set_string (value, iface->priv->security);
+      break;
+    case PROP_AUTH_MODE:
+      g_value_set_string (value, iface->priv->auth_mode);
+      break;
     case PROP_ERROR:
       g_value_set_boxed (value, iface->priv->error);
     default:
@@ -349,6 +540,14 @@ netstatus_iface_get_is_wireless (Netstat
   return iface->priv->is_wireless;
 }
 
+gboolean
+netstatus_iface_get_is_connected (NetstatusIface *iface)
+{
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), FALSE);
+
+  return iface->priv->connected;
+}
+
 int
 netstatus_iface_get_signal_strength (NetstatusIface *iface)
 {
@@ -357,6 +556,116 @@ netstatus_iface_get_signal_strength (Net
   return iface->priv->signal_strength;
 }
 
+G_CONST_RETURN char *
+netstatus_iface_get_essid (NetstatusIface *iface)
+{
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), 0);
+
+  return iface->priv->essid;
+}
+
+G_CONST_RETURN char *
+netstatus_iface_get_bssid (NetstatusIface *iface)
+{
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), 0);
+
+  return iface->priv->bssid;
+}
+
+G_CONST_RETURN char *
+netstatus_iface_get_bss_mode (NetstatusIface *iface)
+{
+  const char*   bss_mode = NULL;
+
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), bss_mode );
+  
+  if ( iface->priv->bss_mode == NULL ) {
+      return( bss_mode );
+  }
+  
+  if ( strcmp( iface->priv->bss_mode, "bss") == 0 ) {
+      /* SUN_BRANDING */
+      bss_mode = _("Infrastructure");
+  }
+  else
+  if ( strcmp( iface->priv->bss_mode, "ibss") == 0 ) {
+      /* SUN_BRANDING */
+      bss_mode = _("Computer-to-Computer (Ad Hoc)");
+  }
+  else  if ( strcmp( iface->priv->bss_mode, "any") == 0 ) {
+      /* SUN_BRANDING */
+      bss_mode = _("Any");
+  }
+
+
+  return bss_mode; 
+}
+
+G_CONST_RETURN char *
+netstatus_iface_get_mode (NetstatusIface *iface)
+{
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), 0);
+
+  return iface->priv->mode;
+}
+
+G_CONST_RETURN char *
+netstatus_iface_get_security (NetstatusIface *iface)
+{
+  const char*   security = NULL;
+
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), 0);
+
+  if ( iface->priv->security == NULL ) {
+      return( security );
+  }
+
+  if ( strcmp( iface->priv->security, "none") == 0 ) {
+      /* SUN_BRANDING */
+      security = _("None");
+  }
+  else
+  if ( strcmp( iface->priv->security, "wep") == 0 ) {
+      security = "WEP";
+  }
+  else
+  if ( strcmp( iface->priv->security, "wpa") == 0 ) {
+      security = "WPA";
+  }
+  else {
+      security = iface->priv->security;
+  }
+
+  return security;
+}
+
+G_CONST_RETURN char *
+netstatus_iface_get_auth_mode (NetstatusIface *iface)
+{
+  const char*   auth_mode = NULL;
+
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), 0);
+
+  if ( iface->priv->auth_mode == NULL ) {
+      return( auth_mode );
+  }
+
+  if ( strcmp( iface->priv->auth_mode, "open") == 0 ) {
+      /* SUN_BRANDING */
+      auth_mode = _("Open");
+  }
+  else
+  if ( strcmp( iface->priv->auth_mode, "shared") == 0 ) {
+      /* SUN_BRANDING */
+      auth_mode = _("Shared");
+  }
+  else {
+      auth_mode = iface->priv->auth_mode;
+  }
+
+  return auth_mode;
+}
+
 void
 netstatus_iface_set_error (NetstatusIface *iface,
 			   const GError   *error)
@@ -553,14 +862,57 @@ netstatus_iface_poll_state (NetstatusIfa
 
 static gboolean
 netstatus_iface_poll_wireless_details (NetstatusIface *iface,
-				       int            *signal_strength)
+				       int            *signal_strength,
+                       gboolean       *connected,
+                       char          **essid,
+                       char          **bssid,
+                       char          **bss_mode,
+                       char          **mode,
+                       char          **security,
+                       char          **auth_mode )
 {
   char     *error_message;
   gboolean  is_wireless;
+#if defined(__sun)
+  wifi_info_t*  wi = netstatus_sysdeps_read_iface_wireless_details (iface->priv->name);
+
+  if ( wi != NULL ) {
+    is_wireless = TRUE;
+    if ( signal_strength )
+      *signal_strength = wi->signal_strength;
+
+    if ( connected )
+      *connected = wi->connected;
 
+    if ( essid ) {
+      *essid = g_strdup( wi->essid );
+    }
+    if ( bssid ) {
+      *bssid = g_strdup( wi->bssid );
+    }
+    if ( bss_mode ) {
+      *bss_mode = g_strdup( wi->bss_mode );
+    }
+    if ( mode ) {
+      *mode = g_strdup( wi->mode );
+    }
+    if ( security ) {
+      *security = g_strdup( wi->security );
+    }
+    if ( auth_mode ) {
+      *auth_mode = g_strdup( wi->auth_mode );
+    }
+    netstatus_wifi_info_free(wi);
+  }
+  else {
+    is_wireless = FALSE;
+  }
+#else 
   error_message = netstatus_sysdeps_read_iface_wireless_details (iface->priv->name,
 								 &is_wireless,
-								 signal_strength);
+								 signal_strength,
+                                 essid,
+                                 max_essid_len );
 
   if (error_message)
     {
@@ -574,6 +926,7 @@ netstatus_iface_poll_wireless_details (N
 
   netstatus_iface_clear_error (iface, NETSTATUS_ERROR_WIRELESS_DETAILS);
 
+#endif
   return is_wireless;
 }
 
@@ -611,12 +964,21 @@ netstatus_iface_increase_poll_delay_in_e
     }
 }
 
+#define MAX_ESSID_LEN   128
+
 static gboolean
 netstatus_iface_monitor_timeout (NetstatusIface *iface)
 {
   NetstatusState state;
   int            signal_strength;
-  gboolean       is_wireless;
+  char          *essid = NULL;
+  char          *bssid = NULL;
+  char          *bss_mode = NULL;
+  gboolean       connected = FALSE;       
+  char          *mode = NULL;
+  char          *security = NULL;
+  char          *auth_mode = NULL;
+  gboolean       is_wireless = NULL;
  
   state = netstatus_iface_poll_state (iface);
 
@@ -627,19 +989,115 @@ netstatus_iface_monitor_timeout (Netstat
       g_object_notify (G_OBJECT (iface), "state");
     }
 
-  is_wireless = netstatus_iface_poll_wireless_details (iface, &signal_strength);
+  /* Look for another interface it tracking active i/f  */
+  netstatus_iface_find_active_interface (iface);
+
+  is_wireless = netstatus_iface_poll_wireless_details (iface, &signal_strength, &connected, &essid,
+                                                       &bssid, &bss_mode, &mode, &security, &auth_mode );
   if (iface->priv->is_wireless != is_wireless)
     {
       iface->priv->is_wireless = is_wireless;
       g_object_notify (G_OBJECT (iface), "wireless");
     }
 
-  if (iface->priv->signal_strength != signal_strength)
-    {
-      iface->priv->signal_strength = signal_strength;
-      g_object_notify (G_OBJECT (iface), "signal-strength");
+  if ( is_wireless ) {
+      if (iface->priv->connected != connected)
+        {
+          iface->priv->connected = connected;
+          g_object_notify (G_OBJECT (iface), "connected");
+        }
+
+    if (iface->priv->signal_strength != signal_strength)
+      {
+        iface->priv->signal_strength = signal_strength;
+        g_object_notify (G_OBJECT (iface), "signal-strength");
+      }
+
+    if (iface->priv->essid == NULL || 
+        ( essid != NULL && strcmp(iface->priv->essid, essid ) != 0 ) )
+      {
+        if ( iface->priv->essid != NULL )
+            g_free(iface->priv->essid);
+
+        iface->priv->essid = essid;
+
+        g_object_notify (G_OBJECT (iface), "essid");
+      }
+    else if ( essid ) {
+      g_free(essid);
     }
 
+    if (iface->priv->bssid == NULL || 
+        ( bssid != NULL && strcmp(iface->priv->bssid, bssid ) != 0 ) )
+      {
+        if ( iface->priv->bssid != NULL )
+            g_free(iface->priv->bssid);
+
+        iface->priv->bssid = bssid;
+
+        g_object_notify (G_OBJECT (iface), "bssid");
+      }
+    else if ( bssid ) {
+      g_free(bssid);
+    }
+
+    if (iface->priv->bss_mode == NULL || 
+        ( bss_mode != NULL && strcmp(iface->priv->bss_mode, bss_mode ) != 0 ) )
+      {
+        if ( iface->priv->bss_mode != NULL )
+            g_free(iface->priv->bss_mode);
+
+        iface->priv->bss_mode = bss_mode;
+
+        g_object_notify (G_OBJECT (iface), "bss_mode");
+      }
+    else if ( bss_mode ) {
+      g_free(bss_mode);
+    }
+
+    if (iface->priv->mode == NULL || 
+        ( mode != NULL && strcmp(iface->priv->mode, mode ) != 0 ) )
+      {
+        if ( iface->priv->mode != NULL )
+            g_free(iface->priv->mode);
+
+        iface->priv->mode = mode;
+
+        g_object_notify (G_OBJECT (iface), "mode");
+      }
+    else if ( mode ) {
+      g_free(mode);
+    }
+
+    if (iface->priv->security == NULL || 
+        ( security != NULL && strcmp(iface->priv->security, security ) != 0 ) )
+      {
+        if ( iface->priv->security != NULL )
+            g_free(iface->priv->security);
+
+        iface->priv->security = security;
+
+        g_object_notify (G_OBJECT (iface), "security");
+      }
+    else if ( security ) {
+      g_free(security);
+    }
+
+    if (iface->priv->auth_mode == NULL || 
+        ( auth_mode != NULL && strcmp(iface->priv->auth_mode, auth_mode ) != 0 ) )
+      {
+        if ( iface->priv->auth_mode != NULL )
+            g_free(iface->priv->auth_mode);
+
+        iface->priv->auth_mode = auth_mode;
+
+        g_object_notify (G_OBJECT (iface), "auth_mode");
+      }
+    else if ( auth_mode ) {
+      g_free(auth_mode);
+    }
+  }
+
   netstatus_iface_increase_poll_delay_in_error (iface);
   
   return TRUE;
@@ -653,12 +1111,20 @@ netstatus_iface_init_monitor (NetstatusI
   iface->priv->stats.in_bytes    = 0;
   iface->priv->stats.out_bytes   = 0;
   iface->priv->signal_strength   = 0;
+  iface->priv->essid  = NULL;
   iface->priv->is_wireless       = FALSE;
+  iface->priv->connected = FALSE;
+  iface->priv->bssid = NULL;
+  iface->priv->bss_mode = NULL;
+  iface->priv->mode = NULL;
+  iface->priv->security = NULL;
+  iface->priv->auth_mode = NULL;
 
   g_object_freeze_notify (G_OBJECT (iface));
   g_object_notify (G_OBJECT (iface), "state");
   g_object_notify (G_OBJECT (iface), "wireless");
   g_object_notify (G_OBJECT (iface), "signal-strength");
+  g_object_notify (G_OBJECT (iface), "essid");
   g_object_thaw_notify (G_OBJECT (iface));
 
   if (iface->priv->monitor_id)
@@ -1024,7 +1490,7 @@ netstatus_iface_get_hw_details (Netstatu
 				char           **hw_addr)
 				
 {
-#ifdef SIOCGIFHWADDR
+#if defined(SIOCGIFHWADDR) && !defined(sun)
   static struct HwType *hw_type = NULL;
   struct ifreq          if_req;
   int                   fd;
@@ -1192,6 +1658,7 @@ netstatus_list_interface_names (GError *
 
   struct ifconf *if_conf;
   GList         *interfaces;
+  GList         *point_to_points;
   GList         *loopbacks;
   char          *p;
   int            fd;
@@ -1214,11 +1681,13 @@ netstatus_list_interface_names (GError *
 
   interfaces = NULL;
   loopbacks  = NULL;
+  point_to_points = NULL;
 
   for (p = if_conf->ifc_buf; p < if_conf->ifc_buf + if_conf->ifc_len;)
     {
       struct ifreq *if_req = (struct ifreq *) p;
       gboolean      loopback = FALSE;
+      gboolean      p2p = FALSE;
 
       p += sizeof (if_req->ifr_name) + NETSTATUS_SA_LEN (&if_req->ifr_addr);
 
@@ -1233,16 +1702,21 @@ netstatus_list_interface_names (GError *
       else
 	{
 	  loopback = (if_req->ifr_flags & IFF_LOOPBACK);
+          p2p = (if_req->ifr_flags & IFF_POINTOPOINT);
 	}
 
-      if (!loopback)
-	interfaces = netstatus_list_insert_unique (interfaces,
+      if (loopback)
+	loopbacks  = netstatus_list_insert_unique (loopbacks,
+						   g_strdup (if_req->ifr_name));
+      else if (p2p)
+	point_to_points  = netstatus_list_insert_unique (point_to_points,
 						   g_strdup (if_req->ifr_name));
       else
-	loopbacks  = netstatus_list_insert_unique (loopbacks,
+	interfaces = netstatus_list_insert_unique (interfaces,
 						   g_strdup (if_req->ifr_name));
     }
 
+  interfaces = g_list_concat (interfaces, point_to_points );
   interfaces = g_list_concat (interfaces, loopbacks);
 
   g_free (if_conf->ifc_buf);
@@ -1256,3 +1730,323 @@ netstatus_list_interface_names (GError *
 
   return interfaces;
 }
+
+
+/*
+ * Returns TRUE if the ifrestart script is installed.
+ */
+gboolean
+netstatus_iface_restart_available (NetstatusIface *iface)
+{
+  g_return_val_if_fail ((iface != NULL), FALSE);
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), FALSE);
+
+  return g_file_test (
+    NETSTATUS_IFACE_RESTART_SCRIPT, NETSTATUS_IFACE_RESTART_SCRIPT_TESTFLAGS);
+}
+
+/*
+ * Returns TRUE if the restart in progress.
+ */
+gboolean
+netstatus_iface_restart_inprogress (NetstatusIface *iface)
+{
+  g_return_val_if_fail ((iface != NULL), FALSE);
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), FALSE);
+  g_return_val_if_fail ((iface->priv != NULL), 0);
+
+  return (iface->priv->restart_status == -2);
+}
+
+/*
+ * Sets the interface restart status and emmits the signal.
+ */
+static void 
+netstatus_iface_restart_set_status (
+  NetstatusIface *iface, gint status)
+{
+  g_return_if_fail (iface != NULL);
+  g_return_if_fail (NETSTATUS_IS_IFACE (iface));
+  g_return_if_fail (iface->priv != NULL);
+
+  /* Restart process exit status */
+  iface->priv->restart_status = status;
+
+  /* Emit restart complete signal */
+  g_signal_emit (iface, 
+    netstatus_iface_signals[RESTART_STATE], 0);
+}
+
+/*
+ * Collect output and release IOChannels.
+ * This method returns TRUE if the error output was empty.
+ */
+static gboolean
+netstatus_iface_restart_collect_output (NetstatusIface *iface)
+{
+  gchar *  outstr  = NULL;
+  gsize    outsize = 0;
+  gchar *  errstr  = NULL;
+  gsize    errsize = 0;
+  GError * error   = NULL;
+
+  g_return_val_if_fail ((iface != NULL), FALSE);
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), FALSE);
+  g_return_val_if_fail ((iface->priv != NULL), FALSE);
+
+  /* Release stdout channel */
+  if (iface->priv->restart_outioc != NULL)
+    {
+      g_io_channel_read_to_end (iface->priv->restart_outioc,
+        &outstr, &outsize, &error);
+      g_io_channel_shutdown (iface->priv->restart_outioc, FALSE, &error);
+      g_io_channel_unref (iface->priv->restart_outioc);
+      iface->priv->restart_outioc = NULL;
+    }
+  /* Release stderr channel */
+  if (iface->priv->restart_errioc != NULL)
+    {
+      g_io_channel_read_to_end (iface->priv->restart_errioc,
+        &errstr, &errsize, &error);
+      g_io_channel_shutdown (iface->priv->restart_errioc, FALSE, &error);
+      g_io_channel_unref (iface->priv->restart_errioc);
+      iface->priv->restart_errioc = NULL;
+    }
+  /* Release the last interface restart output */
+  if (iface->priv->restart_output != NULL)
+    g_free (iface->priv->restart_output);
+  iface->priv->restart_output == NULL;
+  /* New restart output */
+  if (errsize != 0)
+    {
+      iface->priv->restart_output = g_strdup (errstr);
+    }
+  else if (outsize != 0)
+    {
+      iface->priv->restart_output = g_strdup (outstr);
+    }
+  if (outstr != NULL)
+    g_free (outstr);
+  if (errstr != NULL)
+    g_free (errstr);
+
+  return (errsize == 0);
+}
+
+/*
+ * Interface restart completition routine.
+ */
+static void 
+netstatus_iface_restart_complete (
+  GPid pid, gint status, NetstatusIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+  g_return_if_fail (NETSTATUS_IS_IFACE (iface));
+  g_return_if_fail (iface->priv != NULL);
+
+  iface->priv->restart_cwsource = 0;
+
+  /* Release the output and error IOChannels */
+  if (netstatus_iface_restart_collect_output (iface))
+    {
+      netstatus_iface_restart_set_status (iface, status);
+    }
+  else
+    {
+      netstatus_iface_restart_set_status (iface, (status == 0)? 9999: status);
+    }
+}
+
+/*
+ * Initiates the restart for current interface and returns pid of 
+ * the restart process. Returns 0 if the restart fails.
+ */
+GPid
+netstatus_iface_restart (NetstatusIface *iface)
+{
+  gchar *   argv[3];
+  gint      out_fd;
+  gint      err_fd;
+  gboolean  result;
+  GError *  error = NULL;
+
+  g_return_val_if_fail ((iface != NULL), 0);
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), 0);
+  g_return_val_if_fail ((iface->priv != NULL), 0);
+  g_return_val_if_fail ((netstatus_iface_restart_inprogress (iface) == FALSE), 0);
+  g_return_val_if_fail ((netstatus_iface_get_name (iface) != NULL), 0);
+
+  /* Release the last interface restart output */
+  iface->priv->restart_outioc  = NULL;
+  iface->priv->restart_errioc  = NULL;
+  if (iface->priv->restart_output != NULL)
+    g_free (iface->priv->restart_output);
+  iface->priv->restart_output  = NULL;
+  netstatus_iface_restart_set_status (iface, -2);    /* is restarting */
+  argv[0] = g_strdup (NETSTATUS_IFACE_RESTART_SCRIPT);
+  argv[1] = g_strdup (netstatus_iface_get_name (iface));
+  argv[2] = NULL;
+  result = g_spawn_async_with_pipes (
+    NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+    NULL, NULL, 
+    &(iface->priv->restart_pid), 
+    NULL, &(out_fd), &(err_fd), 
+    &error);
+  g_free (argv[1]);
+  g_free (argv[0]);
+  if (result == FALSE)
+    {
+      /* Clean up on unsuccessful spawn */
+      netstatus_iface_restart_complete (0, G_SPAWN_ERROR_FAILED, iface);
+      return 0;
+    }
+
+  iface->priv->restart_outioc = g_io_channel_unix_new (out_fd);
+  iface->priv->restart_errioc = g_io_channel_unix_new (err_fd);
+  /* Set up the completition routine */
+  iface->priv->restart_cwsource = g_child_watch_add (iface->priv->restart_pid,
+    (GChildWatchFunc)netstatus_iface_restart_complete, iface);
+
+  return iface->priv->restart_pid;
+}
+
+/*
+ * Returns the process exit status of the last interface restart.
+ */
+gint
+netstatus_iface_restart_get_status (NetstatusIface  *iface)
+{
+  g_return_val_if_fail ((iface != NULL), -1);
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), -1);
+  g_return_val_if_fail ((iface->priv != NULL), -1);
+
+  return iface->priv->restart_status;
+}
+
+/*
+ * Returns an output of the last interface restart. 
+ */
+G_CONST_RETURN gchar *
+netstatus_iface_restart_get_output (NetstatusIface *iface)
+{
+  g_return_val_if_fail ((iface != NULL), "");
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), "");
+  g_return_val_if_fail ((iface->priv != NULL), "");
+
+  return (iface->priv->restart_output)? iface->priv->restart_output: "";
+}
+
+/*
+ * Interrupts the restart
+ */
+void
+netstatus_iface_restart_interrupt (NetstatusIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+  g_return_if_fail (NETSTATUS_IS_IFACE (iface));
+  g_return_if_fail (iface->priv != NULL);
+  g_return_if_fail (netstatus_iface_restart_inprogress (iface) == TRUE);
+
+  kill (iface->priv->restart_pid, SIGKILL);
+}
+
+gboolean
+netstatus_iface_get_track_active_interface (NetstatusIface  *iface)
+{
+  gboolean track_active = FALSE;
+
+  g_return_val_if_fail (iface != NULL, track_active );
+  g_return_val_if_fail (NETSTATUS_IS_IFACE (iface), track_active );
+  g_return_val_if_fail (iface->priv != NULL, track_active );
+
+  track_active = iface->priv->track_active_interface;
+
+  return( track_active );
+}
+
+void
+netstatus_iface_set_track_active_interface (NetstatusIface  *iface, gboolean track_active )
+{
+  g_return_if_fail (iface != NULL);
+  g_return_if_fail (NETSTATUS_IS_IFACE (iface));
+  g_return_if_fail (iface->priv != NULL);
+
+  if ( iface->priv->track_active_interface != track_active ) {
+      iface->priv->track_active_interface = track_active;
+
+      if ( track_active ) {
+          if ( iface->priv->active_interface != NULL && strlen(iface->priv->active_interface)> 0 ) {
+            netstatus_iface_set_name( iface, iface->priv->active_interface );
+          }
+          else {
+              netstatus_iface_find_active_interface(iface);
+          }
+      }
+
+      g_object_notify (G_OBJECT (iface), "track_active_interface");
+  }
+}
+
+void
+netstatus_iface_find_active_interface (NetstatusIface  *iface )
+{
+  GError *error = NULL;
+  GList  *iface_names;
+  gchar  *iface_name = NULL;
+
+  g_return_if_fail (iface != NULL);
+  g_return_if_fail (NETSTATUS_IS_IFACE (iface));
+  g_return_if_fail (iface->priv != NULL);
+
+  if (!iface->priv->track_active_interface)
+      return;
+
+  iface_names = netstatus_list_interface_names (&error);
+
+  if (iface_names)
+    {
+      GList *l;
+      gulong in_packets, out_packets;
+      gulong in_bytes, out_bytes;
+      char *error_message;
+      /* 
+       * Find first non error interface.
+       */
+      for (l = iface_names; l; l = l->next) {
+        if ( l->data && strncmp(l->data, "lo", 2) &&
+            (error_message = netstatus_sysdeps_read_iface_statistics (l->data,
+             &in_packets, &out_packets, &in_bytes, &out_bytes)) == NULL ) {
+            gchar *old_name = iface->priv->name;
+
+            /* Temporarily set the name, but don't use set_name function
+             * since it would signal a notification which we don't want here.
+             */
+            iface->priv->name = l->data;
+            NetstatusState state = netstatus_iface_poll_state (iface);
+            iface->priv->name = old_name;
+
+            if ( state != NETSTATUS_STATE_DISCONNECTED &&
+                 state != NETSTATUS_STATE_ERROR ) {
+                /* Success !! make this the iface_name */
+                iface_name = l->data;
+                break;
+            }
+        } else if (error_message != NULL ) {
+            g_free (error_message);
+        }
+      }
+
+      for (l = iface_names; l; l = l->next) {
+        /* Only free non used names */
+        if (iface_name == NULL || strcmp(l->data, iface_name)) {
+          g_free (l->data);
+        }
+      }
+      g_list_free (iface_names);
+
+      if ( iface_name ) {
+          netstatus_iface_set_name( iface, iface_name );
+          g_free( iface_name );
+      }
+    }
+}

diff -up ./src/netstatus-iface.h.clean ./src/netstatus-iface.h
--- ./src/netstatus-iface.h.clean	2009-10-20 08:28:14.754379483 +0100
+++ ./src/netstatus-iface.h	2009-10-20 08:21:43.523770530 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2003 Sun Microsystems, Inc.
+ * Copyright (C) 2003-2009 Sun Microsystems, Inc.
  * Copyright (C) 2004 Red Hat Inc.
  *
  * This program is free software; you can redistribute it and/or
@@ -39,6 +39,8 @@ G_BEGIN_DECLS
 #define NETSTATUS_IS_IFACE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), NETSTATUS_TYPE_IFACE))
 #define NETSTATUS_IFACE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), NETSTATUS_TYPE_IFACE, NetstatusIfaceClass))
 
+#define NETSTATUS_IFACE_SIGNAL_RESTART_STATE "restart_state"
+
 typedef struct _NetstatusIface        NetstatusIface;
 typedef struct _NetstatusIfaceClass   NetstatusIfaceClass;
 typedef struct _NetstatusIfacePrivate NetstatusIfacePrivate;
@@ -53,6 +55,8 @@ struct _NetstatusIface
 struct _NetstatusIfaceClass
 {
   GObjectClass parent_class;
+
+  void (*restart_complete) (GObject *iface);
 };
 
 GList *                netstatus_list_interface_names        (GError         **error);
@@ -69,6 +73,13 @@ void                   netstatus_iface_g
 							      NetstatusStats  *stats);
 gboolean               netstatus_iface_get_is_wireless       (NetstatusIface  *iface);
 int                    netstatus_iface_get_signal_strength   (NetstatusIface  *iface);
+gboolean               netstatus_iface_get_is_connected      (NetstatusIface  *iface);
+G_CONST_RETURN char *  netstatus_iface_get_essid             (NetstatusIface  *iface);
+G_CONST_RETURN char *  netstatus_iface_get_bssid             (NetstatusIface  *iface);
+G_CONST_RETURN char *   netstatus_iface_get_bss_mode         (NetstatusIface *iface);
+G_CONST_RETURN char *  netstatus_iface_get_mode              (NetstatusIface  *iface);
+G_CONST_RETURN char *  netstatus_iface_get_security          (NetstatusIface  *iface);
+G_CONST_RETURN char *  netstatus_iface_get_auth_mode         (NetstatusIface  *iface);
 
 void                   netstatus_iface_set_error             (NetstatusIface  *iface,
 							      const GError    *error);
@@ -86,6 +97,17 @@ gboolean               netstatus_iface_g
 							      char           **hw_addr);
 gboolean               netstatus_iface_get_is_loopback       (NetstatusIface  *iface);
 
+gboolean               netstatus_iface_restart_available (NetstatusIface  *iface);
+gboolean               netstatus_iface_restart_inprogress (NetstatusIface  *iface);
+GPid                   netstatus_iface_restart (NetstatusIface  *iface);
+gint                   netstatus_iface_restart_get_status (NetstatusIface  *iface);
+G_CONST_RETURN gchar * netstatus_iface_restart_get_output (NetstatusIface  *iface);
+void                   netstatus_iface_restart_interrupt (NetstatusIface  *iface);
+
+gboolean               netstatus_iface_get_track_active_interface (NetstatusIface  *iface);
+void                   netstatus_iface_set_track_active_interface (NetstatusIface  *iface, gboolean track_active );
+void                   netstatus_iface_find_active_interface (NetstatusIface  *iface );
+
 G_END_DECLS
 
 #endif /* __NETSTATUS_IFACE_H__ */

--- gnome-netstatus-2.28.0.orig/src/netstatus.schemas.in	2009-09-25 11:46:34.295222345 +0100
+++ gnome-netstatus-2.28.0/src/netstatus.schemas.in	2009-09-25 11:46:40.209120418 +0100
@@ -12,6 +12,17 @@
       </locale>
     </schema>
 
+    <schema>
+      <key>/schemas/apps/netstatus_applet/prefs/track_active_interface</key>
+      <owner>netstatus-applet</owner>
+      <type>bool</type>
+      <default>false</default>
+      <locale name="C">
+        <short>Track active Network Interface</short>
+        <long>Have Network Monitor keep track of the active Network Interface</long>
+      </locale>
+    </schema>
+
     <!-- Yes, this key is purposely global to all instances of the applet -->
     <schema>
       <key>/schemas/apps/netstatus_applet/config_tool</key>
--- gnome-netstatus-2.28.0.orig/src/netstatus-applet.c	2009-09-25 11:46:34.295930633 +0100
+++ gnome-netstatus-2.28.0/src/netstatus-applet.c	2009-09-25 12:07:05.866671745 +0100
@@ -45,6 +45,7 @@
   
   GConfClient    *client;
   guint           notify_id;
+  guint           track_active_interface_id;
 };
 
 static void     netstatus_applet_instance_init             (NetstatusApplet           *applet,
@@ -69,6 +70,7 @@
 							    NetstatusApplet           *applet);
 static void     netstatus_applet_display_status_dialog     (NetstatusApplet           *applet);
 static void     netstatus_applet_iface_name_changed        (NetstatusApplet           *applet);
+static void     netstatus_applet_iface_track_active_changed(NetstatusApplet *applet);
 
 static GObjectClass *parent_class;
 
@@ -127,6 +129,10 @@
 			    G_CALLBACK (netstatus_applet_iface_name_changed),
 			    applet);
 
+  g_signal_connect_swapped (applet->priv->iface, "notify::track-active-interface",
+			    G_CALLBACK (netstatus_applet_iface_track_active_changed),
+			    applet);
+
   g_signal_connect_swapped (applet->priv->icon, "invoked",
 			    G_CALLBACK (netstatus_applet_display_status_dialog),
 			    applet);
@@ -168,6 +174,10 @@
     gconf_client_notify_remove (applet->priv->client, applet->priv->notify_id);
   applet->priv->notify_id = 0;
 
+  if (applet->priv->track_active_interface_id)
+    gconf_client_notify_remove (applet->priv->client, applet->priv->track_active_interface_id);
+  applet->priv->track_active_interface_id = 0;
+
   if (applet->priv->client)
     g_object_unref (applet->priv->client);
   applet->priv->client = NULL;
@@ -375,6 +385,19 @@
 }
 
 static void
+netstatus_applet_iface_track_active_changed(NetstatusApplet *applet)
+{
+  gboolean track_active;
+
+  track_active = netstatus_iface_get_track_active_interface (applet->priv->iface);
+  panel_applet_gconf_set_bool(PANEL_APPLET (applet),
+                 "track_active_interface",
+                 track_active,
+                 NULL);
+
+}
+
+static void
 netstatus_applet_iface_name_changed (NetstatusApplet *applet)
 {
   const char *iface_name;
@@ -397,10 +420,29 @@
 {
   if (entry->value && entry->value->type == GCONF_VALUE_STRING)
     {
+      gboolean    track_active;
       const char *iface_name;
 
-      iface_name = gconf_value_get_string (entry->value);
-      netstatus_iface_set_name (applet->priv->iface, iface_name);
+      track_active = netstatus_iface_get_track_active_interface(applet->priv->iface);
+      if ( !track_active ) {
+          iface_name = gconf_value_get_string (entry->value);
+          netstatus_iface_set_name (applet->priv->iface, iface_name);
+      }
+    }
+}
+
+static void
+netstatus_applet_iface_track_active_interface_changed (GConfClient     *client,
+				     guint            cnxn_id,
+				     GConfEntry      *entry,
+				     NetstatusApplet *applet)
+{
+  if (entry->value && entry->value->type == GCONF_VALUE_BOOL)
+    {
+      gboolean track_active;
+
+      track_active = gconf_value_get_bool(entry->value);
+      netstatus_iface_set_track_active_interface (applet->priv->iface, track_active);
     }
 }
 
@@ -408,6 +450,7 @@
 netstatus_applet_create (NetstatusApplet *applet,
 			 const char      *iid)
 {
+  gboolean track_active = FALSE;
   char *iface_name;
   char *key;
 
@@ -424,45 +467,53 @@
   panel_applet_add_preferences (PANEL_APPLET (applet),
 				"/schemas/apps/netstatus_applet/prefs",
 				NULL);
-
-  iface_name = panel_applet_gconf_get_string (PANEL_APPLET (applet),
-					      "interface",
-					      NULL);
-  if (!iface_name || !iface_name [0])
-    {
-      GError *error = NULL;
-      GList  *iface_names;
-
-      g_free (iface_name);
-      iface_name = NULL;
-      
-      iface_names = netstatus_list_interface_names (&error);
-      if (iface_names)
-	{
-	  GList *l;
-
-	  /* FIXME: instead of picking the first one we should
-	   *        figure out what interfaces aren't currently
-	   *        displayed in an applet.
-	   */
-	  iface_name = iface_names->data;
-
-	  for (l = iface_names->next; l; l = l->next)
-	    g_free (l->data);
-	  g_list_free (iface_names);
-	}
-      else
-	{
-	  g_assert (error != NULL);
-	  g_object_set (G_OBJECT (applet->priv->iface),
-			"error", error,
-			NULL);
-	  g_error_free (error);
-	}
-    }
-
-  netstatus_iface_set_name (applet->priv->iface, iface_name);
-  g_free (iface_name);
+  track_active = panel_applet_gconf_get_bool (PANEL_APPLET (applet),
+					      "track_active_interface",
+ 					      NULL);
+  
+  if ( track_active ) {
+      netstatus_iface_set_track_active_interface (applet->priv->iface, track_active );
+  }
+  else {
+          iface_name = panel_applet_gconf_get_string (PANEL_APPLET (applet),
+					              "interface",
+					              NULL);
+          if (!iface_name || !iface_name [0])
+            {
+              GError *error = NULL;
+              GList  *iface_names;
+
+              g_free (iface_name);
+              iface_name = NULL;
+              
+              iface_names = netstatus_list_interface_names (&error);
+              if (iface_names)
+	        {
+	          GList *l;
+
+	          /* FIXME: instead of picking the first one we should
+	           *        figure out what interfaces aren't currently
+	           *        displayed in an applet.
+	           */
+	          iface_name = iface_names->data;
+
+	          for (l = iface_names->next; l; l = l->next)
+	            g_free (l->data);
+	          g_list_free (iface_names);
+	        }
+              else
+	        {
+	          g_assert (error != NULL);
+	          g_object_set (G_OBJECT (applet->priv->iface),
+			        "error", error,
+			        NULL);
+	          g_error_free (error);
+	        }
+            }
+
+          netstatus_iface_set_name (applet->priv->iface, iface_name);
+          g_free (iface_name);
+   }
 
   key = panel_applet_gconf_get_full_key (PANEL_APPLET (applet), "interface");
   applet->priv->notify_id =
@@ -474,6 +525,17 @@
 			     NULL);
   g_free (key);
 
+  key = panel_applet_gconf_get_full_key (PANEL_APPLET (applet), "track_active_interface");
+
+  applet->priv->track_active_interface_id =
+    gconf_client_notify_add (applet->priv->client,
+			     key,
+			     (GConfClientNotifyFunc) netstatus_applet_iface_track_active_interface_changed,
+			     applet,
+			     NULL,
+			     NULL);
+  g_free (key);
+
   return TRUE;
 }
 
--- gnome-netstatus-2.28.0.orig/icons/Makefile.am	2009-09-25 11:46:34.274343975 +0100
+++ gnome-netstatus-2.28.0/icons/Makefile.am	2009-09-25 11:46:40.210390602 +0100
@@ -1,15 +1,4 @@
-icondir = $(datadir)/icons/hicolor/48x48/apps
-icon_DATA = 				\
-	gnome-netstatus-disconn.png	\
-	gnome-netstatus-idle.png	\
-	gnome-netstatus-rx.png		\
-	gnome-netstatus-tx.png		\
-	gnome-netstatus-txrx.png        \
-	gnome-netstatus-error.png       \
-	gnome-netstatus-0-24.png        \
-	gnome-netstatus-25-49.png       \
-	gnome-netstatus-50-74.png       \
-	gnome-netstatus-75-100.png
+SUBDIRS= hicolor
 
 gtk_update_icon_cache = gtk-update-icon-cache -f -t $(datadir)/icons/hicolor
 install-data-hook: update-icon-cache
@@ -23,4 +12,3 @@
 		echo "***   $(gtk_update_icon_cache)"; \
 	fi
 
-EXTRA_DIST = $(icon_DATA)
--- gnome-netstatus-2.28.0.orig/src/netstatus-sysdeps.h	2009-09-25 11:46:34.295394995 +0100
+++ gnome-netstatus-2.28.0/src/netstatus-sysdeps.h	2009-09-25 11:46:40.212586971 +0100
@@ -34,9 +34,36 @@
 						     gulong     *out_packets,
 						     gulong     *in_bytes,
 						     gulong     *out_bytes);
+#if defined (__sun)
+
+typedef struct {
+    char       *essid;
+    gboolean    connected;       
+    char       *bssid;
+    char       *bss_mode;
+    int         signal_strength;
+    char       *mode;
+    char       *security;
+    char       *auth_mode;
+} wifi_info_t;
+
+wifi_info_t* netstatus_wifi_info_new(   char       *essid,
+                                        gboolean    connected,
+                                        char       *bssid,
+                                        char       *bss_mode,
+                                        int         signal_strength,
+                                        char       *mode,
+                                        char       *security,
+                                        char       *auth_mode );
+
+void netstatus_wifi_info_free( wifi_info_t * wi );
+
+wifi_info_t *netstatus_sysdeps_read_iface_wireless_details (const char *iface);
+#else
 char *netstatus_sysdeps_read_iface_wireless_details (const char *iface,
 						     gboolean   *is_wireless,
 						     int        *signal_strength);
+#endif
 
 G_END_DECLS
 
--- gnome-netstatus-2.28.0.orig/src/wifi_info.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-netstatus-2.28.0/src/wifi_info.c	2009-09-25 11:46:40.212927446 +0100
@@ -0,0 +1,379 @@
+/*
+ * Simple test program, that takes a wireles device as an argument, and then
+ * tries to gather various configuration information from it.
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stropts.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <inet/wifi_ioctl.h>
+#include <net/if_types.h>
+#include <net/if_dl.h> /*_link_ntoa*/
+
+#define TRUE   (1)
+#define FALSE  (0)
+
+#define DEV_PATH_PREFIX "/dev/"
+
+const int debug = 0;
+
+wldp_t  *gbuf = NULL;
+
+int 
+get_value( int fd, wldp_t *buf, int prop_id )
+{
+    int             rc;
+    struct strioctl stri;
+
+    (void) memset(gbuf, 0, MAX_BUF_LEN);
+
+    gbuf->wldp_type     =   NET_802_11;
+    gbuf->wldp_id       =   prop_id;
+    gbuf->wldp_length   =   sizeof( wldp_t );
+    stri.ic_timout      =   0;
+    stri.ic_dp          =   (char*)gbuf;
+    stri.ic_cmd         =   WLAN_GET_PARAM;
+    stri.ic_len         =   sizeof( wldp_t );
+
+    if ( (rc = ioctl( fd, I_STR, &stri )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_value( %d ): rc = %d\n", prop_id, rc);
+        return( -1 );
+    }
+    return( rc );
+}
+
+int
+is_connected( int fd ) 
+{
+    int rc;
+
+    if ( (rc = get_value( fd, gbuf, WL_LINKSTATUS )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "is_connected: rc = %d\n", rc);
+        return( -1 );
+    }
+
+    return((*(wl_linkstatus_t *)((gbuf)->wldp_buf) == WL_CONNECTED));
+}
+
+int
+is_wifi( int fd ) 
+{
+    return( (get_value(fd, gbuf, WL_BSS_TYPE ) < 0 )?FALSE:TRUE );
+}
+
+int
+get_signal_strength( int fd ) 
+{
+    int             rc;
+
+    if ( (rc = get_value( fd, gbuf, WL_RSSI )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_signal_strength: rc = %d\n", rc);
+        return( -1 );
+    }
+
+    return( *(wl_rssi_t *)(gbuf->wldp_buf) ); // Get Signal Value
+}
+
+char*
+get_essid( int fd ) 
+{
+    char           *str;
+    int             rc;
+
+    str = calloc(256,sizeof(char));
+
+    if ( (rc = get_value( fd, gbuf, WL_ESSID )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_essid: rc = %d\n", rc);
+        return( str );
+    }
+
+    // Get ESSID Value
+    (void) strlcpy(str, ((wl_essid_t*)(gbuf->wldp_buf))->wl_essid_essid, 256);
+    return( str ); 
+}
+
+extern char *_link_ntoa(const unsigned char *, char *, int, int);
+
+char*
+get_bssid( int fd ) 
+{
+    char           *str;
+    int             rc;
+
+    str = calloc(256,sizeof(char));
+
+    if ( (rc = get_value( fd, gbuf, WL_BSSID )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_bssid: rc = %d\n", rc);
+        return( str );
+    }
+
+    // Get BSSID Value
+	_link_ntoa((const unsigned char*)gbuf->wldp_buf, str, 6, IFT_OTHER);
+
+    return( str ); 
+}
+
+const char*
+get_bss_mode( int fd ) 
+{
+    const char     *str;
+    int             rc;
+    wl_bss_type_t   bsstype;
+
+    str = "";
+
+    if ( (rc = get_value( fd, gbuf, WL_BSS_TYPE )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_bss_mode: rc = %d\n", rc);
+        return( str );
+    }
+
+    // Get BSS Type Value
+    bsstype = *(wl_bss_type_t *)(gbuf->wldp_buf);
+
+	switch (bsstype) {
+	case WL_BSS_BSS:
+		str = "bss";
+		break;
+	case WL_BSS_IBSS:
+		str = "ibss";
+		break;
+	case WL_BSS_ANY:
+		str = "any";
+		break;
+	default:
+		break;
+	}
+
+    return( str ); 
+}
+
+const char*
+get_encryption( int fd ) 
+{
+    char           *str = "none";
+    int             rc;
+	wl_encryption_t	encryption;
+
+    if ( (rc = get_value( fd, gbuf, WL_ENCRYPTION )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_encryption: rc = %d\n", rc);
+
+        return( str );
+    }
+
+	encryption = *(wl_encryption_t *)(gbuf->wldp_buf);
+
+	switch (encryption) {
+	case WL_ENC_WEP:
+		str = "wep";
+		break;
+	case WL_ENC_WPA:
+		str = "wpa";
+		break;
+	case WL_NOENCRYPTION:
+        /* fall-through */
+	default:
+		/* already default = none */
+		break;
+	}
+
+    return( str ); 
+}
+
+const char*
+get_auth_mode( int fd ) 
+{
+    char           *str = "open";
+    int             rc;
+	wl_authmode_t	authmode;
+
+    if ( (rc = get_value( fd, gbuf, WL_AUTH_MODE )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_authmode: rc = %d\n", rc);
+
+        return( str );
+    }
+
+	authmode = *(wl_authmode_t *)(gbuf->wldp_buf);
+
+	switch (authmode) {
+	case WL_SHAREDKEY:
+		str = "shared";
+		break;
+	case WL_OPENSYSTEM:
+        /* fall-through */
+	default:
+		/* already default = open */
+		break;
+	}
+
+    return( str ); 
+}
+
+
+const char*
+get_mode( int fd ) 
+{
+    char           *str = "";
+    int             rc;
+	wl_phy_conf_t  *phy_conf;
+
+    if ( (rc = get_value( fd, gbuf, WL_PHY_CONFIG )) != 0 ) {
+        if (debug) 
+            fprintf(stderr, "get_mode: rc = %d\n", rc);
+
+        return( str );
+    }
+
+    phy_conf = (wl_phy_conf_t *)(gbuf->wldp_buf);
+
+	switch (phy_conf->wl_phy_fhss_conf.wl_fhss_subtype) {
+	case WL_ERP:
+		str = "g";
+        break;
+	case WL_OFDM:
+		str = "a";
+        break;
+	case WL_DSSS:
+	case WL_FHSS:
+		str = "b";
+        break;
+	default:
+		break;
+	}
+
+	return (str);
+}
+
+int
+handle_dev( const char* dev ) 
+{
+    char         *devpath       = NULL;
+    int           fd            = -1;
+    int           iswifi        = FALSE;
+    int           isconnected   = FALSE;
+    char         *essid         = NULL;
+    char         *bssid         = NULL;
+    const char   *bss_mode      = NULL;
+    const char   *mode          = NULL;
+    const char   *auth_mode     = NULL;
+    const char   *encryption    = NULL;
+    int           signal        = 0;
+    const char   *dev_no_path   = NULL;
+
+    if ( dev == NULL ) {
+        return( 1 );
+    }
+
+    if ( (dev_no_path = strchr(dev, '/')) == NULL ) {
+        /* Prefix with /dev/net/ */
+        int buflen = strlen(DEV_PATH_PREFIX) + strlen(dev) + 2;
+
+        devpath = malloc( buflen );
+        (void)snprintf(devpath, buflen, "%s%s", DEV_PATH_PREFIX, dev );
+
+        dev_no_path = dev;  /* Pass back what was used as arg */
+    }
+    else {
+        devpath = strdup( dev );
+        dev_no_path++; /* Skip '/' */
+    }
+
+    if ( (fd = open( devpath, O_RDONLY )) < 0 ) {
+        if ( debug )
+            fprintf(stderr,"Unable to open dev %s\n", dev);
+        /* Output something so caller doesn't block waiting for response */
+        printf("%s;%d;%d;%s;%d;%s;%s;%s;%s\n", 
+               dev_no_path, 
+               iswifi?TRUE:FALSE, 
+               isconnected?TRUE:FALSE, 
+               essid?essid:"", 
+               signal,
+               mode?mode:"", 
+               bssid?bssid:"", 
+               encryption?encryption:"", 
+               auth_mode?auth_mode:""
+               );
+        fflush(stdout);
+        free(devpath);
+        return (1);
+    }
+    
+    iswifi = is_wifi(fd);
+    isconnected = is_connected(fd);
+     
+    if ( iswifi && isconnected ) {
+
+        essid = get_essid(fd);
+        bssid = get_bssid(fd);
+        bss_mode = get_bss_mode(fd);
+        mode = get_mode(fd);
+        auth_mode = get_auth_mode(fd);
+        encryption = get_encryption(fd);
+        signal = get_signal_strength(fd);
+
+    }
+
+    printf("%s;%d;%d;%s;%d;%s;%s;%s;%s;%s\n", 
+           dev_no_path, 
+           iswifi?TRUE:FALSE, 
+           isconnected?TRUE:FALSE, 
+           essid?essid:"", 
+           signal,
+           mode?mode:"", 
+           bssid?bssid:"", 
+           bss_mode?bss_mode:"", 
+           encryption?encryption:"", 
+           auth_mode?auth_mode:""
+           );
+
+    fflush(stdout);
+
+    close(fd);
+
+    free(devpath);
+
+    if ( essid != NULL ) {
+        free(essid);
+        free(bssid);
+    }
+
+    return(0);
+}
+
+int
+main( int argc, char* argv[] ) 
+{
+    char    stdin_buffer[MAXPATHLEN];
+
+    if ((gbuf = malloc(MAX_BUF_LEN)) == NULL) {
+        return (1);
+    }
+
+
+    setbuf(stdin, NULL );
+
+    while ( fgets( stdin_buffer, MAXPATHLEN, stdin ) != NULL ) {
+        char *eol = strrchr( stdin_buffer, '\n' );
+        if ( eol != NULL ) 
+            *eol = '\0';
+
+        handle_dev( stdin_buffer );
+    }
+
+    free(gbuf);
+
+    return(0);
+}
diff -up ./configure.in.clean ./configure.in
--- ./configure.in.clean	2009-10-20 08:28:14.709772269 +0100
+++ ./configure.in	2009-10-13 09:20:07.258434585 +0100
@@ -49,6 +49,11 @@ PKG_CHECK_MODULES(NETSTATUS,
 
 AC_CHECK_HEADERS(sys/sockio.h)
 
+dnl *** checks for socket, nsl and scf libraries ***
+AC_CHECK_FUNC(socket,,[AC_CHECK_LIB(socket,socket)])
+AC_CHECK_FUNC(gethostbyname,,[AC_CHECK_LIB(nsl,gethostbyname)])
+AC_CHECK_FUNC(smf_get_state,,[AC_CHECK_LIB(scf,smf_get_state)])
+
 # Blatantly stolen from configure.in in the sample code from
 # "UNIX Network Programming, Volume 1" by W. Richard Stevens
 AC_CACHE_CHECK(if sockaddr has sa_len member,
@@ -118,6 +123,16 @@ Makefile
 po/Makefile.in
 src/Makefile
 icons/Makefile
+icons/hicolor/Makefile
+icons/hicolor/24x24/Makefile
+icons/hicolor/24x24/status/Makefile
+icons/hicolor/24x24/emblems/Makefile
+icons/hicolor/scalable/status/Makefile
+icons/hicolor/scalable/Makefile
+icons/hicolor/scalable/emblems/Makefile
+icons/hicolor/32x32/status/Makefile
+icons/hicolor/32x32/emblems/Makefile
+icons/hicolor/32x32/Makefile
 help/Makefile
 help/ja/Makefile
 help/ko/Makefile

--- gnome-netstatus-2.28.0.orig/src/Makefile.am	2009-09-25 11:46:34.296413697 +0100
+++ gnome-netstatus-2.28.0/src/Makefile.am	2009-09-25 11:46:40.213683924 +0100
@@ -8,11 +8,14 @@
 	$(NETSTATUS_CFLAGS) \
 	$(NETSTATUS_DEBUG_CFLAGS) \
 	$(WARN_CFLAGS) \
-	-DNETSTATUS_ICONDIR=\""$(datadir)/icons/gnome-netstatus\"" \
+	-DNETSTATUS_DATA_DIR=\""$(pkgdatadir)\"" \
 	-DNETSTATUS_BUILDERDIR=\""$(builderdir)\"" \
 	-DGNOMELOCALEDIR=\""$(prefix)/$(DATADIRNAME)/locale"\"
 
-libexec_PROGRAMS = gnome-netstatus-applet
+libexec_PROGRAMS = gnome-netstatus-applet gnome-netstatus-wifi-info
+
+gnome_netstatus_wifi_info_SOURCES = \
+	wifi_info.c
 
 gnome_netstatus_applet_LDADD = $(NETSTATUS_LIBS) $(KSTAT_LIBS)
 
--- gnome-netstatus-2.28.0.orig/src/netstatus-sysdeps.c	2009-09-25 13:20:00.177042518 +0100
+++ gnome-netstatus-2.28.0/src/netstatus-sysdeps.c	2009-09-25 13:25:09.054558210 +0100
@@ -442,23 +442,178 @@
   return NULL;
 }
 
+typedef struct {
+  gboolean      started;
+  GPid          pid;
+  gint          standard_input;
+  gint          standard_output;
+  gint          standard_error;
+  FILE*         in;
+  FILE*         out; 
+  FILE*         err;
+} child_info_t;
+
+static child_info_t child_info = { FALSE, 0, -1, -1, -1, NULL, NULL, NULL };
+
+static void
+child_watch_func( GPid pid, gint status, gpointer data)
+ {
+    child_info_t* info = (child_info_t*)data;
+
+    g_return_if_fail( info != NULL );
+
+    fclose( info->in );
+    fclose( info->out );
+    fclose( info->err );
+
+    memset( info, 0, sizeof( child_info_t ) );
+
+    info->started = FALSE;
+}
+
 char *
-netstatus_sysdeps_read_iface_wireless_details (const char *iface,
-					       gboolean   *is_wireless,
-					       int        *signal_strength)
+read_wireless_info( const char *iface ) {
+  static  char         *child_argv[] = { 
+                                  "/usr/bin/pfexec",
+                                  "/usr/lib/gnome-netstatus-wifi-info",
+                                  NULL
+                               };
+
+  if ( iface == NULL ) {
+    return ( NULL );
+  }
+
+  if ( ! child_info.started ) {
+    child_info.started = g_spawn_async_with_pipes( NULL, child_argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, 
+                                                   NULL, &child_info.pid, &child_info.standard_input, 
+                                                   &child_info.standard_output, &child_info.standard_error, NULL);
+
+    if ( child_info.started ) {
+      g_child_watch_add(child_info.pid, child_watch_func, &child_info);
+      child_info.in = fdopen( child_info.standard_input, "w");
+      setbuf(child_info.in, NULL);
+      child_info.out = fdopen( child_info.standard_output, "r");
+      setbuf(child_info.out, NULL);
+      child_info.err = fdopen( child_info.standard_error, "r");
+      setbuf(child_info.err, NULL);
+    }
+  }
+
+  if ( child_info.started ) {
+    char buf[1024];
+    int  n;
+
+    fprintf( child_info.in, "%s\n", iface );
+
+    if ( fgets( buf, 1024, child_info.out ) == NULL ) {
+      return(NULL);
+    }
+
+    return( g_strdup( buf ) );
+  }
+
+  return (NULL);
+}
+
+wifi_info_t* 
+netstatus_wifi_info_new(   char       *essid,
+                           gboolean    connected,
+                           char       *bssid,
+                           char       *bss_mode,
+                           int         signal_strength,
+                           char       *mode,
+                           char       *security,
+                           char       *auth_mode )
 {
-  g_return_val_if_fail (iface != NULL, NULL);
-  g_return_val_if_fail (is_wireless != NULL, NULL);
-  g_return_val_if_fail (signal_strength != NULL, NULL);
-                                                                                
-  if (is_wireless)
-    *is_wireless = FALSE;
-  if (signal_strength)
-    *signal_strength = 0;
-                                                                                
-  return NULL;
+    wifi_info_t* wi = g_new0( wifi_info_t, 1 );
+
+    wi->essid = g_strdup(essid?essid:"");
+    wi->connected = connected;
+    wi->bssid = g_strdup(bssid?bssid:"");
+    wi->bss_mode = g_strdup(bss_mode?bss_mode:"");
+    wi->signal_strength = signal_strength;
+    wi->mode = g_strdup(mode?mode:"");
+    wi->security = g_strdup(security?security:"");
+    wi->auth_mode = g_strdup(auth_mode?auth_mode:"");
+   
+    return( wi );
+}
+
+void
+netstatus_wifi_info_free( wifi_info_t * wi )
+{
+    g_return_if_fail( wi != NULL );
+
+    if ( wi->essid )
+        g_free(wi->essid);
+    if ( wi->bssid )
+        g_free(wi->bssid);
+    if ( wi->bss_mode )
+        g_free(wi->bss_mode);
+    if ( wi->mode )
+        g_free(wi->mode);
+    if ( wi->security )
+        g_free(wi->security);
+    if ( wi->auth_mode )
+        g_free(wi->auth_mode);
+
+    g_free(wi);
 }
 
+wifi_info_t *
+netstatus_sysdeps_read_iface_wireless_details (const char *iface)
+{
+  gchar*        str = NULL;
+  wifi_info_t  *wi = NULL;
+  gboolean      is_wireless = FALSE;
+
+   g_return_val_if_fail (iface != NULL, NULL);
+
+  if ( (str = read_wireless_info( iface )) == NULL ) {
+    /* Not wireless, return NULL */
+    return NULL;
+  }
+  else {
+    gchar** fields = g_strsplit_set( g_strchomp(str), ";", 10 );
+
+    is_wireless = (fields[1] != NULL && fields[1][0] == '1')?TRUE:FALSE;
+
+    if ( is_wireless ) {
+      gboolean  connected = (fields[2] != NULL && fields[2][0] == '1')?TRUE:FALSE;
+      char     *essid = fields[3];
+      int       signal_strength = (fields[4] != NULL)?atoi(fields[4]):0;
+      char     *mode = fields[5];
+      char     *bssid = fields[6];
+      char     *bss_mode = fields[7];
+      char     *security = fields[8];
+      char     *auth_mode = fields[9];
+
+      /* Using the Linux code above, log() will provide a smoother
+       * transition between signal strengths than simple division */
+      /* *signal_strength = ((*signal_strength * 100) / 15 ); */
+      signal_strength = (int) rint ((log (signal_strength) / log (15)) * 100.0);
+      signal_strength = CLAMP( signal_strength, 0, 100);
+
+      wi = netstatus_wifi_info_new( essid,
+                                    connected,
+                                    bssid,
+                                    bss_mode,
+                                    signal_strength,
+                                    mode,
+                                    security,
+                                    auth_mode );
+
+    }
+
+    if ( fields != NULL ) 
+        g_strfreev(fields);
+
+    g_free( str );
+  }
+                                                                                  
+  return wi;
+ }
+
 #else /* defined(__FreeBSD__) */
 
 static inline void
--- gnome-netstatus-2.28.0/src/netstatus-icon.c.~1~	2014-06-12 12:03:04.404667614 +0400
+++ gnome-netstatus-2.28.0/src/netstatus-icon.c	2014-06-12 12:08:52.240710385 +0400
@@ -54,15 +54,21 @@
   GdkPixbuf      *icons [NETSTATUS_STATE_LAST];
   GdkPixbuf      *scaled_icons [NETSTATUS_STATE_LAST];
 
+  GdkPixbuf      *wireless_icons [NETSTATUS_STATE_LAST];
+  GdkPixbuf      *scaled_wireless_icons [NETSTATUS_STATE_LAST];
+
   GdkPixbuf      *signal_icons [NETSTATUS_SIGNAL_LAST];
   GdkPixbuf      *rotated_signal_icons [NETSTATUS_SIGNAL_LAST];
   GdkPixbuf      *scaled_signal_icons [NETSTATUS_SIGNAL_LAST];
 
+  GdkPixbuf     *rendered_wireless_pixbufs[NETSTATUS_STATE_LAST][NETSTATUS_SIGNAL_LAST];
+
   GtkOrientation  orientation;
   int             size;
 
+  gulong          query_tooltip_id;
+
   gulong          state_changed_id;
-  gulong          name_changed_id;
   gulong          wireless_changed_id;
   gulong          signal_changed_id;
 
@@ -115,27 +121,48 @@
 netstatus_icon_theme_changed (NetstatusIcon *icon,
 			      GtkIconTheme  *icon_theme)
 {
-  int i;
+  int i,j;
 
   for (i = 0; i < NETSTATUS_STATE_LAST; i++)
     {
-      g_object_unref (icon->priv->scaled_icons [i]);
-      icon->priv->scaled_icons [i] = NULL;
+      if ( icon->priv->scaled_icons [i] != NULL ) {
+          g_object_unref (icon->priv->scaled_icons [i]);
+          icon->priv->scaled_icons [i] = NULL;
+      }
 
       g_object_unref (icon->priv->icons [i]);
       icon->priv->icons [i] = NULL;
+
+      g_object_unref (icon->priv->wireless_icons [i]);
+      icon->priv->wireless_icons [i] = NULL;
+
+      if ( icon->priv->scaled_wireless_icons [i] != NULL ) {
+          g_object_unref(icon->priv->scaled_wireless_icons [i]);
+          icon->priv->scaled_wireless_icons [i] = NULL;
+      }
     }
   
   for (i = 0; i < NETSTATUS_SIGNAL_LAST; i++)
     {
-      g_object_unref (icon->priv->scaled_signal_icons [i]);
-      icon->priv->scaled_signal_icons [i] = NULL;
-
-      g_object_unref (icon->priv->signal_icons [i]);
-      icon->priv->signal_icons [i] = NULL;
+      if ( icon->priv->scaled_signal_icons [i] != NULL ) {
+          g_object_unref (icon->priv->scaled_signal_icons [i]);
+          icon->priv->scaled_signal_icons [i] = NULL;
+      }
+
+      if ( icon->priv->signal_icons [i] != NULL ) {
+          g_object_unref (icon->priv->signal_icons [i]);
+          icon->priv->signal_icons [i] = NULL;
+      }
+    }
+
+  for (i = 0; i < NETSTATUS_STATE_LAST; i++) {
+    for (j = 0; j < NETSTATUS_SIGNAL_LAST; j++) {
+     if ( icon->priv->rendered_wireless_pixbufs[i][j] != NULL ) {
+       g_object_unref(icon->priv->rendered_wireless_pixbufs[i][j]);
+     }
+     icon->priv->rendered_wireless_pixbufs[i][j] = NULL;
     }
-
-  netstatus_icon_init_pixbufs (icon);
+  }
 
   if (icon->priv->size)
     {
@@ -153,6 +180,10 @@
       screen = gtk_widget_get_screen (GTK_WIDGET (icon));
       icon->priv->icon_theme = gtk_icon_theme_get_for_screen (screen);
 
+      gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (),
+                                         NETSTATUS_DATA_DIR G_DIR_SEPARATOR_S "icons");
+
+
       g_signal_connect_object (icon->priv->icon_theme, "changed",
 			       G_CALLBACK (netstatus_icon_theme_changed),
 			       icon,
@@ -286,32 +317,32 @@
 {
   netstatus_icon_init_pixbuf (icon,
 			      &icon->priv->icons [NETSTATUS_STATE_DISCONNECTED],
-			      "gnome-netstatus-disconn");
+			      "network-offline");
   icon->priv->scaled_icons [NETSTATUS_STATE_DISCONNECTED] = NULL;
 
   netstatus_icon_init_pixbuf (icon,
 			      &icon->priv->icons [NETSTATUS_STATE_IDLE],
-			      "gnome-netstatus-idle");
+			      "network-idle");
   icon->priv->scaled_icons [NETSTATUS_STATE_IDLE] = NULL;
 
   netstatus_icon_init_pixbuf (icon,
 			      &icon->priv->icons [NETSTATUS_STATE_TX],
-			      "gnome-netstatus-tx");
+			      "network-transmit");
   icon->priv->scaled_icons [NETSTATUS_STATE_TX] = NULL;
 
   netstatus_icon_init_pixbuf (icon,
 			      &icon->priv->icons [NETSTATUS_STATE_RX],
-			      "gnome-netstatus-rx");
+			      "network-receive");
   icon->priv->scaled_icons [NETSTATUS_STATE_RX] = NULL;
 
   netstatus_icon_init_pixbuf (icon,
 			      &icon->priv->icons [NETSTATUS_STATE_TX_RX],
-			      "gnome-netstatus-txrx");
+			      "network-transmit-receive");
   icon->priv->scaled_icons [NETSTATUS_STATE_TX_RX] = NULL;
 
   netstatus_icon_init_pixbuf (icon,
 			      &icon->priv->icons [NETSTATUS_STATE_ERROR],
-			      "gnome-netstatus-error");
+			      "network-error");
   icon->priv->scaled_icons [NETSTATUS_STATE_ERROR] = NULL;
 
   netstatus_icon_init_pixbuf (icon,
@@ -338,6 +369,38 @@
   icon->priv->rotated_signal_icons [NETSTATUS_SIGNAL_75_100] = NULL;
   icon->priv->scaled_signal_icons  [NETSTATUS_SIGNAL_75_100] = NULL;
 
+  /* Load rx, tx, error, disconnect icons for wireless */
+  netstatus_icon_init_pixbuf (icon,
+			      &icon->priv->wireless_icons [NETSTATUS_STATE_TX],
+			      "gnome-netstatus-wireless-transmit");
+  icon->priv->scaled_wireless_icons [NETSTATUS_STATE_TX] = NULL;
+
+  netstatus_icon_init_pixbuf (icon,
+			      &icon->priv->wireless_icons [NETSTATUS_STATE_RX],
+			      "gnome-netstatus-wireless-receive");
+
+  icon->priv->scaled_wireless_icons [NETSTATUS_STATE_RX] = NULL;
+
+  netstatus_icon_init_pixbuf (icon,
+			      &icon->priv->wireless_icons [NETSTATUS_STATE_TX_RX],
+			      "gnome-netstatus-wireless-transmit-receive");
+  icon->priv->scaled_wireless_icons [NETSTATUS_STATE_TX_RX] = NULL;
+
+  netstatus_icon_init_pixbuf (icon,
+			      &icon->priv->wireless_icons [NETSTATUS_STATE_DISCONNECTED],
+			      "gnome-netstatus-wireless-offline");
+  icon->priv->scaled_wireless_icons [NETSTATUS_STATE_DISCONNECTED] = NULL;
+
+  netstatus_icon_init_pixbuf (icon,
+			      &icon->priv->wireless_icons [NETSTATUS_STATE_IDLE],
+			      "gnome-netstatus-wireless-idle");
+  icon->priv->scaled_wireless_icons [NETSTATUS_STATE_IDLE] = NULL;
+
+  netstatus_icon_init_pixbuf (icon,
+			      &icon->priv->wireless_icons [NETSTATUS_STATE_ERROR],
+			      "gnome-netstatus-wireless-error");
+  icon->priv->scaled_wireless_icons [NETSTATUS_STATE_ERROR] = NULL;
+
   netstatus_icon_rotate_signal_icons (icon, icon->priv->orientation);
 }
 
@@ -356,40 +419,129 @@
   if (gtk_image_get_pixbuf (GTK_IMAGE (icon->priv->image)) != pixbuf)
     gtk_image_set_from_pixbuf (GTK_IMAGE (icon->priv->image), pixbuf);
 
-  pixbuf = icon->priv->scaled_signal_icons [icon->priv->signal_strength];
-  if (!pixbuf)
-    pixbuf = icon->priv->rotated_signal_icons [icon->priv->signal_strength];
-  
-  if (gtk_image_get_pixbuf (GTK_IMAGE (icon->priv->signal_image)) != pixbuf)
-    gtk_image_set_from_pixbuf (GTK_IMAGE (icon->priv->signal_image), pixbuf);
+  if (netstatus_iface_get_is_wireless (icon->priv->iface)) {
+    /* Merge Signal + Status Pixmaps for wireless icon */
+    GdkPixbuf *wireless_state_pixbuf;
+    
+    if ( icon->priv->rendered_wireless_pixbufs[icon->priv->state][icon->priv->signal_strength] == NULL ) {
+      /* Render for first time */
+      GdkPixbuf *rendered_pixbuf; 
+      GdkPixbuf *state_pixbuf; 
+      GdkPixbuf *signal_pixbuf; 
+      gint       back_width;
+      gint       back_height;
+
+      state_pixbuf = icon->priv->scaled_wireless_icons [icon->priv->state];
+      if (!state_pixbuf)
+        state_pixbuf = icon->priv->wireless_icons [icon->priv->state];
+
+      signal_pixbuf = icon->priv->scaled_signal_icons [icon->priv->signal_strength];
+      if (!signal_pixbuf)
+        signal_pixbuf = icon->priv->rotated_signal_icons [icon->priv->signal_strength];
+
+      rendered_pixbuf = gdk_pixbuf_copy(signal_pixbuf);
+      back_width = gdk_pixbuf_get_width (rendered_pixbuf);
+      back_height = gdk_pixbuf_get_height (rendered_pixbuf);
+
+      gdk_pixbuf_composite (state_pixbuf,
+                      rendered_pixbuf,
+                      0, 0,
+                      back_width, back_height,
+                      0, 0,
+                      1.0, 1.0,
+                      GDK_INTERP_NEAREST,
+                      255 );
+
+      icon->priv->rendered_wireless_pixbufs[icon->priv->state][icon->priv->signal_strength] = rendered_pixbuf;
+    }
+
+    /* TODO - Do we handle rotation? 
+    pixbuf = icon->priv->scaled_signal_icons [icon->priv->signal_strength];
+    if (!pixbuf)
+      pixbuf = icon->priv->rotated_signal_icons [icon->priv->signal_strength];
+    */ 
+
+    pixbuf = icon->priv->rendered_wireless_pixbufs[icon->priv->state][icon->priv->signal_strength];
+    if (gtk_image_get_pixbuf (GTK_IMAGE (icon->priv->signal_image)) != pixbuf)
+      gtk_image_set_from_pixbuf (GTK_IMAGE (icon->priv->signal_image), pixbuf);
+  }
 }
 
-static void
-netstatus_icon_name_changed (NetstatusIface *iface,
-			     GParamSpec     *pspec,
-			     NetstatusIcon  *icon)
-{
-  const char *iface_name;
-  const char *tip;
-  char       *freeme = NULL;
-
-  iface_name = netstatus_iface_get_name (icon->priv->iface);
-  if (iface_name)
-    {
-      const char *state_string;
-
-      state_string = netstatus_get_state_string (icon->priv->state);
-      freeme = g_strdup_printf (_("Network Connection: %s\n%s"), iface_name, state_string);
-      tip = freeme;
-    }
-  else
-    {
-      tip = _("Network Connection");
-    }
-
-  gtk_widget_set_tooltip_text (GTK_WIDGET (icon), tip);
+static gboolean
+netstatus_icon_query_tooltip(   NetstatusIcon  *icon,
+                                gint            x,
+                                gint            y,
+                                gboolean        keyboard_mode,
+                                GtkTooltip     *tooltip,
+                                gpointer        user_data)     
+{
+  const char   *iface_name = NULL;
+  char         *ipaddr = NULL;
+  GString      *tooltip_markup = g_string_new("<tt>");
+  char         *cstr;
+
+  if ( !icon->priv->tooltips_enabled )
+      return( FALSE );
+
+  if (icon->priv->iface != NULL ) {
+    if ( netstatus_iface_get_is_wireless (icon->priv->iface)) {
+      const char *iface_essid;
+      const char *iface_bss_mode;
+      gint        signal_strength;
+
+      iface_essid = netstatus_iface_get_essid (icon->priv->iface);
+      iface_bss_mode = netstatus_iface_get_bss_mode (icon->priv->iface);
+      signal_strength = netstatus_iface_get_signal_strength (icon->priv->iface);
+
+      if ( iface_essid != NULL ) {
+        /* SUN_BRANDING */
+        g_string_append_printf(tooltip_markup, _("<b>%-20s</b>: %s"),
+                               /* SUN_BRANDING */
+                               _("Wireless Network"), iface_essid );
+        g_string_append(tooltip_markup, "\n");
+      }
+
+      /* SUN_BRANDING */
+      g_string_append_printf(tooltip_markup, _("<b>%-20s</b>: %d%%"),
+                             /* SUN_BRANDING */
+                             _("Signal Strength"), signal_strength );
+      g_string_append(tooltip_markup, "\n");
+
+      if ( iface_bss_mode != NULL ) {
+        /* SUN_BRANDING */
+        g_string_append_printf(tooltip_markup, _("<b>%-20s</b>: %s"),
+                               /* SUN_BRANDING */
+                               _("Operational Mode"), iface_bss_mode );
+        g_string_append(tooltip_markup, "\n");
+      }
+    }
+
+    iface_name = netstatus_iface_get_name (icon->priv->iface);
+    netstatus_iface_get_inet4_details (icon->priv->iface, &ipaddr, NULL, NULL, NULL );
+
+    if ( ipaddr != NULL ) {
+        /* SUN_BRANDING */
+        g_string_append_printf(tooltip_markup, _("<b>%-20s</b>: %s"),
+                               /* SUN_BRANDING */
+                               _("IP Address (v4)"), ipaddr );
+        g_string_append(tooltip_markup, "\n");
+    }
+
+  }
+  if ( iface_name != NULL ) {
+    g_string_append_printf(tooltip_markup, _("<b>%-20s</b>: %s"), _("Network Connection"), iface_name );
+  }
+  else {
+    g_string_append_printf(tooltip_markup, _("Network Connection")  );
+  }
+
+  g_string_append(tooltip_markup, "</tt>");
+  cstr = g_string_free(tooltip_markup, FALSE);
+  gtk_tooltip_set_markup( tooltip, cstr );
+  g_free(cstr);
 
-  g_free (freeme);
+  g_free(ipaddr);
+  return( TRUE );
 }
 
 static void
@@ -408,7 +560,6 @@
       icon->priv->state = state;
 
       netstatus_icon_update_image (icon);
-      netstatus_icon_name_changed (icon->priv->iface, NULL, icon);
     }
 }
 
@@ -417,10 +568,16 @@
 				    GParamSpec     *pspec,
 				    NetstatusIcon  *icon)
 {
-  if (netstatus_iface_get_is_wireless (iface) && icon->priv->show_signal)
+  netstatus_icon_update_image (icon);
+
+  if (netstatus_iface_get_is_wireless (iface) && icon->priv->show_signal) {
+    gtk_widget_hide (icon->priv->image);
     gtk_widget_show (icon->priv->signal_image);
-  else
+  }
+  else {
+    gtk_widget_show (icon->priv->image);
     gtk_widget_hide (icon->priv->signal_image);
+  }
 }
 
 static void
@@ -459,21 +616,23 @@
     gtk_widget_destroy (icon->priv->error_dialog);
   icon->priv->error_dialog = NULL;
 
+  if ( icon->priv->query_tooltip_id ) {
+      g_signal_handler_disconnect (icon,
+				   icon->priv->query_tooltip_id);
+  }
+  icon->priv->query_tooltip_id    = 0;
+
   if (icon->priv->state_changed_id)
     {
       g_assert (icon->priv->iface != NULL);
-      g_assert (icon->priv->name_changed_id != 0);
       g_signal_handler_disconnect (icon->priv->iface,
 				   icon->priv->state_changed_id);
       g_signal_handler_disconnect (icon->priv->iface,
-				   icon->priv->name_changed_id);
-      g_signal_handler_disconnect (icon->priv->iface,
 				   icon->priv->wireless_changed_id);
       g_signal_handler_disconnect (icon->priv->iface,
 				   icon->priv->signal_changed_id);
     }
   icon->priv->state_changed_id    = 0;
-  icon->priv->name_changed_id     = 0;
   icon->priv->wireless_changed_id = 0;
   icon->priv->signal_changed_id   = 0;
 
@@ -549,7 +708,7 @@
 netstatus_icon_scale_icons (NetstatusIcon  *icon,
 			    int             size)
 {
-  int i;
+  int i,j;
 
   g_return_if_fail (size > 0);
 
@@ -566,6 +725,16 @@
 						   TRUE);
     }
 
+  for (i = 0; i < NETSTATUS_STATE_LAST; i++)
+    {
+      if (icon->priv->scaled_wireless_icons [i])
+	g_object_unref (icon->priv->scaled_wireless_icons [i]);
+      icon->priv->scaled_wireless_icons [i] = scale_pixbuf (icon->priv->wireless_icons [i],
+						   icon->priv->orientation,
+						   size,
+						   TRUE);
+    }
+
   for (i = 0; i < NETSTATUS_SIGNAL_LAST; i++)
     {
       if (icon->priv->scaled_signal_icons [i])
@@ -573,8 +742,18 @@
       icon->priv->scaled_signal_icons [i] = scale_pixbuf (icon->priv->rotated_signal_icons [i],
 							  icon->priv->orientation,
 							  size,
-							  FALSE);
+							  TRUE);
     }
+ 
+   /* Invalidate rendered icons */
+  for (i = 0; i < NETSTATUS_STATE_LAST; i++) {
+    for (j = 0; j < NETSTATUS_SIGNAL_LAST; j++) {
+     if ( icon->priv->rendered_wireless_pixbufs[i][j] != NULL ) {
+       g_object_unref(icon->priv->rendered_wireless_pixbufs[i][j]);
+     }
+     icon->priv->rendered_wireless_pixbufs[i][j] = NULL;
+    }
+  }
 
   netstatus_icon_update_image (icon);
 }
@@ -872,12 +1051,15 @@
 
   icon->priv->image = gtk_image_new ();
   gtk_container_add (GTK_CONTAINER (icon), icon->priv->image);
-  gtk_widget_show (icon->priv->image);
+  gtk_widget_hide (icon->priv->image);
 
   icon->priv->signal_image = gtk_image_new ();
   gtk_container_add (GTK_CONTAINER (icon), icon->priv->signal_image);
   gtk_widget_hide (icon->priv->signal_image);
 
+  icon->priv->query_tooltip_id  = g_signal_connect(icon, "query-tooltip",
+                                                   G_CALLBACK (netstatus_icon_query_tooltip), NULL);
+  
   gtk_widget_add_events (GTK_WIDGET (icon),
 			 GDK_BUTTON_PRESS_MASK | GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
 }
@@ -981,12 +1163,9 @@
       if (icon->priv->state_changed_id)
 	{
 	  g_assert (icon->priv->iface != NULL);
-	  g_assert (icon->priv->name_changed_id != 0);
 	  g_signal_handler_disconnect (icon->priv->iface,
 				       icon->priv->state_changed_id);
 	  g_signal_handler_disconnect (icon->priv->iface,
-				       icon->priv->name_changed_id);
-	  g_signal_handler_disconnect (icon->priv->iface,
 				       icon->priv->wireless_changed_id);
 	  g_signal_handler_disconnect (icon->priv->iface,
 				       icon->priv->signal_changed_id);
@@ -1001,15 +1180,12 @@
 
       icon->priv->state_changed_id     = g_signal_connect (icon->priv->iface, "notify::state",
 							   G_CALLBACK (netstatus_icon_state_changed), icon);
-      icon->priv->name_changed_id      = g_signal_connect (icon->priv->iface, "notify::name",
-							   G_CALLBACK (netstatus_icon_name_changed), icon);
       icon->priv->wireless_changed_id  = g_signal_connect (icon->priv->iface, "notify::wireless",
 							   G_CALLBACK (netstatus_icon_is_wireless_changed), icon);
       icon->priv->signal_changed_id    = g_signal_connect (icon->priv->iface, "notify::signal-strength",
 							   G_CALLBACK (netstatus_icon_signal_changed), icon);
 
       netstatus_icon_state_changed       (icon->priv->iface, NULL, icon);
-      netstatus_icon_name_changed        (icon->priv->iface, NULL, icon);
       netstatus_icon_is_wireless_changed (icon->priv->iface, NULL, icon);
       netstatus_icon_signal_changed      (icon->priv->iface, NULL, icon);
 
