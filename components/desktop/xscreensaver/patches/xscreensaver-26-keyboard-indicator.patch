--- driver/lock-Gtk.c.~5~	2017-04-27 00:59:35.294130605 +0300
+++ driver/lock-Gtk.c	2017-04-27 01:03:50.651526448 +0300
@@ -61,6 +61,7 @@
 #include <ctype.h>
 #include <X11/Xos.h>
 #include <X11/Xlib.h>
+#include <X11/XKBlib.h>
 #include <X11/Xatom.h>
 #include <X11/Xutil.h>
 #include <X11/Xmu/WinUtil.h>
@@ -90,6 +91,7 @@
   GtkWidget *button;
   GtkWidget *msg_label;
   GtkWidget *pam_message_label;
+  GtkWidget *layout_label;
 } PasswdDialog;
 
 /*Global info */
@@ -100,6 +102,48 @@
 
 #define FD_TO_PARENT  9
 
+static int xkb_opcode;
+static int xkb_event_base;
+static int xkb_error_base;
+
+static gchar*
+getGroup()
+{
+  XkbStateRec state;
+  Display *dpy;
+  XkbDescRec desc[1];
+  char *names[XkbNumKbdGroups];
+  int i;
+  gchar *s1 = NULL;
+
+  dpy = gdk_x11_get_default_xdisplay();
+  memset(desc, 0, sizeof(desc));
+  desc->device_spec = XkbUseCoreKbd;
+  if (XkbGetControls(dpy, XkbGroupsWrapMask, desc) == Success) {
+    if (XkbGetNames(dpy, XkbGroupNamesMask, desc) == Success) {
+      if (XkbGetState(dpy, XkbUseCoreKbd, &state) == Success) {
+        XGetAtomNames(dpy, desc->names->groups, desc->ctrls->num_groups, names);
+        for(i=0; i< desc->ctrls->num_groups; i++){
+          fprintf(stderr, names[i]);
+        }
+        if (names[state.group]) {
+          if(strlen(names[state.group]) > 2) {
+             names[state.group][2]='\0';
+          }
+
+          s1 = g_ascii_strdown (names[state.group], -1);
+          fprintf(stderr, "Got group %d %s\n", state.group, s1);
+          fprintf(stderr, "My uid is %d euid is %d\n", getuid(), geteuid());
+          fflush(stderr);
+        }
+      }
+      XkbFreeNames(desc, XkbGroupNamesMask, True);
+    }
+    XkbFreeControls(desc, XkbGroupsWrapMask, True);
+  }
+  return s1;
+}
+
 /* Send a command to the xscreensaver parent daemon
    Arguments:
     - msg - type of message - "input", "raise_wid", etc.
@@ -179,7 +223,7 @@
   GtkWidget *entry;
   AtkObject *atk_entry;
   GtkWidget *title_label, *msg_label, *prompt_label,
-    *user_label, *date_label, *pam_msg_label;
+    *user_label, *date_label, *pam_msg_label, *layout_label;
   AtkObject *atk_title_label, *atk_prompt_label;
   GtkWidget *button;
   GtkWidget *image;
@@ -368,6 +412,27 @@
 
   gtk_box_pack_start (GTK_BOX (vbox2), pam_msg_label, FALSE, FALSE, 0);
 
+  /* current layout */
+  {
+    gchar *s1;
+   
+    s1 = getGroup();
+    if (s1) {
+      s = g_markup_printf_escaped ("<small>Layout: %s</small>", s1);
+      g_free(s1);
+    } else {
+      s = g_strdup("");
+    }
+    layout_label = g_object_new (GTK_TYPE_LABEL,
+                                 "use-markup", TRUE,
+                                 "label", s,
+                                 NULL);
+    pwd->layout_label = layout_label;
+    gtk_box_pack_start (GTK_BOX (vbox2), layout_label,
+                                    FALSE, FALSE, 0);
+    g_free(s);
+  }
+
   /* date string */
   tm = localtime (&now);
   memset (buf, 0, sizeof (buf));
@@ -464,6 +529,47 @@
 }
 
 static GdkFilterReturn
+xkb_filter_func (GdkXEvent *xevent, GdkEvent *gevent, gpointer data)
+{
+  PasswdDialog *pwd = data;
+  XEvent *event = xevent;
+
+  if (event->xany.type == xkb_event_base + XkbEventCode) {
+     fprintf(stderr, "Got xkb event\n");
+     fflush(stderr);
+     /* Xkb event. */
+      XkbEvent * xkbev = (XkbEvent *) event;
+      if (xkbev->any.xkb_type == XkbStateNotify)
+      {
+          gchar *group;
+
+          fprintf(stderr, "Got XkbStateNotify event\n");
+          fflush(stderr);
+          group = getGroup();
+          if (group) {
+            char * s; 
+     
+            s = g_markup_printf_escaped ("<small>Layout: %s</small>", group);
+            gtk_label_set_markup (GTK_LABEL (pwd->layout_label), s);
+
+            fprintf(stderr, "Got group %s\n", group);
+            fflush (stderr);
+
+            g_free (s); 
+
+            g_free(group);
+          } else {
+            fprintf(stderr, "Got empty group\n");
+            fflush(stderr);
+          }    
+      }    
+  }
+
+  return GDK_FILTER_CONTINUE;
+}
+
+
+static GdkFilterReturn
 dialog_filter_func (GdkXEvent *xevent, GdkEvent *gevent, gpointer data)
 {
   PasswdDialog *pwd = data;
@@ -698,6 +804,7 @@
     }
 
   gtk_init (&argc, &argv);
+  getGroup();
 
   /* Intern the atoms that xscreensaver_command() needs.
    */
@@ -716,6 +823,17 @@
     request_atoms (dpy, atom_lists);
   }
 
+  /* Init XKB extension */
+  { 
+    Display *dpy = gdk_x11_get_default_xdisplay();
+
+    if(XkbQueryExtension(dpy, &xkb_opcode, &xkb_event_base, &xkb_error_base,
+                      NULL, NULL)!=True){
+         fprintf(stderr, "Couldn't find XKB extension\n");
+         fflush(stderr);
+    }
+  }
+
   /* bugid 6346056(P1):
      ATOK pallet sometimes appears in screensave/lock-screen mode
   */
@@ -773,7 +891,8 @@
 
   gdk_display_sync (gtk_widget_get_display (pwd->dialog));
 
-  gdk_window_add_filter (GET_WINDOW (pwd->dialog), dialog_filter_func, pwd);
+  gdk_window_add_filter (NULL, xkb_filter_func, pwd);
+  gdk_add_client_message_filter (gdk_x11_xatom_to_atom (XA_UNLOCK_RATIO), dialog_filter_func, pwd);
   write_windowid ("dialog_win", GDK_WINDOW_XID (GET_WINDOW (pwd->dialog)));
 
   if (server_list && server_list->_length)
