#
# This patch was developed in house.
# This is Solaris-specific: not suitable for upstream.
#
--- openssl-1.0.1g/crypto/sparcv9cap.c.~1~	Thu May  1 13:07:00 2014
+++ openssl-1.0.1g/crypto/sparcv9cap.c	Thu May  1 13:11:33 2014
@@ -2,10 +2,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <setjmp.h>
-#include <signal.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <openssl/bn.h>
+#include <sys/auxv.h>
 
 #include "sparc_arch.h"
 
@@ -56,13 +56,8 @@
 	}
 
 unsigned long	_sparcv9_rdtick(void);
-void		_sparcv9_vis1_probe(void);
 unsigned long	_sparcv9_vis1_instrument(void);
-void		_sparcv9_vis2_probe(void);
-void		_sparcv9_fmadd_probe(void);
 unsigned long	_sparcv9_rdcfr(void);
-void		_sparcv9_vis3_probe(void);
-unsigned long	_sparcv9_random(void);
 #ifndef _BOOT
 size_t 	_sparcv9_vis1_instrument_bus(unsigned int *,size_t);
 size_t		_sparcv9_vis1_instrument_bus2(unsigned int *,size_t,size_t);
@@ -227,15 +222,11 @@
 
 #else
 
-static sigjmp_buf common_jmp;
-static void common_handler(int sig) { siglongjmp(common_jmp,sig); }
-
 void OPENSSL_cpuid_setup(void)
 	{
 	char *e;
-	struct sigaction	common_act,ill_oact,bus_oact;
-	sigset_t		all_masked,oset;
 	static int trigger=0;
+	uint_t ui = 0;
 
 	if (trigger) return;
 	trigger=1;
@@ -248,86 +239,42 @@
 		return;
 		}
 
+	(void) getisax(&ui, 1);
+
 	/* Initial value, fits UltraSPARC-I&II... */
-	OPENSSL_sparcv9cap_P[0] = SPARCV9_PREFER_FPU|SPARCV9_TICK_PRIVILEGED;
+	OPENSSL_sparcv9cap_P[0] = SPARCV9_BLK;
 
-	sigfillset(&all_masked);
-	sigdelset(&all_masked,SIGILL);
-	sigdelset(&all_masked,SIGTRAP);
-#ifdef SIGEMT
-	sigdelset(&all_masked,SIGEMT);
-#endif
-	sigdelset(&all_masked,SIGFPE);
-	sigdelset(&all_masked,SIGBUS);
-	sigdelset(&all_masked,SIGSEGV);
-	sigprocmask(SIG_SETMASK,&all_masked,&oset);
-
-	memset(&common_act,0,sizeof(common_act));
-	common_act.sa_handler = common_handler;
-	common_act.sa_mask    = all_masked;
-
-	sigaction(SIGILL,&common_act,&ill_oact);
-	sigaction(SIGBUS,&common_act,&bus_oact);/* T1 fails 16-bit ldda [on Linux] */
-
-	if (sigsetjmp(common_jmp,1) == 0)
+	if (ui & AV_SPARC_VIS)
 		{
-		_sparcv9_rdtick();
-		OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;
-		}
-
-	if (sigsetjmp(common_jmp,1) == 0)
-		{
-		_sparcv9_vis1_probe();
-		OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1|SPARCV9_BLK;
 		/* detect UltraSPARC-Tx, see sparccpud.S for details... */
-		if (_sparcv9_vis1_instrument() >= 12)
-			OPENSSL_sparcv9cap_P[0] &= ~(SPARCV9_VIS1|SPARCV9_PREFER_FPU);
-		else
+		if (_sparcv9_vis1_instrument() < 7)
+			OPENSSL_sparcv9cap_P[0] |= SPARCV9_TICK_PRIVILEGED;
+		if (_sparcv9_vis1_instrument() < 12)
 			{
-			_sparcv9_vis2_probe();
-			OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;
+			OPENSSL_sparcv9cap_P[0] |= (SPARCV9_VIS1|SPARCV9_PREFER_FPU);
+			if (ui & AV_SPARC_VIS2)
+				OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;
 			}
 		}
 
-	if (sigsetjmp(common_jmp,1) == 0)
-		{
-		_sparcv9_fmadd_probe();
+	if (ui & AV_SPARC_FMAF)
 		OPENSSL_sparcv9cap_P[0] |= SPARCV9_FMADD;
-		}
 
 	/*
 	 * VIS3 flag is tested independently from VIS1, unlike VIS2 that is,
 	 * because VIS3 defines even integer instructions.
 	 */
-	if (sigsetjmp(common_jmp,1) == 0)
-		{
-		_sparcv9_vis3_probe();
+	if (ui & AV_SPARC_VIS3)
 		OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS3;
-		}
 
-	if (sigsetjmp(common_jmp,1) == 0)
-		{
-		(void)_sparcv9_random();
-		OPENSSL_sparcv9cap_P[0] |= SPARCV9_RANDOM;
-		}
+#define AV_T4_MECHS	(AV_SPARC_AES | AV_SPARC_DES | AV_SPARC_KASUMI | \
+			AV_SPARC_CAMELLIA | AV_SPARC_MD5 | AV_SPARC_SHA1 | \
+			AV_SPARC_SHA256 | AV_SPARC_SHA512 | AV_SPARC_MPMUL | AV_SPARC_CRC32C)
 
-	/*
-	 * In wait for better solution _sparcv9_rdcfr is masked by
-	 * VIS3 flag, because it goes to uninterruptable endless
-	 * loop on UltraSPARC II running Solaris. Things might be
-	 * different on Linux...
-	 */
 	if ((OPENSSL_sparcv9cap_P[0]&SPARCV9_VIS3) &&
-	    sigsetjmp(common_jmp,1) == 0)
-		{
-		OPENSSL_sparcv9cap_P[1] = (unsigned int)_sparcv9_rdcfr();
-		}
+	    (ui & AV_T4_MECHS))
+		OPENSSL_sparcv9cap_P[1] = (unsigned int)_sparcv9_rdcfr(); 
 
-	sigaction(SIGBUS,&bus_oact,NULL);
-	sigaction(SIGILL,&ill_oact,NULL);
-
-	sigprocmask(SIG_SETMASK,&oset,NULL);
-
 	if (sizeof(size_t)==8)
 		OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;
 #ifdef __linux
--- openssl-1.0.1g/crypto/sparccpuid.S.~1~	Fri Apr 25 16:16:07 2014
+++ openssl-1.0.1g/crypto/sparccpuid.S	Fri Apr 25 16:17:40 2014
@@ -236,16 +236,6 @@
 .type	_sparcv9_rdtick,#function
 .size	_sparcv9_rdtick,.-_sparcv9_rdtick
 
-.global	_sparcv9_vis1_probe
-.align	8
-_sparcv9_vis1_probe:
-	.word	0x81b00d80	!fxor	%f0,%f0,%f0
-	add	%sp,BIAS+2,%o1
-	retl
-	.word	0xc19a5a40	!ldda	[%o1]ASI_FP16_P,%f0
-.type	_sparcv9_vis1_probe,#function
-.size	_sparcv9_vis1_probe,.-_sparcv9_vis1_probe
-
 ! Probe and instrument VIS1 instruction. Output is number of cycles it
 ! takes to execute rdtick and pair of VIS1 instructions. US-Tx VIS unit
 ! is slow (documented to be 6 cycles on T2) and the core is in-order
@@ -307,24 +297,6 @@
 .type	_sparcv9_vis1_instrument,#function
 .size	_sparcv9_vis1_instrument,.-_sparcv9_vis1_instrument
 
-.global	_sparcv9_vis2_probe
-.align	8
-_sparcv9_vis2_probe:
-	retl
-	.word	0x81b00980	!bshuffle	%f0,%f0,%f0
-.type	_sparcv9_vis2_probe,#function
-.size	_sparcv9_vis2_probe,.-_sparcv9_vis2_probe
-
-.global	_sparcv9_fmadd_probe
-.align	8
-_sparcv9_fmadd_probe:
-	.word	0x81b00d80	!fxor	%f0,%f0,%f0
-	.word	0x85b08d82	!fxor	%f2,%f2,%f2
-	retl
-	.word	0x81b80440	!fmaddd	%f0,%f0,%f2,%f0
-.type	_sparcv9_fmadd_probe,#function
-.size	_sparcv9_fmadd_probe,.-_sparcv9_fmadd_probe
-
 .global	_sparcv9_rdcfr
 .align	8
 _sparcv9_rdcfr:
@@ -333,22 +305,6 @@
 .type	_sparcv9_rdcfr,#function
 .size	_sparcv9_rdcfr,.-_sparcv9_rdcfr
 
-.global	_sparcv9_vis3_probe
-.align	8
-_sparcv9_vis3_probe:
-	retl
-	.word	0x81b022a0	!xmulx	%g0,%g0,%g0
-.type	_sparcv9_vis3_probe,#function
-.size	_sparcv9_vis3_probe,.-_sparcv9_vis3_probe
-
-.global	_sparcv9_random
-.align	8
-_sparcv9_random:
-	retl
-	.word	0x91b002a0	!random	%o0
-.type	_sparcv9_random,#function
-.size	_sparcv9_random,.-_sparcv9_vis3_probe
-
 .global	OPENSSL_cleanse
 .align	32
 OPENSSL_cleanse:
