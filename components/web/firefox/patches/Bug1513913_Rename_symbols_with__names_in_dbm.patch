
# HG changeset patch
# User Martin Thomson <martin.thomson@gmail.com>
# Date 1545610470 -39600
# Node ID b10754b2cb747dbc970d71e393868e96b1f5c1e9
# Parent  b216206312d29af13a8112b6568e108913fc1493
Bug 1513913 - Rename symbols with __ names in dbm, r=jcj

These have been shown to collice.  This also renames two types: `struct __db`
and `__default_hash`.  A global, `__sigtemp` is also renamed (though removed
might be better, I don't want to do too much here).

I considered also renaming __DBINTERFACE_PRIVATE, but that is part of the
external interface.

diff --git a/security/nss/lib/security/nss/dbm/include/extern.h b/lib/dbm/include/extern.h
--- a/security/nss/lib/security/nss/dbm/include/extern.h
+++ b/security/nss/lib/dbm/include/extern.h
@@ -26,38 +26,38 @@
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
  *  @(#)extern.h    8.4 (Berkeley) 6/16/94
  */
 
-BUFHEAD *__add_ovflpage(HTAB *, BUFHEAD *);
-int __addel(HTAB *, BUFHEAD *, const DBT *, const DBT *);
-int __big_delete(HTAB *, BUFHEAD *);
-int __big_insert(HTAB *, BUFHEAD *, const DBT *, const DBT *);
-int __big_keydata(HTAB *, BUFHEAD *, DBT *, DBT *, int);
-int __big_return(HTAB *, BUFHEAD *, int, DBT *, int);
-int __big_split(HTAB *, BUFHEAD *, BUFHEAD *, BUFHEAD *,
-                uint32, uint32, SPLIT_RETURN *);
-int __buf_free(HTAB *, int, int);
-void __buf_init(HTAB *, int);
-uint32 __call_hash(HTAB *, char *, size_t);
-int __delpair(HTAB *, BUFHEAD *, int);
-int __expand_table(HTAB *);
-int __find_bigpair(HTAB *, BUFHEAD *, int, char *, int);
-uint16 __find_last_page(HTAB *, BUFHEAD **);
-void __free_ovflpage(HTAB *, BUFHEAD *);
-BUFHEAD *__get_buf(HTAB *, uint32, BUFHEAD *, int);
-int __get_page(HTAB *, char *, uint32, int, int, int);
-int __ibitmap(HTAB *, int, int, int);
-uint32 __log2(uint32);
-int __put_page(HTAB *, char *, uint32, int, int);
-void __reclaim_buf(HTAB *, BUFHEAD *);
-int __split_page(HTAB *, uint32, uint32);
+BUFHEAD *dbm_add_ovflpage(HTAB *, BUFHEAD *);
+int dbm_addel(HTAB *, BUFHEAD *, const DBT *, const DBT *);
+int dbm_big_delete(HTAB *, BUFHEAD *);
+int dbm_big_insert(HTAB *, BUFHEAD *, const DBT *, const DBT *);
+int dbm_big_keydata(HTAB *, BUFHEAD *, DBT *, DBT *, int);
+int dbm_big_return(HTAB *, BUFHEAD *, int, DBT *, int);
+int dbm_big_split(HTAB *, BUFHEAD *, BUFHEAD *, BUFHEAD *,
+                  uint32, uint32, SPLIT_RETURN *);
+int dbm_buf_free(HTAB *, int, int);
+void dbm_buf_init(HTAB *, int);
+uint32 dbm_call_hash(HTAB *, char *, size_t);
+int dbm_delpair(HTAB *, BUFHEAD *, int);
+int dbm_expand_table(HTAB *);
+int dbm_find_bigpair(HTAB *, BUFHEAD *, int, char *, int);
+uint16 dbm_find_last_page(HTAB *, BUFHEAD **);
+void dbm_free_ovflpage(HTAB *, BUFHEAD *);
+BUFHEAD *dbm_get_buf(HTAB *, uint32, BUFHEAD *, int);
+int dbm_get_page(HTAB *, char *, uint32, int, int, int);
+int dbm_ibitmap(HTAB *, int, int, int);
+uint32 dbm_log2(uint32);
+int dbm_put_page(HTAB *, char *, uint32, int, int);
+void dbm_reclaim_buf(HTAB *, BUFHEAD *);
+int dbm_split_page(HTAB *, uint32, uint32);
 
 /* Default hash routine. */
-extern uint32 (*__default_hash)(const void *, size_t);
+extern uint32 (*dbm_default_hash)(const void *, size_t);
 
 #ifdef HASH_STATISTICS
 extern int hash_accesses, hash_collisions, hash_expansions, hash_overflows;
 #endif
diff --git a/security/nss/lib/security/nss/dbm/include/hash.h b/lib/dbm/include/hash.h
--- a/security/nss/lib/security/nss/dbm/include/hash.h
+++ b/security/nss/lib/dbm/include/hash.h
@@ -185,17 +185,17 @@ typedef struct htab { /* Memory resident
 
 #define SPLITSHIFT 11
 #define SPLITMASK 0x7FF
 #define SPLITNUM(N) (((uint32)(N)) >> SPLITSHIFT)
 #define OPAGENUM(N) ((N)&SPLITMASK)
 #define OADDR_OF(S, O) ((uint32)((uint32)(S) << SPLITSHIFT) + (O))
 
 #define BUCKET_TO_PAGE(B) \
-    (B) + hashp->HDRPAGES + ((B) ? hashp->SPARES[__log2((uint32)((B) + 1)) - 1] : 0)
+    (B) + hashp->HDRPAGES + ((B) ? hashp->SPARES[dbm_log2((uint32)((B) + 1)) - 1] : 0)
 #define OADDR_TO_PAGE(B) \
     BUCKET_TO_PAGE((1 << SPLITNUM((B))) - 1) + OPAGENUM((B));
 
 /*
  * page.h contains a detailed description of the page format.
  *
  * Normally, keys and data are accessed from offset tables in the top of
  * each page which point to the beginning of the key and data.  There are
@@ -309,33 +309,33 @@ typedef struct htab { /* Memory resident
 #define HDRPAGES hdr.hdrpages
 #define SPARES hdr.spares
 #define BITMAPS hdr.bitmaps
 #define VERSION hdr.version
 #define MAGIC hdr.magic
 #define NEXT_FREE hdr.next_free
 #define H_CHARKEY hdr.h_charkey
 
-extern uint32 (*__default_hash)(const void *, size_t);
-void __buf_init(HTAB *hashp, int32 nbytes);
-int __big_delete(HTAB *hashp, BUFHEAD *bufp);
-BUFHEAD *__get_buf(HTAB *hashp, uint32 addr, BUFHEAD *prev_bp, int newpage);
-uint32 __call_hash(HTAB *hashp, char *k, size_t len);
+extern uint32 (*dbm_default_hash)(const void *, size_t);
+void dbm_buf_init(HTAB *hashp, int32 nbytes);
+int dbm_big_delete(HTAB *hashp, BUFHEAD *bufp);
+BUFHEAD *dbm_get_buf(HTAB *hashp, uint32 addr, BUFHEAD *prev_bp, int newpage);
+uint32 dbm_call_hash(HTAB *hashp, char *k, size_t len);
 #include "page.h"
-extern int __big_split(HTAB *hashp, BUFHEAD *op, BUFHEAD *np,
-                       BUFHEAD *big_keyp, uint32 addr, uint32 obucket, SPLIT_RETURN *ret);
-void __free_ovflpage(HTAB *hashp, BUFHEAD *obufp);
-BUFHEAD *__add_ovflpage(HTAB *hashp, BUFHEAD *bufp);
-int __big_insert(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val);
-int __expand_table(HTAB *hashp);
-uint32 __log2(uint32 num);
-void __reclaim_buf(HTAB *hashp, BUFHEAD *bp);
-int __get_page(HTAB *hashp, char *p, uint32 bucket, int is_bucket, int is_disk, int is_bitmap);
-int __put_page(HTAB *hashp, char *p, uint32 bucket, int is_bucket, int is_bitmap);
-int __ibitmap(HTAB *hashp, int pnum, int nbits, int ndx);
-int __buf_free(HTAB *hashp, int do_free, int to_disk);
-int __find_bigpair(HTAB *hashp, BUFHEAD *bufp, int ndx, char *key, int size);
-uint16 __find_last_page(HTAB *hashp, BUFHEAD **bpp);
-int __addel(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val);
-int __big_return(HTAB *hashp, BUFHEAD *bufp, int ndx, DBT *val, int set_current);
-int __delpair(HTAB *hashp, BUFHEAD *bufp, int ndx);
-int __big_keydata(HTAB *hashp, BUFHEAD *bufp, DBT *key, DBT *val, int set);
-int __split_page(HTAB *hashp, uint32 obucket, uint32 nbucket);
+extern int dbm_big_split(HTAB *hashp, BUFHEAD *op, BUFHEAD *np,
+                         BUFHEAD *big_keyp, uint32 addr, uint32 obucket, SPLIT_RETURN *ret);
+void dbm_free_ovflpage(HTAB *hashp, BUFHEAD *obufp);
+BUFHEAD *dbm_add_ovflpage(HTAB *hashp, BUFHEAD *bufp);
+int dbm_big_insert(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val);
+int dbm_expand_table(HTAB *hashp);
+uint32 dbm_log2(uint32 num);
+void dbm_reclaim_buf(HTAB *hashp, BUFHEAD *bp);
+int dbm_get_page(HTAB *hashp, char *p, uint32 bucket, int is_bucket, int is_disk, int is_bitmap);
+int dbm_put_page(HTAB *hashp, char *p, uint32 bucket, int is_bucket, int is_bitmap);
+int dbm_ibitmap(HTAB *hashp, int pnum, int nbits, int ndx);
+int dbm_buf_free(HTAB *hashp, int do_free, int to_disk);
+int dbm_find_bigpair(HTAB *hashp, BUFHEAD *bufp, int ndx, char *key, int size);
+uint16 dbm_find_last_page(HTAB *hashp, BUFHEAD **bpp);
+int dbm_addel(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val);
+int dbm_big_return(HTAB *hashp, BUFHEAD *bufp, int ndx, DBT *val, int set_current);
+int dbm_delpair(HTAB *hashp, BUFHEAD *bufp, int ndx);
+int dbm_big_keydata(HTAB *hashp, BUFHEAD *bufp, DBT *key, DBT *val, int set);
+int dbm_split_page(HTAB *hashp, uint32 obucket, uint32 nbucket);
diff --git a/security/nss/lib/security/nss/dbm/include/mcom_db.h b/lib/dbm/include/mcom_db.h
--- a/security/nss/lib/security/nss/dbm/include/mcom_db.h
+++ b/security/nss/lib/dbm/include/mcom_db.h
@@ -282,26 +282,26 @@ typedef enum { LockOutDatabase,
 #define DB_TXN 0x80000000   /* Do transactions. */
 #else
 #define DB_LOCK 0x2000  /* Do locking. */
 #define DB_SHMEM 0x4000 /* Use shared memory. */
 #define DB_TXN 0x8000   /* Do transactions. */
 #endif
 
 /* Access method description structure. */
-typedef struct __db {
+typedef struct dbm_db {
     DBTYPE type; /* Underlying db type. */
-    int (*close)(struct __db *);
-    int (*del)(const struct __db *, const DBT *, uint);
-    int (*get)(const struct __db *, const DBT *, DBT *, uint);
-    int (*put)(const struct __db *, DBT *, const DBT *, uint);
-    int (*seq)(const struct __db *, DBT *, DBT *, uint);
-    int (*sync)(const struct __db *, uint);
+    int (*close)(struct dbm_db *);
+    int (*del)(const struct dbm_db *, const DBT *, uint);
+    int (*get)(const struct dbm_db *, const DBT *, DBT *, uint);
+    int (*put)(const struct dbm_db *, DBT *, const DBT *, uint);
+    int (*seq)(const struct dbm_db *, DBT *, DBT *, uint);
+    int (*sync)(const struct dbm_db *, uint);
     void *internal; /* Access method private. */
-    int (*fd)(const struct __db *);
+    int (*fd)(const struct dbm_db *);
 } DB;
 
 #define BTREEMAGIC 0x053162
 #define BTREEVERSION 3
 
 /* Structure used to pass parameters to the btree routines. */
 typedef struct {
 #define R_DUP 0x01 /* duplicate keys */
@@ -407,17 +407,17 @@ extern DB *
 dbopen(const char *, int, int, DBTYPE, const void *);
 
 /* set or unset a global lock flag to disable the
  * opening of any DBM file
  */
 void dbSetOrClearDBLock(DBLockFlagEnum type);
 
 #ifdef __DBINTERFACE_PRIVATE
-DB *__bt_open(const char *, int, int, const BTREEINFO *, int);
-DB *__hash_open(const char *, int, int, const HASHINFO *, int);
-DB *__rec_open(const char *, int, int, const RECNOINFO *, int);
-void __dbpanic(DB *dbp);
+DB *dbm_bt_open(const char *, int, int, const BTREEINFO *, int);
+DB *dbm_hash_open(const char *, int, int, const HASHINFO *, int);
+DB *dbm_rec_open(const char *, int, int, const RECNOINFO *, int);
+void dbm_dbpanic(DB *dbp);
 #endif
 
 PR_END_EXTERN_C
 
 #endif /* !_DB_H_ */
diff --git a/security/nss/lib/security/nss/dbm/include/ncompat.h b/lib/dbm/include/ncompat.h
--- a/security/nss/lib/security/nss/dbm/include/ncompat.h
+++ b/security/nss/lib/dbm/include/ncompat.h
@@ -84,23 +84,23 @@ typedef unsigned int  sigset_t;
 #define sigaddset(set, signo) (*(set) |= sigmask(signo), 0)
 #define sigdelset(set, signo) (*(set) &= ~sigmask(signo), 0)
 #define sigismember(set, signo) ((*(set)&sigmask(signo)) != 0)
 
 #define SIG_BLOCK 1
 #define SIG_UNBLOCK 2
 #define SIG_SETMASK 3
 
-static int __sigtemp; /* For the use of sigprocmask */
+static int dbm_sigtemp; /* For the use of sigprocmask */
 
 /* Repeated test of oset != NULL is to avoid "*0". */
 #define sigprocmask(how, set, oset)                                                                                                                            \
-    ((__sigtemp =                                                                                                                                              \
+    ((dbm_sigtemp =                                                                                                                                            \
           (((how) == SIG_BLOCK) ? sigblock(0) | *(set) : (((how) == SIG_UNBLOCK) ? sigblock(0) & ~(*(set)) : ((how) == SIG_SETMASK ? *(set) : sigblock(0))))), \
-     ((oset) ? (*(oset ? oset : set) = sigsetmask(__sigtemp)) : sigsetmask(__sigtemp)), 0)
+     ((oset) ? (*(oset ? oset : set) = sigsetmask(dbm_sigtemp)) : sigsetmask(dbm_sigtemp)), 0)
 #endif
 
 /*
  * If your system doesn't have an include file with the appropriate
  * byte order set, make sure you specify the correct one.
  */
 #ifndef BYTE_ORDER
 #define LITTLE_ENDIAN 1234    /* LSB first: i386, vax */
diff --git a/security/nss/lib/security/nss/dbm/src/db.c b/lib/dbm/src/db.c
--- a/security/nss/lib/security/nss/dbm/src/db.c
+++ b/security/nss/lib/dbm/src/db.c
@@ -87,48 +87,48 @@ dbopen(const char *fname, int flags, int
      O_RDWR | O_TRUNC)
 #endif
 
     if ((flags & ~(USE_OPEN_FLAGS | DB_FLAGS)) == 0)
         switch (type) {
 /* we don't need btree and recno right now */
 #if 0
             case DB_BTREE:
-                return (__bt_open(fname, flags & USE_OPEN_FLAGS,
+                return (dbm_bt_open(fname, flags & USE_OPEN_FLAGS,
                     mode, openinfo, flags & DB_FLAGS));
             case DB_RECNO:
-                return (__rec_open(fname, flags & USE_OPEN_FLAGS,
+                return (dbm_rec_open(fname, flags & USE_OPEN_FLAGS,
                     mode, openinfo, flags & DB_FLAGS));
 #endif
 
             case DB_HASH:
-                return (__hash_open(fname, flags & USE_OPEN_FLAGS,
-                                    mode, (const HASHINFO *)openinfo, flags & DB_FLAGS));
+                return (dbm_hash_open(fname, flags & USE_OPEN_FLAGS,
+                                      mode, (const HASHINFO *)openinfo, flags & DB_FLAGS));
             default:
                 break;
         }
     errno = EINVAL;
     return (NULL);
 }
 
 static int
-__dberr()
+dbm_dberr()
 {
     return (RET_ERROR);
 }
 
 /*
  * __DBPANIC -- Stop.
  *
  * Parameters:
  *  dbp:    pointer to the DB structure.
  */
 void
-__dbpanic(DB *dbp)
+dbm_dbpanic(DB *dbp)
 {
     /* The only thing that can succeed is a close. */
-    dbp->del = (int (*)(const struct __db *, const DBT *, uint))__dberr;
-    dbp->fd = (int (*)(const struct __db *))__dberr;
-    dbp->get = (int (*)(const struct __db *, const DBT *, DBT *, uint))__dberr;
-    dbp->put = (int (*)(const struct __db *, DBT *, const DBT *, uint))__dberr;
-    dbp->seq = (int (*)(const struct __db *, DBT *, DBT *, uint))__dberr;
-    dbp->sync = (int (*)(const struct __db *, uint))__dberr;
+    dbp->del = (int (*)(const struct dbm_db *, const DBT *, uint))dbm_dberr;
+    dbp->fd = (int (*)(const struct dbm_db *))dbm_dberr;
+    dbp->get = (int (*)(const struct dbm_db *, const DBT *, DBT *, uint))dbm_dberr;
+    dbp->put = (int (*)(const struct dbm_db *, DBT *, const DBT *, uint))dbm_dberr;
+    dbp->seq = (int (*)(const struct dbm_db *, DBT *, DBT *, uint))dbm_dberr;
+    dbp->sync = (int (*)(const struct dbm_db *, uint))dbm_dberr;
 }
diff --git a/security/nss/lib/security/nss/dbm/src/h_bigkey.c b/lib/dbm/src/h_bigkey.c
--- a/security/nss/lib/security/nss/dbm/src/h_bigkey.c
+++ b/security/nss/lib/dbm/src/h_bigkey.c
@@ -80,17 +80,17 @@ static int collect_data(HTAB *, BUFHEAD 
  *
  * You need to do an insert and the key/data pair is too big
  *
  * Returns:
  * 0 ==> OK
  *-1 ==> ERROR
  */
 extern int
-__big_insert(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val)
+dbm_big_insert(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val)
 {
     register uint16 *p;
     uint key_size, n, val_size;
     uint16 space, move_bytes, off;
     char *cp, *key_data, *val_data;
 
     cp = bufp->page; /* Character pointer of p. */
     p = (uint16 *)cp;
@@ -109,17 +109,17 @@ extern int
         key_size -= move_bytes;
         key_data += move_bytes;
         n = p[0];
         p[++n] = off;
         p[0] = ++n;
         FREESPACE(p) = off - PAGE_META(n);
         OFFSET(p) = off;
         p[n] = PARTIAL_KEY;
-        bufp = __add_ovflpage(hashp, bufp);
+        bufp = dbm_add_ovflpage(hashp, bufp);
         if (!bufp)
             return (-1);
         n = p[0];
         if (!key_size) {
             if (FREESPACE(p)) {
                 move_bytes = PR_MIN(FREESPACE(p), val_size);
                 off = OFFSET(p) - move_bytes;
                 p[n] = off;
@@ -153,17 +153,17 @@ extern int
         val_data += move_bytes;
         n = p[0];
         p[++n] = off;
         p[0] = ++n;
         FREESPACE(p) = off - PAGE_META(n);
         OFFSET(p) = off;
         if (val_size) {
             p[n] = FULL_KEY;
-            bufp = __add_ovflpage(hashp, bufp);
+            bufp = dbm_add_ovflpage(hashp, bufp);
             if (!bufp)
                 return (-1);
             cp = bufp->page;
             p = (uint16 *)cp;
         } else
             p[n] = FULL_KEY_DATA;
         bufp->flags |= BUF_MOD;
     }
@@ -177,17 +177,17 @@ extern int
  * free bufp because the page pointing to it is lost and we can't get rid
  * of its pointer.
  *
  * Returns:
  * 0 => OK
  *-1 => ERROR
  */
 extern int
-__big_delete(HTAB *hashp, BUFHEAD *bufp)
+dbm_big_delete(HTAB *hashp, BUFHEAD *bufp)
 {
     register BUFHEAD *last_bfp, *rbufp;
     uint16 *bp, pageno;
     int key_done, n;
 
     rbufp = bufp;
     last_bfp = NULL;
     bp = (uint16 *)bufp->page;
@@ -202,19 +202,19 @@ extern int
          * If there is freespace left on a FULL_KEY_DATA page, then
          * the data is short and fits entirely on this page, and this
          * is the last page.
          */
         if (bp[2] == FULL_KEY_DATA && FREESPACE(bp))
             break;
         pageno = bp[bp[0] - 1];
         rbufp->flags |= BUF_MOD;
-        rbufp = __get_buf(hashp, pageno, rbufp, 0);
+        rbufp = dbm_get_buf(hashp, pageno, rbufp, 0);
         if (last_bfp)
-            __free_ovflpage(hashp, last_bfp);
+            dbm_free_ovflpage(hashp, last_bfp);
         last_bfp = rbufp;
         if (!rbufp)
             return (-1); /* Error. */
         bp = (uint16 *)rbufp->page;
     }
 
     /*
      * If we get here then rbufp points to the last page of the big
@@ -239,32 +239,32 @@ extern int
         bufp->ovfl = NULL;
     n -= 2;
     bp[0] = n;
     FREESPACE(bp) = hashp->BSIZE - PAGE_META(n);
     OFFSET(bp) = hashp->BSIZE - 1;
 
     bufp->flags |= BUF_MOD;
     if (rbufp)
-        __free_ovflpage(hashp, rbufp);
+        dbm_free_ovflpage(hashp, rbufp);
     if (last_bfp != rbufp)
-        __free_ovflpage(hashp, last_bfp);
+        dbm_free_ovflpage(hashp, last_bfp);
 
     hashp->NKEYS--;
     return (0);
 }
 /*
  * Returns:
  *  0 = key not found
  * -1 = get next overflow page
  * -2 means key not found and this is big key/data
  * -3 error
  */
 extern int
-__find_bigpair(HTAB *hashp, BUFHEAD *bufp, int ndx, char *key, int size)
+dbm_find_bigpair(HTAB *hashp, BUFHEAD *bufp, int ndx, char *key, int size)
 {
     register uint16 *bp;
     register char *p;
     int ksize;
     uint16 bytes;
     char *kkey;
 
     bp = (uint16 *)bufp->page;
@@ -274,17 +274,17 @@ extern int
 
     for (bytes = hashp->BSIZE - bp[ndx];
          bytes <= size && bp[ndx + 1] == PARTIAL_KEY;
          bytes = hashp->BSIZE - bp[ndx]) {
         if (memcmp(p + bp[ndx], kkey, bytes))
             return (-2);
         kkey += bytes;
         ksize -= bytes;
-        bufp = __get_buf(hashp, bp[ndx + 2], bufp, 0);
+        bufp = dbm_get_buf(hashp, bp[ndx + 2], bufp, 0);
         if (!bufp)
             return (-3);
         p = bufp->page;
         bp = (uint16 *)p;
         ndx = 1;
     }
 
     if (bytes != ksize || memcmp(p + bp[ndx], kkey, bytes)) {
@@ -301,17 +301,17 @@ extern int
  * find the end of the big pair
  *
  * This will set bpp to the buffer header of the last page of the big pair.
  * It will return the pageno of the overflow page following the last page
  * of the pair; 0 if there isn't any (i.e. big pair is the last key in the
  * bucket)
  */
 extern uint16
-__find_last_page(HTAB *hashp, BUFHEAD **bpp)
+dbm_find_last_page(HTAB *hashp, BUFHEAD **bpp)
 {
     BUFHEAD *bufp;
     uint16 *bp, pageno;
     uint n;
 
     bufp = *bpp;
     bp = (uint16 *)bufp->page;
     for (;;) {
@@ -327,17 +327,17 @@ extern uint16
             break;
 
         /* LJM bound the size of n to reasonable limits
          */
         if (n > hashp->BSIZE / sizeof(uint16))
             return (0);
 
         pageno = bp[n - 1];
-        bufp = __get_buf(hashp, pageno, bufp, 0);
+        bufp = dbm_get_buf(hashp, pageno, bufp, 0);
         if (!bufp)
             return (0); /* Need to indicate an error! */
         bp = (uint16 *)bufp->page;
     }
 
     *bpp = bufp;
     if (bp[0] > 2)
         return (bp[3]);
@@ -345,39 +345,39 @@ extern uint16
         return (0);
 }
 
 /*
  * Return the data for the key/data pair that begins on this page at this
  * index (index should always be 1).
  */
 extern int
-__big_return(
+dbm_big_return(
     HTAB *hashp,
     BUFHEAD *bufp,
     int ndx,
     DBT *val,
     int set_current)
 {
     BUFHEAD *save_p;
     uint16 *bp, len, off, save_addr;
     char *tp;
     int save_flags;
 
     bp = (uint16 *)bufp->page;
     while (bp[ndx + 1] == PARTIAL_KEY) {
-        bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+        bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
         if (!bufp)
             return (-1);
         bp = (uint16 *)bufp->page;
         ndx = 1;
     }
 
     if (bp[ndx + 1] == FULL_KEY) {
-        bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+        bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
         if (!bufp)
             return (-1);
         bp = (uint16 *)bufp->page;
         save_p = bufp;
         save_addr = save_p->addr;
         off = bp[1];
         len = 0;
     } else if (!FREESPACE(bp)) {
@@ -387,35 +387,35 @@ extern int
              * incomplete data, so we require that if the data
              * is complete, there is at least 1 byte of free
              * space left.
              */
         off = bp[bp[0]];
         len = bp[1] - off;
         save_p = bufp;
         save_addr = bufp->addr;
-        bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+        bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
         if (!bufp)
             return (-1);
         bp = (uint16 *)bufp->page;
     } else {
         /* The data is all on one page. */
         tp = (char *)bp;
         off = bp[bp[0]];
         val->data = (uint8 *)tp + off;
         val->size = bp[1] - off;
         if (set_current) {
             if (bp[0] == 2) { /* No more buckets in
                              * chain */
                 hashp->cpage = NULL;
                 hashp->cbucket++;
                 hashp->cndx = 1;
             } else {
-                hashp->cpage = __get_buf(hashp,
-                                         bp[bp[0] - 1], bufp, 0);
+                hashp->cpage = dbm_get_buf(hashp,
+                                           bp[bp[0] - 1], bufp, 0);
                 if (!hashp->cpage)
                     return (-1);
                 hashp->cndx = 1;
                 if (!((uint16 *)
                           hashp->cpage->page)[0]) {
                     hashp->cbucket++;
                     hashp->cpage = NULL;
                 }
@@ -465,17 +465,17 @@ collect_data(
      * pin it to make sure it doesn't leave the buffer pool.
      * This has the effect of growing the buffer pool if necessary.
      */
     save_bufp = bufp;
     save_flags = save_bufp->flags;
     save_bufp->flags |= BUF_PIN;
 
     /* read the length of the buffer */
-    for (totlen = len; bufp; bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0)) {
+    for (totlen = len; bufp; bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0)) {
         bp = (uint16 *)bufp->page;
         mylen = hashp->BSIZE - bp[1];
 
         /* if mylen ever goes negative it means that the
          * page is screwed up.
          */
         if (mylen < 0) {
             save_bufp->flags = save_flags;
@@ -497,17 +497,17 @@ collect_data(
         free(hashp->tmp_buf);
     if ((hashp->tmp_buf = (char *)malloc((size_t)totlen)) == NULL) {
         save_bufp->flags = save_flags;
         return (-1);
     }
 
     /* copy the buffers back into temp buf */
     for (bufp = save_bufp; bufp;
-         bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0)) {
+         bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0)) {
         bp = (uint16 *)bufp->page;
         mylen = hashp->BSIZE - bp[1];
         memmove(&hashp->tmp_buf[len], (bufp->page) + bp[1], (size_t)mylen);
         len += mylen;
         if (bp[2] == FULL_KEY_DATA) {
             break;
         }
     }
@@ -517,33 +517,33 @@ collect_data(
 
     /* update the database cursor */
     if (set) {
         hashp->cndx = 1;
         if (bp[0] == 2) { /* No more buckets in chain */
             hashp->cpage = NULL;
             hashp->cbucket++;
         } else {
-            hashp->cpage = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+            hashp->cpage = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
             if (!hashp->cpage)
                 return (-1);
             else if (!((uint16 *)hashp->cpage->page)[0]) {
                 hashp->cbucket++;
                 hashp->cpage = NULL;
             }
         }
     }
     return (totlen);
 }
 
 /*
  * Fill in the key and data for this big pair.
  */
 extern int
-__big_keydata(
+dbm_big_keydata(
     HTAB *hashp,
     BUFHEAD *bufp,
     DBT *key, DBT *val,
     int set)
 {
     key->size = collect_key(hashp, bufp, 0, val, set);
     if (key->size == (size_t)-1)
         return (-1);
@@ -574,20 +574,20 @@ collect_key(
 
     save_addr = bufp->addr;
     totlen = len + mylen;
     if (bp[2] == FULL_KEY || bp[2] == FULL_KEY_DATA) { /* End of Key. */
         if (hashp->tmp_key != NULL)
             free(hashp->tmp_key);
         if ((hashp->tmp_key = (char *)malloc((size_t)totlen)) == NULL)
             return (-1);
-        if (__big_return(hashp, bufp, 1, val, set))
+        if (dbm_big_return(hashp, bufp, 1, val, set))
             return (-1);
     } else {
-        xbp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+        xbp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
         if (!xbp || ((totlen =
                           collect_key(hashp, xbp, totlen, val, set)) < 1))
             return (-1);
     }
     if (bufp->addr != save_addr) {
         errno = EINVAL; /* MIS -- OUT OF BUFFERS */
         return (-1);
     }
@@ -596,17 +596,17 @@ collect_key(
 }
 
 /*
  * Returns:
  *  0 => OK
  * -1 => error
  */
 extern int
-__big_split(
+dbm_big_split(
     HTAB *hashp,
     BUFHEAD *op, /* Pointer to where to put keys that go in old bucket */
     BUFHEAD *np, /* Pointer to new bucket page */
                  /* Pointer to first page containing the big key/data */
     BUFHEAD *big_keyp,
     uint32 addr,    /* Address of big_keyp */
     uint32 obucket, /* Old Bucket */
     SPLIT_RETURN *ret)
@@ -616,23 +616,23 @@ extern int
     BUFHEAD *bp;
     DBT key, val;
     uint32 change;
     uint16 free_space, n, off;
 
     bp = big_keyp;
 
     /* Now figure out where the big key/data goes */
-    if (__big_keydata(hashp, big_keyp, &key, &val, 0))
+    if (dbm_big_keydata(hashp, big_keyp, &key, &val, 0))
         return (-1);
-    change = (__call_hash(hashp, (char *)key.data, key.size) != obucket);
+    change = (dbm_call_hash(hashp, (char *)key.data, key.size) != obucket);
 
-    if ((ret->next_addr = __find_last_page(hashp, &big_keyp))) {
+    if ((ret->next_addr = dbm_find_last_page(hashp, &big_keyp))) {
         if (!(ret->nextp =
-                  __get_buf(hashp, ret->next_addr, big_keyp, 0)))
+                  dbm_get_buf(hashp, ret->next_addr, big_keyp, 0)))
             return (-1);
         ;
     } else
         ret->nextp = NULL;
 
 /* Now make one of np/op point to the big key/data pair */
 #ifdef DEBUG
     assert(np->ovfl == NULL);
@@ -687,17 +687,17 @@ extern int
          * next overflow page is added.
          */
         n = tp[4];
         free_space = FREESPACE(tp);
         off = OFFSET(tp);
         tp[0] -= 2;
         FREESPACE(tp) = free_space + OVFLSIZE;
         OFFSET(tp) = off;
-        tmpp = __add_ovflpage(hashp, big_keyp);
+        tmpp = dbm_add_ovflpage(hashp, big_keyp);
         if (!tmpp)
             return (-1);
         tp[4] = n;
     } else
         tmpp = big_keyp;
 
     if (change)
         ret->newp = tmpp;
diff --git a/security/nss/lib/security/nss/dbm/src/h_func.c b/lib/dbm/src/h_func.c
--- a/security/nss/lib/security/nss/dbm/src/h_func.c
+++ b/security/nss/lib/dbm/src/h_func.c
@@ -47,17 +47,17 @@ static char sccsid[] = "@(#)hash_func.c 
 #if 0
 static uint32 hash1(const void *, size_t);
 static uint32 hash2(const void *, size_t);
 static uint32 hash3(const void *, size_t);
 #endif
 static uint32 hash4(const void *, size_t);
 
 /* Global default hash function */
-uint32 (*__default_hash)(const void *, size_t) = hash4;
+uint32 (*dbm_default_hash)(const void *, size_t) = hash4;
 
 /*
  * HASH FUNCTIONS
  *
  * Assume that we've already split the bucket to which this key hashes,
  * calculate that bucket, and check that in fact we did already split it.
  *
  * This came from ejb's hsearch.
diff --git a/security/nss/lib/security/nss/dbm/src/h_log2.c b/lib/dbm/src/h_log2.c
--- a/security/nss/lib/security/nss/dbm/src/h_log2.c
+++ b/security/nss/lib/dbm/src/h_log2.c
@@ -38,17 +38,17 @@ static char sccsid[] = "@(#)hash_log2.c 
 
 #include <stdio.h>
 #ifndef macintosh
 #include <sys/types.h>
 #endif
 #include "mcom_db.h"
 
 uint32
-__log2(uint32 num)
+dbm_log2(uint32 num)
 {
     register uint32 i, limit;
 
     limit = 1;
     for (i = 0; limit < num; limit = limit << 1, i++) {
     }
     return (i);
 }
diff --git a/security/nss/lib/security/nss/dbm/src/h_page.c b/lib/dbm/src/h_page.c
--- a/security/nss/lib/security/nss/dbm/src/h_page.c
+++ b/security/nss/lib/dbm/src/h_page.c
@@ -199,27 +199,27 @@ putpair(char *p, const DBT *key, DBT *va
 }
 
 /*
  * Returns:
  *   0 OK
  *  -1 error
  */
 extern int
-__delpair(HTAB *hashp, BUFHEAD *bufp, int ndx)
+dbm_delpair(HTAB *hashp, BUFHEAD *bufp, int ndx)
 {
     register uint16 *bp, newoff;
     register int n;
     uint16 pairlen;
 
     bp = (uint16 *)bufp->page;
     n = bp[0];
 
     if (bp[ndx + 1] < REAL_KEY)
-        return (__big_delete(hashp, bufp));
+        return (dbm_big_delete(hashp, bufp));
     if (ndx != 1)
         newoff = bp[ndx - 1];
     else
         newoff = hashp->BSIZE;
     pairlen = newoff - bp[ndx + 1];
 
     if (ndx != (n - 1)) {
         /* Hard Case -- need to shuffle keys */
@@ -272,35 +272,35 @@ extern int
     return (0);
 }
 /*
  * Returns:
  *   0 ==> OK
  *  -1 ==> Error
  */
 extern int
-__split_page(HTAB *hashp, uint32 obucket, uint32 nbucket)
+dbm_split_page(HTAB *hashp, uint32 obucket, uint32 nbucket)
 {
     register BUFHEAD *new_bufp, *old_bufp;
     register uint16 *ino;
     register uint16 *tmp_uint16_array;
     register char *np;
     DBT key, val;
     uint16 n, ndx;
     int retval;
     uint16 copyto, diff, moved;
     size_t off;
     char *op;
 
     copyto = (uint16)hashp->BSIZE;
     off = (uint16)hashp->BSIZE;
-    old_bufp = __get_buf(hashp, obucket, NULL, 0);
+    old_bufp = dbm_get_buf(hashp, obucket, NULL, 0);
     if (old_bufp == NULL)
         return (-1);
-    new_bufp = __get_buf(hashp, nbucket, NULL, 0);
+    new_bufp = dbm_get_buf(hashp, nbucket, NULL, 0);
     if (new_bufp == NULL)
         return (-1);
 
     old_bufp->flags |= (BUF_MOD | BUF_PIN);
     new_bufp->flags |= (BUF_MOD | BUF_PIN);
 
     ino = (uint16 *)(op = old_bufp->page);
     np = new_bufp->page;
@@ -326,17 +326,17 @@ extern int
 
         key.size = off - ino[n];
 
 #ifdef DEBUG
         /* make sure the size is positive */
         assert(((int)key.size) > -1);
 #endif
 
-        if (__call_hash(hashp, (char *)key.data, key.size) == obucket) {
+        if (dbm_call_hash(hashp, (char *)key.data, key.size) == obucket) {
             /* Don't switch page */
             diff = copyto - off;
             if (diff) {
                 copyto = ino[n + 1] + diff;
                 memmove(op + copyto, op + ino[n + 1],
                         off - ino[n + 1]);
                 ino[ndx] = copyto + ino[n] - ino[n + 1];
                 ino[ndx + 1] = copyto;
@@ -438,18 +438,18 @@ ugly_split(HTAB *hashp, uint32 obucket, 
          * :LJM
          */
         loop_detection++;
 
         if (loop_detection > MAX_UGLY_SPLIT_LOOPS)
             return DATABASE_CORRUPTED_ERROR;
 
         if (ino[2] < REAL_KEY && ino[2] != OVFLPAGE) {
-            if ((status = __big_split(hashp, old_bufp,
-                                      new_bufp, bufp, bufp->addr, obucket, &ret)))
+            if ((status = dbm_big_split(hashp, old_bufp,
+                                        new_bufp, bufp, bufp->addr, obucket, &ret)))
                 return (status);
             old_bufp = ret.oldp;
             if (!old_bufp)
                 return (-1);
             op = (uint16 *)old_bufp->page;
             new_bufp = ret.newp;
             if (!new_bufp)
                 return (-1);
@@ -472,27 +472,27 @@ ugly_split(HTAB *hashp, uint32 obucket, 
             ino[0] -= (moved + 2);
             if (scopyto < sizeof(uint16) * (ino[0] + 3)) {
                 return DATABASE_CORRUPTED_ERROR;
             }
             FREESPACE(ino) =
                 scopyto - sizeof(uint16) * (ino[0] + 3);
             OFFSET(ino) = scopyto;
 
-            bufp = __get_buf(hashp, ov_addr, bufp, 0);
+            bufp = dbm_get_buf(hashp, ov_addr, bufp, 0);
             if (!bufp)
                 return (-1);
 
             ino = (uint16 *)bufp->page;
             n = 1;
             scopyto = hashp->BSIZE;
             moved = 0;
 
             if (last_bfp)
-                __free_ovflpage(hashp, last_bfp);
+                dbm_free_ovflpage(hashp, last_bfp);
             last_bfp = bufp;
         }
         /* Move regular sized pairs of there are any */
         off = hashp->BSIZE;
         for (n = 1; (n < ino[0]) && (ino[n + 1] >= REAL_KEY); n += 2) {
             cino = (char *)ino;
             key.data = (uint8 *)cino + ino[n];
             if (off < ino[n]) {
@@ -501,73 +501,73 @@ ugly_split(HTAB *hashp, uint32 obucket, 
             key.size = off - ino[n];
             val.data = (uint8 *)cino + ino[n + 1];
             if (ino[n] < ino[n + 1]) {
                 return DATABASE_CORRUPTED_ERROR;
             }
             val.size = ino[n] - ino[n + 1];
             off = ino[n + 1];
 
-            if (__call_hash(hashp, (char *)key.data, key.size) == obucket) {
+            if (dbm_call_hash(hashp, (char *)key.data, key.size) == obucket) {
                 /* Keep on old page */
                 if (PAIRFITS(op, (&key), (&val)))
                     putpair((char *)op, &key, &val);
                 else {
                     old_bufp =
-                        __add_ovflpage(hashp, old_bufp);
+                        dbm_add_ovflpage(hashp, old_bufp);
                     if (!old_bufp)
                         return (-1);
                     op = (uint16 *)old_bufp->page;
                     putpair((char *)op, &key, &val);
                 }
                 old_bufp->flags |= BUF_MOD;
             } else {
                 /* Move to new page */
                 if (PAIRFITS(np, (&key), (&val)))
                     putpair((char *)np, &key, &val);
                 else {
                     new_bufp =
-                        __add_ovflpage(hashp, new_bufp);
+                        dbm_add_ovflpage(hashp, new_bufp);
                     if (!new_bufp)
                         return (-1);
                     np = (uint16 *)new_bufp->page;
                     putpair((char *)np, &key, &val);
                 }
                 new_bufp->flags |= BUF_MOD;
             }
         }
     }
     if (last_bfp)
-        __free_ovflpage(hashp, last_bfp);
+        dbm_free_ovflpage(hashp, last_bfp);
     return (0);
 }
 
 /*
  * Add the given pair to the page
  *
  * Returns:
  *  0 ==> OK
  *  1 ==> failure
  */
 extern int
-__addel(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val)
+dbm_addel(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val)
 {
     register uint16 *bp, *sop;
     int do_expand;
 
     bp = (uint16 *)bufp->page;
     do_expand = 0;
     while (bp[0] && (bp[2] < REAL_KEY || bp[bp[0]] < REAL_KEY))
         /* Exception case */
         if (bp[2] == FULL_KEY_DATA && bp[0] == 2)
             /* This is the last page of a big key/data pair
                and we need to add another page */
             break;
         else if (bp[2] < REAL_KEY && bp[bp[0]] != OVFLPAGE) {
-            bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+            bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
             if (!bufp) {
 #ifdef DEBUG
                 assert(0);
 #endif
                 return (-1);
             }
             bp = (uint16 *)bufp->page;
         } else
@@ -580,68 +580,68 @@ extern int
                  * left out on accident.
                  * if this isn't incremented nkeys will not
                  * be the actual number of keys in the db.
                  */
                 hashp->NKEYS++;
                 return (0);
             }
         } else {
-            bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
+            bufp = dbm_get_buf(hashp, bp[bp[0] - 1], bufp, 0);
             if (!bufp) {
 #ifdef DEBUG
                 assert(0);
 #endif
                 return (-1);
             }
             bp = (uint16 *)bufp->page;
         }
 
     if (PAIRFITS(bp, key, val))
         putpair(bufp->page, key, (DBT *)val);
     else {
         do_expand = 1;
-        bufp = __add_ovflpage(hashp, bufp);
+        bufp = dbm_add_ovflpage(hashp, bufp);
         if (!bufp) {
 #ifdef DEBUG
             assert(0);
 #endif
             return (-1);
         }
         sop = (uint16 *)bufp->page;
 
         if (PAIRFITS(sop, key, val))
             putpair((char *)sop, key, (DBT *)val);
-        else if (__big_insert(hashp, bufp, key, val)) {
+        else if (dbm_big_insert(hashp, bufp, key, val)) {
 #ifdef DEBUG
             assert(0);
 #endif
             return (-1);
         }
     }
     bufp->flags |= BUF_MOD;
     /*
      * If the average number of keys per bucket exceeds the fill factor,
      * expand the table.
      */
     hashp->NKEYS++;
     if (do_expand ||
         (hashp->NKEYS / (hashp->MAX_BUCKET + 1) > hashp->FFACTOR))
-        return (__expand_table(hashp));
+        return (dbm_expand_table(hashp));
     return (0);
 }
 
 /*
  *
  * Returns:
  *  pointer on success
  *  NULL on error
  */
 extern BUFHEAD *
-__add_ovflpage(HTAB *hashp, BUFHEAD *bufp)
+dbm_add_ovflpage(HTAB *hashp, BUFHEAD *bufp)
 {
     register uint16 *sp;
     uint16 ndx, ovfl_num;
 #ifdef DEBUG1
     int tmp1, tmp2;
 #endif
     sp = (uint16 *)bufp->page;
 
@@ -652,17 +652,17 @@ extern BUFHEAD *
             hashp->FFACTOR = MIN_FFACTOR;
     }
     bufp->flags |= BUF_MOD;
     ovfl_num = overflow_page(hashp);
 #ifdef DEBUG1
     tmp1 = bufp->addr;
     tmp2 = bufp->ovfl ? bufp->ovfl->addr : 0;
 #endif
-    if (!ovfl_num || !(bufp->ovfl = __get_buf(hashp, ovfl_num, bufp, 1)))
+    if (!ovfl_num || !(bufp->ovfl = dbm_get_buf(hashp, ovfl_num, bufp, 1)))
         return (NULL);
     bufp->ovfl->flags |= BUF_MOD;
 #ifdef DEBUG1
     (void)fprintf(stderr, "ADDOVFLPAGE: %d->ovfl was %d is now %d\n",
                   tmp1, tmp2, bufp->ovfl->addr);
 #endif
     ndx = sp[0];
     /*
@@ -682,22 +682,22 @@ extern BUFHEAD *
 }
 
 /*
  * Returns:
  *   0 indicates SUCCESS
  *  -1 indicates FAILURE
  */
 extern int
-__get_page(HTAB *hashp,
-           char *p,
-           uint32 bucket,
-           int is_bucket,
-           int is_disk,
-           int is_bitmap)
+dbm_get_page(HTAB *hashp,
+             char *p,
+             uint32 bucket,
+             int is_bucket,
+             int is_disk,
+             int is_bitmap)
 {
     register int fd, page;
     size_t size;
     int rsize;
     uint16 *bp;
 
     fd = hashp->fp;
     size = hashp->BSIZE;
@@ -800,17 +800,17 @@ extern int
 /*
  * Write page p to disk
  *
  * Returns:
  *   0 ==> OK
  *  -1 ==>failure
  */
 extern int
-__put_page(HTAB *hashp, char *p, uint32 bucket, int is_bucket, int is_bitmap)
+dbm_put_page(HTAB *hashp, char *p, uint32 bucket, int is_bucket, int is_bitmap)
 {
     register int fd, page;
     size_t size;
     int wsize;
     off_t offset;
 
     size = hashp->BSIZE;
     if ((hashp->fp == -1) && open_temp(hashp))
@@ -890,17 +890,17 @@ extern int
 }
 
 #define BYTE_MASK ((1 << INT_BYTE_SHIFT) - 1)
 /*
  * Initialize a new bitmap page.  Bitmap pages are left in memory
  * once they are read in.
  */
 extern int
-__ibitmap(HTAB *hashp, int pnum, int nbits, int ndx)
+dbm_ibitmap(HTAB *hashp, int pnum, int nbits, int ndx)
 {
     uint32 *ip;
     size_t clearbytes, clearints;
 
     if ((ip = (uint32 *)malloc((size_t)hashp->BSIZE)) == NULL)
         return (1);
     hashp->nmaps++;
     clearints = ((nbits - 1) >> INT_BYTE_SHIFT) + 1;
@@ -1006,18 +1006,18 @@ overflow_page(HTAB *hashp)
          * allocate 2 pages from this map.  The first is going to be
          * the map page, the second is the overflow page we were
          * looking for.  The init_bitmap routine automatically, sets
          * the first bit of itself to indicate that the bitmap itself
          * is in use.  We would explicitly set the second bit, but
          * don't have to if we tell init_bitmap not to leave it clear
          * in the first place.
          */
-        if (__ibitmap(hashp,
-                      (int)OADDR_OF(splitnum, offset), 1, free_page))
+        if (dbm_ibitmap(hashp,
+                        (int)OADDR_OF(splitnum, offset), 1, free_page))
             return (0);
         hashp->SPARES[splitnum]++;
 #ifdef DEBUG2
         free_bit = 2;
 #endif
         offset++;
         if (offset > SPLITMASK) {
             if (++splitnum >= NCACHED) {
@@ -1079,17 +1079,17 @@ found:
     /* Allocate and return the overflow page */
     return (addr);
 }
 
 /*
  * Mark this overflow page as free.
  */
 extern void
-__free_ovflpage(HTAB *hashp, BUFHEAD *obufp)
+dbm_free_ovflpage(HTAB *hashp, BUFHEAD *obufp)
 {
     uint16 addr;
     uint32 *freep;
     uint32 bit_address, free_page, free_bit;
     uint16 ndx;
 
     if (!obufp || !obufp->addr)
         return;
@@ -1120,17 +1120,17 @@ extern void
         return;
     }
 #endif
     CLRBIT(freep, free_bit);
 #ifdef DEBUG2
     (void)fprintf(stderr, "FREE_OVFLPAGE: ADDR: %d BIT: %d PAGE %d\n",
                   obufp->addr, free_bit, free_page);
 #endif
-    __reclaim_buf(hashp, obufp);
+    dbm_reclaim_buf(hashp, obufp);
 }
 
 /*
  * Returns:
  *   0 success
  *  -1 failure
  */
 static int
@@ -1231,37 +1231,37 @@ squeeze_key(uint16 *sp, const DBT *key, 
 
 static uint32 *
 fetch_bitmap(HTAB *hashp, uint32 ndx)
 {
     if (ndx >= (unsigned)hashp->nmaps)
         return (NULL);
     if ((hashp->mapp[ndx] = (uint32 *)malloc((size_t)hashp->BSIZE)) == NULL)
         return (NULL);
-    if (__get_page(hashp,
-                   (char *)hashp->mapp[ndx], hashp->BITMAPS[ndx], 0, 1, 1)) {
+    if (dbm_get_page(hashp,
+                     (char *)hashp->mapp[ndx], hashp->BITMAPS[ndx], 0, 1, 1)) {
         free(hashp->mapp[ndx]);
         hashp->mapp[ndx] = NULL; /* NEW: 9-11-95 */
         return (NULL);
     }
     return (hashp->mapp[ndx]);
 }
 
 #ifdef DEBUG4
 int
 print_chain(int addr)
 {
     BUFHEAD *bufp;
     short *bp, oaddr;
 
     (void)fprintf(stderr, "%d ", addr);
-    bufp = __get_buf(hashp, addr, NULL, 0);
+    bufp = dbm_get_buf(hashp, addr, NULL, 0);
     bp = (short *)bufp->page;
     while (bp[0] && ((bp[bp[0]] == OVFLPAGE) ||
                      ((bp[0] > 2) && bp[2] < REAL_KEY))) {
         oaddr = bp[bp[0] - 1];
         (void)fprintf(stderr, "%d ", (int)oaddr);
-        bufp = __get_buf(hashp, (int)oaddr, bufp, 0);
+        bufp = dbm_get_buf(hashp, (int)oaddr, bufp, 0);
         bp = (short *)bufp->page;
     }
     (void)fprintf(stderr, "\n");
 }
 #endif
diff --git a/security/nss/lib/security/nss/dbm/src/hash.c b/lib/dbm/src/hash.c
--- a/security/nss/lib/security/nss/dbm/src/hash.c
+++ b/security/nss/lib/dbm/src/hash.c
@@ -113,33 +113,33 @@ int hash_accesses, hash_collisions, hash
 
 /* A new Lou (montulli@mozilla.com) routine.
  *
  * The database is screwed.
  *
  * This closes the file, flushing buffers as appropriate.
  */
 static void
-__remove_database(DB *dbp)
+dbm_remove_database(DB *dbp)
 {
     HTAB *hashp = (HTAB *)dbp->internal;
 
     assert(0);
 
     if (!hashp)
         return;
     hdestroy(hashp);
     dbp->internal = NULL;
 }
 
 /************************** INTERFACE ROUTINES ***************************/
 /* OPEN/CLOSE */
 
 extern DB *
-__hash_open(const char *file, int flags, int mode, const HASHINFO *info, int dflags)
+dbm_hash_open(const char *file, int flags, int mode, const HASHINFO *info, int dflags)
 {
     HTAB *hashp = NULL;
     struct stat statbuf;
     DB *dbp;
     int bpages, hdrsize, new_table, nsegs, save_errno;
 
     if ((flags & O_ACCMODE) == O_WRONLY) {
         errno = EINVAL;
@@ -194,17 +194,17 @@ extern DB *
     if (new_table) {
         if (!init_hash(hashp, file, (HASHINFO *)info))
             RETURN_ERROR(errno, error1);
     } else {
         /* Table already exists */
         if (info && info->hash)
             hashp->hash = info->hash;
         else
-            hashp->hash = __default_hash;
+            hashp->hash = dbm_default_hash;
 
         hdrsize = read(hashp->fp, (char *)&hashp->hdr, sizeof(HASHHDR));
         if (hdrsize == -1)
             RETURN_ERROR(errno, error1);
         if (hdrsize != sizeof(HASHHDR))
             RETURN_ERROR(EFTYPE, error1);
 #if BYTE_ORDER == LITTLE_ENDIAN
         swap_header(hashp);
@@ -238,19 +238,19 @@ extern DB *
                  (hashp->BSHIFT + BYTE_SHIFT);
 
         hashp->nmaps = bpages;
         (void)memset(&hashp->mapp[0], 0, bpages * sizeof(uint32 *));
     }
 
     /* Initialize Buffer Manager */
     if (info && info->cachesize)
-        __buf_init(hashp, (int32)info->cachesize);
+        dbm_buf_init(hashp, (int32)info->cachesize);
     else
-        __buf_init(hashp, DEF_BUFSIZE);
+        dbm_buf_init(hashp, DEF_BUFSIZE);
 
     hashp->new_file = new_table;
 #ifdef macintosh
     hashp->save_file = file && !(hashp->flags & O_RDONLY);
 #else
     hashp->save_file = file && (hashp->flags & O_RDWR);
 #endif
     hashp->cbucket = -1;
@@ -326,17 +326,17 @@ init_hash(HTAB *hashp, const char *file,
     hashp->NKEYS = 0;
     hashp->LORDER = BYTE_ORDER;
     hashp->BSIZE = DEF_BUCKET_SIZE;
     hashp->BSHIFT = DEF_BUCKET_SHIFT;
     hashp->SGSIZE = DEF_SEGSIZE;
     hashp->SSHIFT = DEF_SEGSIZE_SHIFT;
     hashp->DSIZE = DEF_DIRSIZE;
     hashp->FFACTOR = DEF_FFACTOR;
-    hashp->hash = __default_hash;
+    hashp->hash = dbm_default_hash;
     memset(hashp->SPARES, 0, sizeof(hashp->SPARES));
     memset(hashp->BITMAPS, 0, sizeof(hashp->BITMAPS));
 
     /* Fix bucket size to be optimal for file system */
     if (file != NULL) {
         if (stat(file, &statbuf))
             return (NULL);
 
@@ -348,23 +348,23 @@ init_hash(HTAB *hashp, const char *file,
 #endif
 
         /* new code added by Lou to reduce block
          * size down below MAX_BSIZE
          */
         if (hashp->BSIZE > MAX_BSIZE)
             hashp->BSIZE = MAX_BSIZE;
 #endif
-        hashp->BSHIFT = __log2((uint32)hashp->BSIZE);
+        hashp->BSHIFT = dbm_log2((uint32)hashp->BSIZE);
     }
 
     if (info) {
         if (info->bsize) {
             /* Round pagesize up to power of 2 */
-            hashp->BSHIFT = __log2(info->bsize);
+            hashp->BSHIFT = dbm_log2(info->bsize);
             hashp->BSIZE = 1 << hashp->BSHIFT;
             if (hashp->BSIZE > MAX_BSIZE) {
                 errno = EINVAL;
                 return (NULL);
             }
         }
         if (info->ffactor)
             hashp->FFACTOR = info->ffactor;
@@ -401,36 +401,36 @@ init_htab(HTAB *hashp, int nelem)
 
     /*
      * Divide number of elements by the fill factor and determine a
      * desired number of buckets.  Allocate space for the next greater
      * power of two number of buckets.
      */
     nelem = (nelem - 1) / hashp->FFACTOR + 1;
 
-    l2 = __log2((uint32)PR_MAX(nelem, 2));
+    l2 = dbm_log2((uint32)PR_MAX(nelem, 2));
     nbuckets = 1 << l2;
 
     hashp->SPARES[l2] = l2 + 1;
     hashp->SPARES[l2 + 1] = l2 + 1;
     hashp->OVFL_POINT = l2;
     hashp->LAST_FREED = 2;
 
     /* First bitmap page is at: splitpoint l2 page offset 1 */
-    if (__ibitmap(hashp, (int)OADDR_OF(l2, 1), l2 + 1, 0))
+    if (dbm_ibitmap(hashp, (int)OADDR_OF(l2, 1), l2 + 1, 0))
         return (-1);
 
     hashp->MAX_BUCKET = hashp->LOW_MASK = nbuckets - 1;
     hashp->HIGH_MASK = (nbuckets << 1) - 1;
     hashp->HDRPAGES = ((PR_MAX(sizeof(HASHHDR), MINHDRSIZE) - 1) >>
                        hashp->BSHIFT) +
                       1;
 
     nsegs = (nbuckets - 1) / hashp->SGSIZE + 1;
-    nsegs = 1 << __log2((uint32)nsegs);
+    nsegs = 1 << dbm_log2((uint32)nsegs);
 
     if (nsegs > hashp->DSIZE)
         hashp->DSIZE = nsegs;
     return (alloc_segs(hashp, nsegs));
 }
 
 /********************** DESTROY/CLOSE ROUTINES ************************/
 
@@ -458,17 +458,17 @@ hdestroy(HTAB *hashp)
     for (i = 0; i < NCACHED; i++)
         (void)fprintf(stderr,
                       "spares[%d] = %d\n", i, hashp->SPARES[i]);
 #endif
     /*
      * Call on buffer manager to free buffers, and if required,
      * write them to disk.
      */
-    if (__buf_free(hashp, 1, hashp->save_file))
+    if (dbm_buf_free(hashp, 1, hashp->save_file))
         save_errno = errno;
     if (hashp->dir) {
         free(*hashp->dir); /* Free initial segments */
         /* Free extra segments */
         while (hashp->exsegs--)
             free(hashp->dir[--hashp->nsegs]);
         free(hashp->dir);
     }
@@ -580,17 +580,17 @@ hash_sync(const DB *dbp, uint flags)
         return (DBM_ERROR);
 
     hashp = (HTAB *)dbp->internal;
     if (!hashp)
         return (DBM_ERROR);
 
     if (!hashp->save_file)
         return (0);
-    if (__buf_free(hashp, 0, 1) || flush_meta(hashp))
+    if (dbm_buf_free(hashp, 0, 1) || flush_meta(hashp))
         return (DBM_ERROR);
 #if defined(_WIN32) || defined(_WINDOWS)
     if (hashp->updateEOF && hashp->filename && !hashp->is_temp) {
         int status = update_EOF(hashp);
         hashp->updateEOF = 0;
         if (status)
             return status;
     }
@@ -630,18 +630,18 @@ flush_meta(HTAB *hashp)
         return (-1);
     else if (wsize != sizeof(HASHHDR)) {
         errno = EFTYPE;
         hashp->dbmerrno = errno;
         return (-1);
     }
     for (i = 0; i < NCACHED; i++)
         if (hashp->mapp[i])
-            if (__put_page(hashp, (char *)hashp->mapp[i],
-                           hashp->BITMAPS[i], 0, 1))
+            if (dbm_put_page(hashp, (char *)hashp->mapp[i],
+                             hashp->BITMAPS[i], 0, 1))
                 return (-1);
     return (0);
 }
 
 /*******************************SEARCH ROUTINES *****************************/
 /*
  * All the access routines return
  *
@@ -670,17 +670,17 @@ hash_get(
     }
 
     rv = hash_access(hashp, HASH_GET, (DBT *)key, data);
 
     if (rv == DATABASE_CORRUPTED_ERROR) {
 #if defined(unix) && defined(DEBUG)
         printf("\n\nDBM Database has been corrupted, tell Lou...\n\n");
 #endif
-        __remove_database((DB *)dbp);
+        dbm_remove_database((DB *)dbp);
     }
 
     return (rv);
 }
 
 static int
 hash_put(
     const DB *dbp,
@@ -706,17 +706,17 @@ hash_put(
 
     rv = hash_access(hashp, flag == R_NOOVERWRITE ? HASH_PUTNEW : HASH_PUT,
                      (DBT *)key, (DBT *)data);
 
     if (rv == DATABASE_CORRUPTED_ERROR) {
 #if defined(unix) && defined(DEBUG)
         printf("\n\nDBM Database has been corrupted, tell Lou...\n\n");
 #endif
-        __remove_database((DB *)dbp);
+        dbm_remove_database((DB *)dbp);
     }
 
     return (rv);
 }
 
 static int
 hash_delete(
     const DB *dbp,
@@ -739,17 +739,17 @@ hash_delete(
         return (DBM_ERROR);
     }
     rv = hash_access(hashp, HASH_DELETE, (DBT *)key, NULL);
 
     if (rv == DATABASE_CORRUPTED_ERROR) {
 #if defined(unix) && defined(DEBUG)
         printf("\n\nDBM Database has been corrupted, tell Lou...\n\n");
 #endif
-        __remove_database((DB *)dbp);
+        dbm_remove_database((DB *)dbp);
     }
 
     return (rv);
 }
 
 #define MAX_OVERFLOW_HASH_ACCESS_LOOPS 2000
 /*
  * Assume that hashp has been set in wrapper routine.
@@ -772,17 +772,17 @@ hash_access(
 
 #ifdef HASH_STATISTICS
     hash_accesses++;
 #endif
 
     off = hashp->BSIZE;
     size = key->size;
     kp = (char *)key->data;
-    rbufp = __get_buf(hashp, __call_hash(hashp, kp, size), NULL, 0);
+    rbufp = dbm_get_buf(hashp, dbm_call_hash(hashp, kp, size), NULL, 0);
     if (!rbufp)
         return (DATABASE_CORRUPTED_ERROR);
     save_bufp = rbufp;
 
     /* Pin the bucket chain */
     rbufp->flags |= BUF_PIN;
     for (bp = (uint16 *)rbufp->page, n = *bp++, ndx = 1; ndx < n;) {
 
@@ -800,44 +800,44 @@ hash_access(
         } else if (bp[1] == OVFLPAGE) {
 
             /* database corruption: overflow loop detection */
             if (last_overflow_page_no == (int32)*bp)
                 return (DATABASE_CORRUPTED_ERROR);
 
             last_overflow_page_no = *bp;
 
-            rbufp = __get_buf(hashp, *bp, rbufp, 0);
+            rbufp = dbm_get_buf(hashp, *bp, rbufp, 0);
             if (!rbufp) {
                 save_bufp->flags &= ~BUF_PIN;
                 return (DBM_ERROR);
             }
 
             ovfl_loop_count++;
             if (ovfl_loop_count > MAX_OVERFLOW_HASH_ACCESS_LOOPS)
                 return (DATABASE_CORRUPTED_ERROR);
 
             /* FOR LOOP INIT */
             bp = (uint16 *)rbufp->page;
             n = *bp++;
             ndx = 1;
             off = hashp->BSIZE;
         } else if (bp[1] < REAL_KEY) {
             if ((ndx =
-                     __find_bigpair(hashp, rbufp, ndx, kp, (int)size)) > 0)
+                     dbm_find_bigpair(hashp, rbufp, ndx, kp, (int)size)) > 0)
                 goto found;
             if (ndx == -2) {
                 bufp = rbufp;
                 if (!(pageno =
-                          __find_last_page(hashp, &bufp))) {
+                          dbm_find_last_page(hashp, &bufp))) {
                     ndx = 0;
                     rbufp = bufp;
                     break; /* FOR */
                 }
-                rbufp = __get_buf(hashp, pageno, bufp, 0);
+                rbufp = dbm_get_buf(hashp, pageno, bufp, 0);
                 if (!rbufp) {
                     save_bufp->flags &= ~BUF_PIN;
                     return (DBM_ERROR);
                 }
                 /* FOR LOOP INIT */
                 bp = (uint16 *)rbufp->page;
                 n = *bp++;
                 ndx = 1;
@@ -848,17 +848,17 @@ hash_access(
             }
         }
     }
 
     /* Not found */
     switch (action) {
         case HASH_PUT:
         case HASH_PUTNEW:
-            if (__addel(hashp, rbufp, key, val)) {
+            if (dbm_addel(hashp, rbufp, key, val)) {
                 save_bufp->flags &= ~BUF_PIN;
                 return (DBM_ERROR);
             } else {
                 save_bufp->flags &= ~BUF_PIN;
                 return (SUCCESS);
             }
         case HASH_GET:
         case HASH_DELETE:
@@ -870,32 +870,32 @@ hash_access(
 found:
     switch (action) {
         case HASH_PUTNEW:
             save_bufp->flags &= ~BUF_PIN;
             return (ABNORMAL);
         case HASH_GET:
             bp = (uint16 *)rbufp->page;
             if (bp[ndx + 1] < REAL_KEY) {
-                if (__big_return(hashp, rbufp, ndx, val, 0))
+                if (dbm_big_return(hashp, rbufp, ndx, val, 0))
                     return (DBM_ERROR);
             } else {
                 val->data = (uint8 *)rbufp->page + (int)bp[ndx + 1];
                 val->size = bp[ndx] - bp[ndx + 1];
             }
             break;
         case HASH_PUT:
-            if ((__delpair(hashp, rbufp, ndx)) ||
-                (__addel(hashp, rbufp, key, val))) {
+            if ((dbm_delpair(hashp, rbufp, ndx)) ||
+                (dbm_addel(hashp, rbufp, key, val))) {
                 save_bufp->flags &= ~BUF_PIN;
                 return (DBM_ERROR);
             }
             break;
         case HASH_DELETE:
-            if (__delpair(hashp, rbufp, ndx))
+            if (dbm_delpair(hashp, rbufp, ndx))
                 return (DBM_ERROR);
             break;
         default:
             abort();
     }
     save_bufp->flags &= ~BUF_PIN;
     return (SUCCESS);
 }
@@ -928,17 +928,17 @@ hash_seq(
         hashp->cpage = NULL;
     }
 
     for (bp = NULL; !bp || !bp[0];) {
         if (!(bufp = hashp->cpage)) {
             for (bucket = hashp->cbucket;
                  bucket <= (uint32)hashp->MAX_BUCKET;
                  bucket++, hashp->cndx = 1) {
-                bufp = __get_buf(hashp, bucket, NULL, 0);
+                bufp = dbm_get_buf(hashp, bucket, NULL, 0);
                 if (!bufp)
                     return (DBM_ERROR);
                 hashp->cpage = bufp;
                 bp = (uint16 *)bufp->page;
                 if (bp[0])
                     break;
             }
             hashp->cbucket = bucket;
@@ -950,30 +950,30 @@ hash_seq(
             bp = (uint16 *)hashp->cpage->page;
 
 #ifdef DEBUG
         assert(bp);
         assert(bufp);
 #endif
         while (bp[hashp->cndx + 1] == OVFLPAGE) {
             bufp = hashp->cpage =
-                __get_buf(hashp, bp[hashp->cndx], bufp, 0);
+                dbm_get_buf(hashp, bp[hashp->cndx], bufp, 0);
             if (!bufp)
                 return (DBM_ERROR);
             bp = (uint16 *)(bufp->page);
             hashp->cndx = 1;
         }
         if (!bp[0]) {
             hashp->cpage = NULL;
             ++hashp->cbucket;
         }
     }
     ndx = hashp->cndx;
     if (bp[ndx + 1] < REAL_KEY) {
-        if (__big_keydata(hashp, bufp, key, data, 1))
+        if (dbm_big_keydata(hashp, bufp, key, data, 1))
             return (DBM_ERROR);
     } else {
         key->data = (uint8 *)hashp->cpage->page + bp[ndx];
         key->size = (ndx > 1 ? bp[ndx - 1] : hashp->BSIZE) - bp[ndx];
         data->data = (uint8 *)hashp->cpage->page + bp[ndx + 1];
         data->size = bp[ndx] - bp[ndx + 1];
         ndx += 2;
         if (ndx > bp[0]) {
@@ -989,17 +989,17 @@ hash_seq(
 /********************************* UTILITIES ************************/
 
 /*
  * Returns:
  *   0 ==> OK
  *  -1 ==> Error
  */
 extern int
-__expand_table(HTAB *hashp)
+dbm_expand_table(HTAB *hashp)
 {
     uint32 old_bucket, new_bucket;
     int new_segnum, spare_ndx;
     size_t dirsize;
 
 #ifdef HASH_STATISTICS
     hash_expansions++;
 #endif
@@ -1024,29 +1024,29 @@ extern int
         hashp->exsegs++;
         hashp->nsegs++;
     }
     /*
      * If the split point is increasing (MAX_BUCKET's log base 2
      * * increases), we need to copy the current contents of the spare
      * split bucket to the next bucket.
      */
-    spare_ndx = __log2((uint32)(hashp->MAX_BUCKET + 1));
+    spare_ndx = dbm_log2((uint32)(hashp->MAX_BUCKET + 1));
     if (spare_ndx > hashp->OVFL_POINT) {
         hashp->SPARES[spare_ndx] = hashp->SPARES[hashp->OVFL_POINT];
         hashp->OVFL_POINT = spare_ndx;
     }
 
     if (new_bucket > (uint32)hashp->HIGH_MASK) {
         /* Starting a new doubling */
         hashp->LOW_MASK = hashp->HIGH_MASK;
         hashp->HIGH_MASK = new_bucket | hashp->LOW_MASK;
     }
     /* Relocate records to the new bucket */
-    return (__split_page(hashp, old_bucket, new_bucket));
+    return (dbm_split_page(hashp, old_bucket, new_bucket));
 }
 
 /*
  * If realloc guarantees that the pointer is not destroyed if the realloc
  * fails, then this routine can go away.
  */
 static void *
 hash_realloc(
@@ -1060,17 +1060,17 @@ hash_realloc(
         memset((char *)p + oldsize, 0, newsize - oldsize);
         free(*p_ptr);
         *p_ptr = (SEGMENT *)p;
     }
     return (p);
 }
 
 extern uint32
-__call_hash(HTAB *hashp, char *k, size_t len)
+dbm_call_hash(HTAB *hashp, char *k, size_t len)
 {
     uint32 n, bucket;
 
     n = hashp->hash(k, len);
     bucket = n & hashp->HIGH_MASK;
     if (bucket > (uint32)hashp->MAX_BUCKET)
         bucket = bucket & hashp->LOW_MASK;
     return (bucket);
diff --git a/security/nss/lib/security/nss/dbm/src/hash_buf.c b/lib/dbm/src/hash_buf.c
--- a/security/nss/lib/security/nss/dbm/src/hash_buf.c
+++ b/security/nss/lib/dbm/src/hash_buf.c
@@ -99,17 +99,17 @@ static BUFHEAD *newbuf(HTAB *, uint32, B
  * address is a bucket index.  If prev_bp is not NULL, then it points to the
  * page previous to an overflow page that we are trying to find.
  *
  * CAVEAT:  The buffer header accessed via prev_bp's ovfl field may no longer
  * be valid.  Therefore, you must always verify that its address matches the
  * address you are seeking.
  */
 extern BUFHEAD *
-__get_buf(HTAB *hashp, uint32 addr, BUFHEAD *prev_bp, int newpage)
+dbm_get_buf(HTAB *hashp, uint32 addr, BUFHEAD *prev_bp, int newpage)
 /* If prev_bp set, indicates a new overflow page. */
 {
     register BUFHEAD *bp;
     register uint32 is_disk_mask;
     register int is_disk, segment_ndx = 0;
     SEGMENT segp = 0;
 
     is_disk = 0;
@@ -119,33 +119,33 @@ extern BUFHEAD *
         if (!bp || (bp->addr != addr))
             bp = NULL;
         if (!newpage)
             is_disk = BUF_DISK;
     } else {
         /* Grab buffer out of directory */
         segment_ndx = addr & (hashp->SGSIZE - 1);
 
-        /* valid segment ensured by __call_hash() */
+        /* valid segment ensured by dbm_call_hash() */
         segp = hashp->dir[addr >> hashp->SSHIFT];
 #ifdef DEBUG
         assert(segp != NULL);
 #endif
 
         bp = PTROF(segp[segment_ndx]);
 
         is_disk_mask = ISDISK(segp[segment_ndx]);
         is_disk = is_disk_mask || !hashp->new_file;
     }
 
     if (!bp) {
         bp = newbuf(hashp, addr, prev_bp);
         if (!bp)
             return (NULL);
-        if (__get_page(hashp, bp->page, addr, !prev_bp, is_disk, 0)) {
+        if (dbm_get_page(hashp, bp->page, addr, !prev_bp, is_disk, 0)) {
             /* free bp and its page */
             if (prev_bp) {
                 /* if prev_bp is set then the new page that
                  * failed is hooked onto prev_bp as an overflow page.
                  * if we don't remove the pointer to the bad page
                  * we may try and access it later and we will die
                  * horribly because it will have already been
                  * free'd and overwritten with bogus data.
@@ -237,18 +237,18 @@ newbuf(HTAB *hashp, uint32 addr, BUFHEAD
              */
             shortp = (uint16 *)bp->page;
             if (shortp[0]) {
                 if (shortp[0] > (hashp->BSIZE / sizeof(uint16))) {
                     return (NULL);
                 }
                 oaddr = shortp[shortp[0] - 1];
             }
-            if ((bp->flags & BUF_MOD) && __put_page(hashp, bp->page,
-                                                    bp->addr, (int)IS_BUCKET(bp->flags), 0))
+            if ((bp->flags & BUF_MOD) && dbm_put_page(hashp, bp->page,
+                                                      bp->addr, (int)IS_BUCKET(bp->flags), 0))
                 return (NULL);
             /*
              * Update the pointer to this page (i.e. invalidate it).
              *
              * If this is a new file (i.e. we created it at open
              * time), make sure that we mark pages which have been
              * written to disk so we retrieve them from disk later,
              * rather than allocating new pages.
@@ -293,18 +293,18 @@ newbuf(HTAB *hashp, uint32 addr, BUFHEAD
                     /* LJM is the number of reported
                      * pages way too much?
                      */
                     if (shortp[0] > hashp->BSIZE / sizeof(uint16))
                         return NULL;
                     /* set before __put_page */
                     oaddr = shortp[shortp[0] - 1];
                 }
-                if ((xbp->flags & BUF_MOD) && __put_page(hashp,
-                                                         xbp->page, xbp->addr, 0, 0))
+                if ((xbp->flags & BUF_MOD) && dbm_put_page(hashp,
+                                                           xbp->page, xbp->addr, 0, 0))
                     return (NULL);
                 xbp->addr = 0;
                 xbp->flags = 0;
                 BUF_REMOVE(xbp);
                 LRU_INSERT(xbp);
             }
         }
     }
@@ -330,17 +330,17 @@ newbuf(HTAB *hashp, uint32 addr, BUFHEAD
         bp->flags = 0;
     } else
         bp->flags = BUF_BUCKET;
     MRU_INSERT(bp);
     return (bp);
 }
 
 extern void
-__buf_init(HTAB *hashp, int32 nbytes)
+dbm_buf_init(HTAB *hashp, int32 nbytes)
 {
     BUFHEAD *bfp;
     int npages;
 
     bfp = &(hashp->bufhead);
     npages = (nbytes + hashp->BSIZE - 1) >> hashp->BSHIFT;
     npages = PR_MAX(npages, MIN_BUFFERS);
 
@@ -353,30 +353,30 @@ extern void
      * bfp->ovfl = NULL;
      * bfp->flags = 0;
      * bfp->page = NULL;
      * bfp->addr = 0;
      */
 }
 
 extern int
-__buf_free(HTAB *hashp, int do_free, int to_disk)
+dbm_buf_free(HTAB *hashp, int do_free, int to_disk)
 {
     BUFHEAD *bp;
     int status = -1;
 
     /* Need to make sure that buffer manager has been initialized */
     if (!LRU)
         return (0);
     for (bp = LRU; bp != &hashp->bufhead;) {
         /* Check that the buffer is valid */
         if (bp->addr || IS_BUCKET(bp->flags)) {
             if (to_disk && (bp->flags & BUF_MOD) &&
-                (status = __put_page(hashp, bp->page,
-                                     bp->addr, IS_BUCKET(bp->flags), 0))) {
+                (status = dbm_put_page(hashp, bp->page,
+                                       bp->addr, IS_BUCKET(bp->flags), 0))) {
 
                 if (do_free) {
                     if (bp->page)
                         free(bp->page);
                     BUF_REMOVE(bp);
                     free(bp);
                 }
 
@@ -392,16 +392,16 @@ extern int
             bp = LRU;
         } else
             bp = bp->prev;
     }
     return (0);
 }
 
 extern void
-__reclaim_buf(HTAB *hashp, BUFHEAD *bp)
+dbm_reclaim_buf(HTAB *hashp, BUFHEAD *bp)
 {
     bp->ovfl = 0;
     bp->addr = 0;
     bp->flags = 0;
     BUF_REMOVE(bp);
     LRU_INSERT(bp);
 }

