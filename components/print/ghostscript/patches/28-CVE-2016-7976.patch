Description: CVE-2016-7976: Various userparams allow %pipe% in paths, allowing remote shell command execution
Origin: backport, http://git.ghostscript.com/?p=ghostpdl.git;h=6d444c273da5499a4cd72f21cb6d4c9a5256807d
Bug: http://bugs.ghostscript.com/show_bug.cgi?id=697178
Bug-Debian: https://bugs.debian.org/839260
Forwarded: not-needed
Author: Salvatore Bonaccorso <carnil@debian.org>
Reviewed-by: Emily Ratliff <emily.ratliff@canonical.com>
Last-Update: 2016-11-30
---

--- ghostscript-9.00/base/gsicc_manage.c.~1~	2016-12-02 10:59:47.032537280 +0300
+++ ghostscript-9.00/base/gsicc_manage.c	2016-12-02 11:04:48.199259954 +0300
@@ -691,9 +691,12 @@
     }
 
     /* First just try it like it is */
-    str = sfopen(pname, "rb", mem_gc);
-    if (str != NULL) 
-        return(str);
+    if (gs_check_file_permission(mem_gc, pname, namelen, "r") >= 0) {
+        str = sfopen(pname, "r", mem_gc);
+        if (str != NULL) {
+            return(str);
+        }
+    }
 
     /* If that fails, try %rom% */
     buffer = (char *) gs_alloc_bytes(mem_gc, 1 + namelen + 
--- ghostscript-9.00/base/gslibctx.c.~1~	2016-12-02 10:59:47.034263324 +0300
+++ ghostscript-9.00/base/gslibctx.c	2016-12-02 11:08:20.943151894 +0300
@@ -74,6 +74,7 @@
     pio->gs_next_id           = 5;  /* this implies that each thread has its own complete state */
     pio->BITTAG               = GS_DEVICE_DOESNT_SUPPORT_TAGS;
 
+    pio->client_check_file_permission = NULL;
     gp_get_realtime(pio->real_time_0);
 
     return 0;
@@ -157,3 +158,12 @@
 }
 
 
+int
+gs_check_file_permission (gs_memory_t *mem, const char *fname, const int len, const char *permission)
+{
+    int code = 0;
+    if (mem->gs_lib_ctx->client_check_file_permission != NULL) {
+        code = mem->gs_lib_ctx->client_check_file_permission(mem, fname, len, permission);
+    }
+    return code;
+}
--- ghostscript-9.00/base/gslibctx.h.~1~	2010-05-02 03:22:33.000000000 +0400
+++ ghostscript-9.00/base/gslibctx.h	2016-12-02 11:10:27.701024822 +0300
@@ -27,6 +27,8 @@
 typedef struct gs_font_dir_s gs_font_dir;
 #endif
 
+typedef int (*client_check_file_permission_t) (gs_memory_t *mem, const char *fname, const int len, const char *permission);
+
 /* graphical object tags */
 typedef enum {
     GS_DEVICE_DOESNT_SUPPORT_TAGS = 0, /* default */
@@ -64,6 +66,7 @@
     bool dict_auto_expand;  /* ps dictionary: false level 1 true level 2 or 3 */
     /* A table of local copies of the IODevices */
     struct gx_io_device_s **io_device_table;
+    client_check_file_permission_t client_check_file_permission;
     /* Define the default value of AccurateScreens that affects setscreen
        and setcolorscreen. */
     bool screen_accurate_screens;
@@ -96,4 +99,7 @@
  */
 gs_memory_t * gs_lib_ctx_get_non_gc_memory_t(void);
 
+int
+gs_check_file_permission (gs_memory_t *mem, const char *fname, const int len, const char *permission);
+
 #endif /* GSLIBCTX_H */
--- ghostscript-9.00/psi/imain.c.~1~	2010-05-04 22:47:12.000000000 +0400
+++ ghostscript-9.00/psi/imain.c	2016-12-02 11:13:30.212541838 +0300
@@ -49,6 +49,7 @@
 #include "ivmspace.h"
 #include "idisp.h"		/* for setting display device callback */
 #include "iplugin.h"
+#include "zfile.h"
 
 /* ------ Exported data ------ */
 
@@ -195,6 +196,7 @@
 					   "the_gs_name_table");
 	    if (code < 0)
 		return code;
+            mem->gs_lib_ctx->client_check_file_permission = z_check_file_permissions;
 	}
 	code = obj_init(&minst->i_ctx_p, &idmem);  /* requires name_init */
 	if (code < 0)
--- ghostscript-9.00/psi/int.mak.~1~	2010-09-07 20:51:36.000000000 +0400
+++ ghostscript-9.00/psi/int.mak	2016-12-02 11:16:51.419100153 +0300
@@ -2013,7 +2013,8 @@
  $(ialloc_h) $(iconf_h) $(idebug_h) $(idict_h) $(idisp_h) $(iinit_h)\
  $(iname_h) $(interp_h) $(iplugin_h) $(isave_h) $(iscan_h) $(ivmspace_h)\
  $(iinit_h) $(main_h) $(oper_h) $(ostack_h)\
- $(sfilter_h) $(store_h) $(stream_h) $(strimpl_h)
+ $(sfilter_h) $(store_h) $(stream_h) $(strimpl_h) $(zfile_h)\
+ $(INT_MAK) $(MAKEDIRS)
 	$(PSCC) $(PSO_)imain.$(OBJ) $(C_) $(PSSRC)imain.c
 
 #****** $(CCINT) interp.c
--- ghostscript-9.05~dfsg.orig/psi/zfile.c
+++ ghostscript-9.05~dfsg/psi/zfile.c
@@ -195,6 +195,25 @@ check_file_permissions(i_ctx_t *i_ctx_p,
     return check_file_permissions_reduced(i_ctx_p, fname_reduced, rlen, permitgroup);
 }
 
+/* z_check_file_permissions: see zfile.h for explanation
+ */
+int
+z_check_file_permissions(gs_memory_t *mem, const char *fname, const int len, const char *permission)
+{
+    i_ctx_t *i_ctx_p = get_minst_from_memory(mem)->i_ctx_p;
+    gs_parsed_file_name_t pname;
+    const char *permitgroup = permission[0] == 'r' ? "PermitFileReading" : "PermitFileWriting";
+    int code = gs_parse_file_name(&pname, fname, len, imemory);
+    if (code < 0)
+        return code;
+
+    if (pname.iodev && i_ctx_p->LockFilePermissions && strcmp(pname.iodev->dname, "%pipe%") == 0)
+        return e_invalidaccess;
+        
+    code = check_file_permissions(i_ctx_p, fname, len, permitgroup);
+    return code;
+}
+
 /* <name_string> <access_string> file <file> */
 int                             /* exported for zsysvm.c */
 zfile(i_ctx_t *i_ctx_p)
--- ghostscript-9.05~dfsg.orig/psi/zfile.h
+++ ghostscript-9.05~dfsg/psi/zfile.h
@@ -20,4 +20,11 @@
 int zopen_file(i_ctx_t *i_ctx_p, const gs_parsed_file_name_t *pfn,
            const char *file_access, stream **ps, gs_memory_t *mem);
 
+/* z_check_file_permissions: a callback (via mem->gs_lib_ctx->client_check_file_permission)
+ * to allow applying the above permissions checks when opening file(s) from
+ * the graphics library
+ */
+int
+z_check_file_permissions(gs_memory_t *mem, const char *fname,
+                                 const int len, const char *permission);
 #endif
