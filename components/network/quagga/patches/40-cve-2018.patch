This patch includes the fixes for the following CVEs:
cve-2018-5378
cve-2018-5379
cve-2018-5381
cve-2017-16227
cve-2016-1245

All of these CVEs are fixed in Quagga 1.2.4 and this patch may be removed
when Quagga in Solaris is upgraded to that version or later.

These bug fixes are all directly from the Quagga community GIT repository at
http://git.savannah.gnu.org/gitweb/?p=quagga.git. The specific changes are as
follows:
cve-2018-5378
http://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=9e5251151894aefdf8e9392a2371615222119ad8

cve-2018-5379
http://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=e69b535f92eafb599329bf725d9b4c6fd5d7fded

cve-2018-5381
http://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=ce07207c50a3d1f05d6dd49b5294282e59749787

cve-2017-16227
http://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=7a42b78be9a4108d98833069a88e6fddb9285008

cve-2016-1245
http://git.savannah.gnu.org/gitweb/?p=quagga.git;a=commitdiff;h=23ed2c2fb49b8a15ad125b16278e535719d64e7d

*** zebra/rtadv.c
--- zebra/rtadv.c
*************** rtadv_read (struct thread *thread)
*** 473,479 ****
    /* Register myself. */
    rtadv_event (RTADV_READ, sock);
  
!   len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);
  
    if (len < 0) 
      {
--- 473,479 ----
    /* Register myself. */
    rtadv_event (RTADV_READ, sock);
  
!   len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);
  
    if (len < 0) 
      {
*** bgpd/bgp_aspath.c
--- bgpd/bgp_aspath.c
*************** aspath_put (struct stream *s, struct asp
*** 874,880 ****
                assegment_header_put (s, seg->type, AS_SEGMENT_MAX);
                assegment_data_put (s, seg->as, AS_SEGMENT_MAX, use32bit);
                written += AS_SEGMENT_MAX;
!               bytes += ASSEGMENT_SIZE (written, use32bit);
              }
            
            /* write the final segment, probably is also the first */
--- 874,880 ----
                assegment_header_put (s, seg->type, AS_SEGMENT_MAX);
                assegment_data_put (s, seg->as, AS_SEGMENT_MAX, use32bit);
                written += AS_SEGMENT_MAX;
!               bytes += ASSEGMENT_SIZE (AS_SEGMENT_MAX, use32bit);
              }
            
            /* write the final segment, probably is also the first */
*** bgpd/bgp_debug.c
--- bgpd/bgp_debug.c
*************** Software Foundation, Inc., 59 Temple Pla
*** 28,33 ****
--- 28,34 ----
  #include "str.h"
  #include "log.h"
  #include "sockunion.h"
+ #include "memory.h"
  
  #include "bgpd/bgpd.h"
  #include "bgpd/bgp_aspath.h"
*************** const struct message bgp_status_msg[] =
*** 68,74 ****
    { Clearing,    "Clearing"    },
    { Deleted,     "Deleted"     },
  };
! const int bgp_status_msg_max = BGP_STATUS_MAX;
  
  /* BGP message type string. */
  const char *bgp_type_str[] =
--- 69,76 ----
    { Clearing,    "Clearing"    },
    { Deleted,     "Deleted"     },
  };
! #define BGP_DEBUG_MSG_MAX(msg) const int msg ## _max = array_size (msg)
! BGP_DEBUG_MSG_MAX (bgp_status_msg);
  
  /* BGP message type string. */
  const char *bgp_type_str[] =
*************** const char *bgp_type_str[] =
*** 79,85 ****
    "NOTIFICATION",
    "KEEPALIVE",
    "ROUTE-REFRESH",
!   "CAPABILITY"
  };
  
  /* message for BGP-4 Notify */
--- 81,88 ----
    "NOTIFICATION",
    "KEEPALIVE",
    "ROUTE-REFRESH",
!   "CAPABILITY",
!   NULL,
  };
  
  /* message for BGP-4 Notify */
*************** static const struct message bgp_notify_m
*** 93,107 ****
    { BGP_NOTIFY_CEASE, "Cease"},
    { BGP_NOTIFY_CAPABILITY_ERR, "CAPABILITY Message Error"},
  };
! static const int bgp_notify_msg_max = BGP_NOTIFY_MAX;
  
  static const struct message bgp_notify_head_msg[] = 
  {
    { BGP_NOTIFY_HEADER_NOT_SYNC, "/Connection Not Synchronized"},
    { BGP_NOTIFY_HEADER_BAD_MESLEN, "/Bad Message Length"},
!   { BGP_NOTIFY_HEADER_BAD_MESTYPE, "/Bad Message Type"}
  };
! static const int bgp_notify_head_msg_max = BGP_NOTIFY_HEADER_MAX;
  
  static const struct message bgp_notify_open_msg[] = 
  {
--- 96,110 ----
    { BGP_NOTIFY_CEASE, "Cease"},
    { BGP_NOTIFY_CAPABILITY_ERR, "CAPABILITY Message Error"},
  };
! BGP_DEBUG_MSG_MAX (bgp_notify_msg);
  
  static const struct message bgp_notify_head_msg[] = 
  {
    { BGP_NOTIFY_HEADER_NOT_SYNC, "/Connection Not Synchronized"},
    { BGP_NOTIFY_HEADER_BAD_MESLEN, "/Bad Message Length"},
!   { BGP_NOTIFY_HEADER_BAD_MESTYPE, "/Bad Message Type"},
  };
! BGP_DEBUG_MSG_MAX (bgp_notify_head_msg);
  
  static const struct message bgp_notify_open_msg[] = 
  {
*************** static const struct message bgp_notify_o
*** 113,119 ****
    { BGP_NOTIFY_OPEN_UNACEP_HOLDTIME, "/Unacceptable Hold Time"}, 
    { BGP_NOTIFY_OPEN_UNSUP_CAPBL, "/Unsupported Capability"},
  };
! static const int bgp_notify_open_msg_max = BGP_NOTIFY_OPEN_MAX;
  
  static const struct message bgp_notify_update_msg[] = 
  {
--- 116,122 ----
    { BGP_NOTIFY_OPEN_UNACEP_HOLDTIME, "/Unacceptable Hold Time"}, 
    { BGP_NOTIFY_OPEN_UNSUP_CAPBL, "/Unsupported Capability"},
  };
! BGP_DEBUG_MSG_MAX (bgp_notify_open_msg);
  
  static const struct message bgp_notify_update_msg[] = 
  {
*************** static const struct message bgp_notify_u
*** 129,135 ****
    { BGP_NOTIFY_UPDATE_INVAL_NETWORK, "/Invalid Network Field"},
    { BGP_NOTIFY_UPDATE_MAL_AS_PATH, "/Malformed AS_PATH"},
  };
! static const int bgp_notify_update_msg_max = BGP_NOTIFY_UPDATE_MAX;
  
  static const struct message bgp_notify_cease_msg[] =
  {
--- 132,138 ----
    { BGP_NOTIFY_UPDATE_INVAL_NETWORK, "/Invalid Network Field"},
    { BGP_NOTIFY_UPDATE_MAL_AS_PATH, "/Malformed AS_PATH"},
  };
! BGP_DEBUG_MSG_MAX (bgp_notify_update_msg);
  
  static const struct message bgp_notify_cease_msg[] =
  {
*************** static const struct message bgp_notify_c
*** 142,148 ****
    { BGP_NOTIFY_CEASE_COLLISION_RESOLUTION, "/Connection collision resolution"},
    { BGP_NOTIFY_CEASE_OUT_OF_RESOURCE, "/Out of Resource"},
  };
! static const int bgp_notify_cease_msg_max = BGP_NOTIFY_CEASE_MAX;
  
  static const struct message bgp_notify_capability_msg[] = 
  {
--- 145,151 ----
    { BGP_NOTIFY_CEASE_COLLISION_RESOLUTION, "/Connection collision resolution"},
    { BGP_NOTIFY_CEASE_OUT_OF_RESOURCE, "/Out of Resource"},
  };
! BGP_DEBUG_MSG_MAX (bgp_notify_cease_msg);
  
  static const struct message bgp_notify_capability_msg[] = 
  {
*************** static const struct message bgp_notify_c
*** 150,156 ****
    { BGP_NOTIFY_CAPABILITY_INVALID_LENGTH, "/Invalid Capability Length"},
    { BGP_NOTIFY_CAPABILITY_MALFORMED_CODE, "/Malformed Capability Value"},
  };
! static const int bgp_notify_capability_msg_max = BGP_NOTIFY_CAPABILITY_MAX;
  
  /* Origin strings. */
  const char *bgp_origin_str[] = {"i","e","?"};
--- 153,159 ----
    { BGP_NOTIFY_CAPABILITY_INVALID_LENGTH, "/Invalid Capability Length"},
    { BGP_NOTIFY_CAPABILITY_MALFORMED_CODE, "/Malformed Capability Value"},
  };
! BGP_DEBUG_MSG_MAX (bgp_notify_capability_msg);
  
  /* Origin strings. */
  const char *bgp_origin_str[] = {"i","e","?"};
*** lib/memory.h
--- lib/memory.h
*************** Software Foundation, Inc., 59 Temple Pla
*** 21,26 ****
--- 21,27 ----
  #ifndef _ZEBRA_MEMORY_H
  #define _ZEBRA_MEMORY_H
  
+ #define array_size(ar) (sizeof(ar) / sizeof(ar[0]))
  /* For pretty printing of memory allocate information. */
  struct memory_list
  {
*** bgpd/bgp_attr.h
--- bgpd/bgp_attr.h
*************** extern unsigned long int attr_unknown_co
*** 174,183 ****
  
  /* Cluster list prototypes. */
  extern int cluster_loop_check (struct cluster_list *, struct in_addr);
! extern void cluster_unintern (struct cluster_list *);
  
  /* Transit attribute prototypes. */
! void transit_unintern (struct transit *);
  
  /* Exported for unit-test purposes only */
  extern int bgp_mp_reach_parse (struct peer *, bgp_size_t, struct attr *,
--- 174,183 ----
  
  /* Cluster list prototypes. */
  extern int cluster_loop_check (struct cluster_list *, struct in_addr);
! extern void cluster_unintern (struct cluster_list **);
  
  /* Transit attribute prototypes. */
! void transit_unintern (struct transit **);
  
  /* Exported for unit-test purposes only */
  extern int bgp_mp_reach_parse (struct peer *, bgp_size_t, struct attr *,
*** bgpd/bgp_attr.c
--- bgpd/bgp_attr.c
*************** cluster_intern (struct cluster_list *clu
*** 173,189 ****
  }
  
  void
! cluster_unintern (struct cluster_list *cluster)
  {
!   struct cluster_list *ret;
  
!   if (cluster->refcnt)
!     cluster->refcnt--;
  
!   if (cluster->refcnt == 0)
      {
!       ret = hash_release (cluster_hash, cluster);
!       cluster_free (cluster);
      }
  }
  
--- 173,190 ----
  }
  
  void
! cluster_unintern (struct cluster_list **cluster)
  {
!   struct cluster_list *c = *cluster;
  
!   if (c->refcnt)
!     c->refcnt--;
  
!   if (c->refcnt == 0)
      {
!       hash_release (cluster_hash, c);
!       cluster_free (c);
!       *cluster = NULL;
      }
  }
  
*************** transit_intern (struct transit *transit)
*** 233,249 ****
  }
  
  void
! transit_unintern (struct transit *transit)
  {
!   struct transit *ret;
  
!   if (transit->refcnt)
!     transit->refcnt--;
  
!   if (transit->refcnt == 0)
      {
!       ret = hash_release (transit_hash, transit);
!       transit_free (transit);
      }
  }
  
--- 234,251 ----
  }
  
  void
! transit_unintern (struct transit **transit)
  {
!   struct transit *t = *transit;
  
!   if (t->refcnt)
!     t->refcnt--;
  
!   if (t->refcnt == 0)
      {
!       hash_release (transit_hash, t);
!       transit_free (t);
!       *transit = NULL;
      }
  }
  
*************** bgp_attr_unintern_sub (struct attr *attr
*** 638,648 ****
        UNSET_FLAG(attr->flag, BGP_ATTR_EXT_COMMUNITIES);
        
        if (attr->extra->cluster)
!         cluster_unintern (attr->extra->cluster);
        UNSET_FLAG(attr->flag, BGP_ATTR_CLUSTER_LIST);
        
        if (attr->extra->transit)
!         transit_unintern (attr->extra->transit);
      }
  }
  
--- 640,650 ----
        UNSET_FLAG(attr->flag, BGP_ATTR_EXT_COMMUNITIES);
        
        if (attr->extra->cluster)
!         cluster_unintern (&attr->extra->cluster);
        UNSET_FLAG(attr->flag, BGP_ATTR_CLUSTER_LIST);
        
        if (attr->extra->transit)
!         transit_unintern (&attr->extra->transit);
      }
  }
  
*** bgpd/bgp_packet.c
--- bgpd/bgp_packet.c
*************** bgp_capability_msg_parse (struct peer *p
*** 2136,2142 ****
    bgp = peer->bgp;
    end = pnt + length;
  
!   while (pnt < end)
      {      
        /* We need at least action, capability code and capability length. */
        if (pnt + 3 > end)
--- 2136,2143 ----
    bgp = peer->bgp;
    end = pnt + length;
  
!   /* XXX: Streamify this */
!   for (; pnt < end; pnt += hdr->length + 3)
      {      
        /* We need at least action, capability code and capability length. */
        if (pnt + 3 > end)
*************** bgp_capability_msg_parse (struct peer *p
*** 2224,2230 ****
            zlog_warn ("%s unrecognized capability code: %d - ignored",
                       peer->host, hdr->code);
          }
-       pnt += hdr->length + 3;
      }
    return 0;
  }
--- 2225,2230 ----
