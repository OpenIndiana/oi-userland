#!/usr/bin/python2.7

#
# This file and its contents are supplied under the terms of the
# Common Development and Distribution License ("CDDL"), version 1.0.
# You may only use this file in accordance with the terms of version
# 1.0 of the CDDL.
#
# A full copy of the text of the CDDL should have accompanied this
# source.  A copy of the CDDL is also available via the Internet at
# http://www.illumos.org/license/CDDL.
#

#
# Copyright 2018 Adam Stevko
#

#
# userland-deprecate - deprecate component type and update dependent components
#

import argparse
import subprocess
import os
import re
import sys
import json


def load_db(file_name):
    with open(file_name, 'r') as f:
        return json.loads(f.read())


def convert_fmri_to_path(fmri):

    result = None

    ws_tools = os.path.dirname(os.path.realpath(sys.argv[0]))
    component_translate = os.path.join(ws_tools, 'component-translate')

    args = [component_translate, '--fmri', fmri]
    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    for out in proc.stdout:
        result = out.rstrip()

    return result


def locate_dependents(path, data):
    result = []

    for component in data.keys():
        if path in data[component]:
            result.append(component)

    return result


def bump_component_revision(contents):
    contents_new = []

    component_version_idx = 0
    component_revision_idx = 0
    has_component_revision = False
    for idx, line in enumerate(contents):
        if re.match(r'^COMPONENT_VERSION\s*=', line):
            component_version_idx = idx

        if re.match(r'^COMPONENT_REVISION\s*=', line):
            has_component_revision = True
            component_revision_idx = idx

    if has_component_revision:
        contents_new.extend(contents[:component_revision_idx])

        component_revision = contents[component_revision_idx].split('=')[-1]
        try:
            component_revision_int = int(component_revision)
        except ValueError:
            print('\tSkipping component, COMPONENT_REVISION field malformed: {}'.format(component_revision))
            return contents
        else:
            component_revision_int += 1
            contents_new.append('COMPONENT_REVISION=\t{}\n'.format(component_revision_int))

        contents_new.extend(contents[component_revision_idx + 1:])
    else:
        contents_new.extend(contents[:component_version_idx + 1])
        contents_new.append('COMPONENT_REVISION=\t1\n')
        contents_new.extend(contents[component_version_idx + 1:])

    return contents_new


def deprecate_python(version, db_path=None, workspace=None, subdir='components', verbose=False):
    data = load_db(db_path)
    pyv  = version.replace('.', '')
    path = convert_fmri_to_path('runtime/python-'+pyv)
    dependent_paths = locate_dependents(path=path, data=data)
    for component_path in dependent_paths:
        if verbose:
            print('Processing {}'.format(component_path))

        component_fullpath =  os.path.join(workspace, subdir, component_path)

        contents = []
        makefile = os.path.join(component_fullpath, 'Makefile')
        with open(makefile, 'r') as f:
            contents = f.readlines()
        # Bump component revision
        contents = bump_component_revision(contents)

        contents_new = []
        for idx, line in enumerate(contents):
            # Adjust list of packaged python versions
            if re.match(r'^PYTHON_VERSIONS\s*=', line):
                line = line.replace(version, "")
                contents_new.append(re.sub(r' +',' ', line))
            # Remove required packages for current python version
            elif not re.match(r'^REQUIRED_PACKAGES\s*[+]?=.*-{0}'.format(pyv), line):
                contents_new.append(line)

        with open(makefile, 'w') as f:
            for line in contents_new:
                f.write(line)
        
        # Generate fmris for history
        proc = subprocess.Popen(['gmake', '-s', 'print-value-IPS_COMPONENT_VERSION', 'print-value-BRANCHID'],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                cwd=os.path.join(component_fullpath),
                                universal_newlines=True)
        stdout, stderr = proc.communicate()
        suffix = []
        for out in stdout.splitlines():
            suffix.append(out.rstrip())

        with open(os.path.join(component_fullpath, 'pkg5'), 'r') as f:
            data = json.loads(f.read())
        if not data:
            raise ValueError('Component pkg5 data is empty for path ' + self.path + '.')
        contents_new = []
        for prefix in data['fmris']:
            if re.match(r'^.*-{0}'.format(pyv), prefix):
                contents_new.append("{0}@{1}\n".format(prefix, ','.join(suffix)))

        history_exists = os.path.isfile(os.path.join(component_fullpath, 'history'))
        if history_exists:
            with open(os.path.join(component_fullpath, 'history'), 'r') as f:
                contents_new += f.readlines()
        with open(os.path.join(component_fullpath, 'history'), 'w') as f:
            for line in contents_new:
                f.write(line)

        # Update metadata
        proc = subprocess.Popen(['gmake', '-s', 'update-metadata'],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                cwd=os.path.join(component_fullpath),
                                universal_newlines=True)
        stdout, stderr = proc.communicate()

        # Add to GIT
        proc = subprocess.Popen(['git', 'add', 'history', 'pkg5', 'Makefile'],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                cwd=os.path.join(component_fullpath),
                                universal_newlines=True)
        stdout, stderr = proc.communicate()


def main():
    db_default_path = os.path.join(os.path.dirname(sys.argv[0]).rsplit('/', 1)[0], 'components', 'dependencies.json')
    workspace_default_path = os.path.dirname(os.path.dirname(sys.argv[0]))

    parser = argparse.ArgumentParser()
    parser.add_argument('--db-path', default=db_default_path, help=argparse.SUPPRESS)
    parser.add_argument('-w', '--workspace', default=workspace_default_path, help='Path to workspace')
    parser.add_argument('--subdir', default='components', help='Directory holding components')
    parser.add_argument('--type', required=True, help='Type of component to deprecate')
    parser.add_argument('--version', required=True, help='Type of component to deprecate')
    parser.add_argument('-v', '--verbose', action='store_true', default=False, help='Verbose output')
    args = parser.parse_args()

    db_path = args.db_path
    ctype = args.type
    version = args.version
    verbose = args.verbose
    workspace = args.workspace
    subdir = args.subdir

    if ctype == 'python':
        deprecate_python(version, db_path=db_path, workspace=workspace, subdir=subdir, verbose=verbose)

if __name__ == '__main__':
    main()
